<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Markdown基本语法</title>
    <url>/2023/11/05/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><i>markdown:通用html标签</i></p>
<p>标签后要加空格</p>
<p><u>块级元素：至少独占一行</u><br><u>行内元素：只占据自身所需空间</u></p>
<hr>

<p># 标题1<br>## 标题2<br>### 标题3</p>
<h1 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h1><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><hr>

<span id="more"></span>

<p>&gt;引用</p>
<h1 id="效果：-1"><a href="#效果：-1" class="headerlink" title="效果："></a>效果：</h1><blockquote>
<p>引用</p>
</blockquote>
<hr>

<p>有序列表:<br>1. a<br>2. b<br>3. c</p>
<p>无序列表：<br>- A<br>- B<br>- C</p>
<p>任务列表：<br>- [ ] a<br>- [ ] b<br>- [x] c</p>
<h1 id="效果：-2"><a href="#效果：-2" class="headerlink" title="效果："></a>效果：</h1><p>有序列表:</p>
<ol>
<li>a</li>
<li>b</li>
<li>c</li>
</ol>
<p>无序列表：</p>
<ul>
<li>A</li>
<li>B</li>
<li>C</li>
</ul>
<p>任务列表：</p>
<ul>
<li><input disabled="" type="checkbox"> a</li>
<li><input disabled="" type="checkbox"> b</li>
<li><input checked="" disabled="" type="checkbox"> c</li>
</ul>
<hr>

<p>代码块：<br>``` c(此处c表示代码是C语言)<br>int main():<br>{<br>    printf(“Hello world”);<br>}<br>```<br>行内代码:<br>`&#96; printf(Hello wold!)&#96;&#96;;</p>
<h1 id="效果：-3"><a href="#效果：-3" class="headerlink" title="效果："></a>效果：</h1><p>代码块：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>:</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>行内代码:<br><code> printf(Hello wold!)</code>;</p>
<hr>

<p>数学公式：有美元符号$才能识别lateX</p>
<p>$$<br>\frac{\partial f}{\partial x} = 2\sqrt{a}x<br>$$</p>
<p>行内数学公式：<br>$\theta &#x3D; x^2$</p>
<h1 id="效果：-4"><a href="#效果：-4" class="headerlink" title="效果："></a>效果：</h1><p>数学公式：有美元符号$才能识别lateX<br>$$<br>\frac{\partial f}{\partial x} &#x3D; 2\sqrt{a}x<br>$$</p>
<p>行内数学公式：<br>$\theta &#x3D; x^2$</p>
<hr>

<p>表格：“:”决定居中居左具右<br>| 姓名 | 年龄 | 成绩 |<br>| :— | —: | :—: |<br>| 张三 | 22 | 92 |</p>
<h1 id="效果：-5"><a href="#效果：-5" class="headerlink" title="效果："></a>效果：</h1><p>表格：“:”决定居中居左具右</p>
<table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="right">年龄</th>
<th align="center">成绩</th>
</tr>
</thead>
<tbody><tr>
<td align="left">张三</td>
<td align="right">22</td>
<td align="center">92</td>
</tr>
</tbody></table>
<hr>

<p>脚注：<br>脚注[^脚注]<br>[^脚注]:脚注</p>
<h1 id="效果：-6"><a href="#效果：-6" class="headerlink" title="效果："></a>效果：</h1><p>脚注[^脚注]<br>[^脚注]:脚注</p>
<hr>

<p>横线：</p>
<p>- - -或***或_ _ _</p>
<h1 id="效果：第一条虚线"><a href="#效果：第一条虚线" class="headerlink" title="效果：第一条虚线"></a>效果：第一条虚线</h1><hr>
<hr>

<p>链接：<br>[百度](baidu.com “一个搜索引擎”)<br>例子：给标题设置链接<br>请参考[标题1](#标题1)</p>
<p>引用链接：引用需要回车<br>[百度][id],[百度][id],[百度][id]</p>
<p>[id]: baidu.com &quot;一个搜索引擎”</p>
<p>URL:输入网页链接格式，自动识别<br>https:&#x2F;&#x2F;<a href="http://www.baidu.com/">www.baidu.com</a></p>
<h1 id="效果：-7"><a href="#效果：-7" class="headerlink" title="效果："></a>效果：</h1><p>链接：<br><a href="baidu.com" title="一个搜索引擎">百度</a><br>例子：给标题设置链接<br>请参考<a href="#%E6%A0%87%E9%A2%981">标题1</a></p>
<p>引用链接：引用需要回车<br><a href="baidu.com" title="一个搜索引擎">百度</a>,<a href="baidu.com" title="一个搜索引擎">百度</a>,<a href="baidu.com" title="一个搜索引擎">百度</a></p>
<p>URL:输入网页链接格式，自动识别<br><a href="https://www.baidu.com/">https://www.baidu.com</a></p>
<hr>

<p>图片：相对地址、绝对地址、网址链接</p>
<p>![百度](https:&#x2F;&#x2F;pss.bdstatic.com&#x2F;static&#x2F;superman&#x2F;img&#x2F;logo&#x2F;logo_white-d0c9fe2af5.png “百度LOGO”)</p>
<h1 id="效果：-8"><a href="#效果：-8" class="headerlink" title="效果："></a>效果：</h1><p><img src="https://pss.bdstatic.com/static/superman/img/logo/logo_white-d0c9fe2af5.png" alt="百度" title="百度LOGO"></p>
<hr>

<p>*斜体*</p>
<p>**加粗**</p>
<p>&gt;引用</p>
<p>~~删除线~~</p>
<p>&lt;u&gt;下划线&lt;&#x2F;u&gt;</p>
<p>高亮：=&#x3D;高亮&#x3D;&#x3D;</p>
<p>下标：H~2~O</p>
<p>上标：X^2^</p>
<p>表情符号：:smile:<br><br></p>
<h1 id="效果：-9"><a href="#效果：-9" class="headerlink" title="效果："></a>效果：</h1><p><em>斜体</em></p>
<p><strong>加粗</strong></p>
<blockquote>
<p>引用</p>
</blockquote>
<p><del>删除线</del></p>
<p><u>下划线</u></p>
<p>高亮：&#x3D;&#x3D;高亮&#x3D;&#x3D;</p>
<p>下标：H<del>2</del>O</p>
<p>上标：X^2^</p>
<p>表情符号：:smile:</p>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2023/11/06/Linux/</url>
    <content><![CDATA[<blockquote>
<ul>
<li><p>父子进程不共享变量，子进程和父进程分别执行程序</p>
</li>
<li><p>创建子进程（父子进程程序相同，进程号不同）并执行时，父子进程分别为2个程序，同时执行各自程序</p>
</li>
<li><p>线程共享</p>
</li>
<li><p>terminal运行.&#x2F;a.out &amp;，’&amp;’表示后台运行    <a href="https://blog.csdn.net/z19861216/article/details/130848954">相关链接</a></p>
</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/05/HelloWorld/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>实验8</title>
    <url>/2023/11/27/%E5%AE%9E%E9%AA%8C8/</url>
    <content><![CDATA[<h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><blockquote>
<ul>
<li><p><strong>可靠信号</strong>（Reliable Signals）： 这种信号在发送时不会丢失，系统会确保信号最终被接收。当进程处于阻塞状态时，可靠信号会被排队，直到进程解除阻塞后才被传递。SIGINT通常被认为是可靠信号。</p>
</li>
<li><p><strong>不可靠信号</strong>（Unreliable Signals）： 这种信号可能在发送时丢失，而且不会在信号过多导致排队不足时保存。进程在信号未被处理完全之前，可能不会接收到新的信号。SIGIO和SIGURG通常被认为是不可靠信号。</p>
<p>不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。非可靠信号一般都有确定的用途及含义，可靠信号则可以让用户自定义使用。</p>
</li>
</ul>
</blockquote>
<span id="more"></span>

<p><strong>试验：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGINT信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nReceived SIGINT. Processing and saving critical information...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟处理过程</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Critical information processed and saved.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注册SIGINT信号处理函数</span></span><br><span class="line">    signal(SIGINT, signal_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟程序的主要逻辑</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这里添加程序的主要逻辑</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Working...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="/images/Linux_pic/sy8/1.png"></p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> target_process_id;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alarm_handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (signum == SIGALRM) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A: Sending a SIGALRM signal to process %d...\n&quot;</span>, target_process_id);</span><br><span class="line">        kill(target_process_id, SIGALRM);  <span class="comment">// 发送 SIGALRM 信号给程序 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;B_process_id&gt; &lt;timer_seconds&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target_process_id = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> timer_seconds = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 SIGALRM 信号处理函数</span></span><br><span class="line">    signal(SIGALRM, alarm_handler);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A: After %d seconds, send a SIGALRM signal myself.\n&quot;</span>, timer_seconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器</span></span><br><span class="line">    alarm(timer_seconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待定时器触发</span></span><br><span class="line">    pause();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//B.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigalrm_handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (signum == SIGALRM) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B: Receiving a SIGALRM signal. Exiting...\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行程序 B 的其他操作...</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置 SIGALRM 信号处理函数</span></span><br><span class="line">    signal(SIGALRM, sigalrm_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出进程 ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B: My process ID is %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保持程序 B 持续运行</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>结果：</strong></p>
<blockquote>
<p>‘&amp;’表后台运行</p>
</blockquote>
<p><img src="/images/Linux_pic/sy8/2.png"></p>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (signum == SIGQUIT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent: Received SIGQUIT signal. Sending signals to children...\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向两个子进程发送信号</span></span><br><span class="line">        kill(<span class="number">0</span>, SIGUSR1);  <span class="comment">// 向同一进程组的所有进程发送 SIGUSR1 信号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigusr1_handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (signum == SIGUSR1) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child: Received SIGUSR1 signal. Exiting...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置 SIGQUIT 信号处理函数</span></span><br><span class="line">    signal(SIGQUIT, sigquit_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第一个子进程</span></span><br><span class="line">    <span class="type">pid_t</span> child_pid1 = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error creating child process 1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid1 == <span class="number">0</span>) &#123;  <span class="comment">// 子进程1</span></span><br><span class="line">        signal(SIGUSR1, sigusr1_handler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程1执行的任务</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第二个子进程</span></span><br><span class="line">    <span class="type">pid_t</span> child_pid2 = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error creating child process 2&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid2 == <span class="number">0</span>) &#123;  <span class="comment">// 子进程2</span></span><br><span class="line">        signal(SIGUSR1, sigusr1_handler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程2执行的任务</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待子进程退出</span></span><br><span class="line">    <span class="type">int</span> status1, status2;</span><br><span class="line">    waitpid(child_pid1, &amp;status1, <span class="number">0</span>);</span><br><span class="line">    waitpid(child_pid2, &amp;status2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当收到 SIGQUIT 信号时，会执行到这里</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent: Both children have exited. Exiting...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="/images/Linux_pic/sy8/3.png"></p>
<h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PRIMES 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[MAX_PRIMES];</span><br><span class="line"><span class="type">int</span> num_primes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_prime</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= number; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (number % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_sigint</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (signum == SIGINT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nLast prime found: %d\n&quot;</span>, primes[num_primes - <span class="number">1</span>]);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_sigquit</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (signum == SIGQUIT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nAll primes found:\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_primes; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, primes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nExiting...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    signal(SIGINT, handle_sigint);</span><br><span class="line">    signal(SIGQUIT, handle_sigquit);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Searching for primes between 2 and 65535...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">65535</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime(i)) &#123;</span><br><span class="line">            primes[num_primes++] = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印找到的素数</span></span><br><span class="line">            <span class="comment">//printf(&quot;%d &quot;, i);</span></span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加睡眠函数，使效果明显</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="/images/Linux_pic/sy8/4.png"></p>
<h3 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h3><p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayDateTime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> currentTime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">localTime</span>;</span></span><br><span class="line"></span><br><span class="line">    currentTime = time(<span class="literal">NULL</span>);</span><br><span class="line">    localTime = localtime(&amp;currentTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 \033 进行颜色设置，\033[0m 恢复默认颜色</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34;47m%04d-%02d-%02d %02d:%02d:%02d\033[0m\n&quot;</span>,</span><br><span class="line">           localTime-&gt;tm_year + <span class="number">1900</span>, localTime-&gt;tm_mon + <span class="number">1</span>, localTime-&gt;tm_mday,</span><br><span class="line">           localTime-&gt;tm_hour, localTime-&gt;tm_min, localTime-&gt;tm_sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleAlarm</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="comment">// 重置闹钟</span></span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">    displayDateTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注册信号处理函数</span></span><br><span class="line">    signal(SIGALRM, handleAlarm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初次触发闹钟</span></span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 空循环等待信号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="/images/Linux_pic/sy8/5.png"></p>
<p><em>参考例子：</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//digital_clock.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alarm_handler</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(signo == SIGALRM)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="type">char</span> date_str[<span class="number">100</span>];</span><br><span class="line">                <span class="type">char</span> time_str[<span class="number">100</span>];</span><br><span class="line">                <span class="type">time_t</span> t=time(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tp</span>=</span>localtime(&amp;t);</span><br><span class="line">                strftime(date_str, <span class="keyword">sizeof</span>(date_str),<span class="string">&quot;%Y-%m-%d&quot;</span>, tp);</span><br><span class="line">                strftime(time_str, <span class="keyword">sizeof</span>(time_str),<span class="string">&quot;%H:%M:%S&quot;</span>, tp);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033c&quot;</span>); <span class="comment">//清屏命令</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;        \033[35;47m%s\033[0m  &quot;</span>, date_str);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[31;43m%s\033[0m\n&quot;</span>, time_str);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_time</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>( signal(SIGALRM, alarm_handler) == SIG_ERR  )</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;signal SIGALAM error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        alarm(<span class="number">1</span>);</span><br><span class="line">        pause(); <span class="comment">//等待定时器触发完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                show_time();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><code>time_t t = time(NULL);</code></li>
</ol>
<p>这行代码使用 <code>time</code> 函数获取当前时间，并将其表示为一个从 1970 年 1 月 1 日（UNIX 时代开始）到现在的秒数，这个值被存储在 <code>time_t</code> 类型的变量 <code>t</code> 中。<code>time(NULL)</code> 是一种常见的写法，表示获取当前时间。</p>
<ol start="2">
<li><code>struct tm *tp = localtime(&amp;t);</code></li>
</ol>
<p>这行代码使用 <code>localtime</code> 函数将上述获取的当前时间（以秒数为单位）转换为一个 <code>struct tm</code> 结构体，这个结构体描述了日期和时间的各个部分（例如年、月、日、时、分和秒）。<code>localtime</code> 函数返回一个指向这个结构体的指针，该指针被存储在 <code>struct tm</code> 类型的指针变量 <code>tp</code> 中。</p>
<p>通过这两行代码，你得到了一个 <code>structtm</code> 类型的结构体指针 <code>tp</code>，它可以让你访问和操作当前的日期和时间。例如，你可以使用 <code>tp-&gt;tm_year</code> 来获取当前的年份，使用 <code>tp-&gt;tm_mday</code> 来获取当前的月份等等。</p>
</blockquote>
<p><img src="/images/Linux_pic/sy8/6.png"></p>
]]></content>
      <categories>
        <category>Linux实验</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2023/11/29/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="实验项目名称：贪婪算法技术的应用"><a href="#实验项目名称：贪婪算法技术的应用" class="headerlink" title="实验项目名称：贪婪算法技术的应用"></a>实验项目名称：贪婪算法技术的应用</h3><h3 id="一、实验任务和要求"><a href="#一、实验任务和要求" class="headerlink" title="一、实验任务和要求"></a>一、实验任务和要求</h3><blockquote>
<p>1、问题描述<br>2、设计问题求解的算法、并进行代码的编写、调试、运行。<br>3、分析算法的时间复杂度</p>
</blockquote>
<h3 id="二、算法描述"><a href="#二、算法描述" class="headerlink" title="二、算法描述"></a>二、算法描述</h3><p>1）问题描述<br><strong>a</strong>.活动安排问题<br><strong>b</strong>.背包问题</p>
<span id="more"></span>

<p>2）算法描述：<br><strong>a</strong>.活动安排问题：使用贪心算法，先按结束时间排序；第一个活动选择结束时间最早的；再选择开始时间晚于上一个活动的结束时间且结束时间最早的活动，重复该步骤。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体表示活动</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Activity</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="type">int</span> no; <span class="comment">//活动号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照活动结束时间升序排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sortByEndTime</span><span class="params">(<span class="keyword">struct</span> Activity arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j].end &gt; arr[j + <span class="number">1</span>].end) &#123;</span><br><span class="line">                <span class="comment">// 交换活动的位置</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Activity</span> <span class="title">temp</span> =</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印选择的活动</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printActivities</span><span class="params">(<span class="keyword">struct</span> Activity arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    sortByEndTime(arr,n); <span class="comment">// 按照活动结束时间升序排序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Selected Activities:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个活动总是被选中</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//记录上一个被选中的活动</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) &quot;</span>, arr[i].start, arr[i].end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对剩余活动进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前活动的开始时间大于或等于前一个活动的结束时间，则选择该活动</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j].start &gt;= arr[i].end) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) &quot;</span>, arr[j].start, arr[j].end);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 示例活动</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Activity</span> <span class="title">activities</span>[] =</span> &#123;&#123;<span class="number">1</span>, <span class="number">4</span>&#125;, &#123;<span class="number">3</span>, <span class="number">5</span>&#125;, &#123;<span class="number">0</span>, <span class="number">6</span>&#125;, &#123;<span class="number">5</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>&#125;, &#123;<span class="number">5</span>, <span class="number">9</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算活动数组的大小</span></span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(activities) / <span class="keyword">sizeof</span>(activities[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印选择的活动</span></span><br><span class="line">    printActivities(activities, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>b</strong>.背包问题：贪心算法,先按照价值密度（value&#x2F;weight）降序排序，然后尽可能多地装入背包，分为整个装入和部分装入。0-1也按性价比排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体表示物品</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> weight;<span class="comment">//重量</span></span><br><span class="line">	<span class="type">int</span> value;<span class="comment">//价值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照价值密度（value/weight）降序排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sortByValueDensity</span><span class="params">(<span class="keyword">struct</span> Item arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="type">double</span> density1 = (<span class="type">double</span>)arr[j].value / arr[j].weight;</span><br><span class="line">			<span class="type">double</span> density2 = (<span class="type">double</span>)arr[j + <span class="number">1</span>].value / arr[j + <span class="number">1</span>].weight;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (density1 &lt; density2) &#123;</span><br><span class="line">				<span class="comment">// 交换物品的位置</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">Item</span> <span class="title">temp</span> =</span> arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决分数背包问题</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">fractionalKnapsack</span><span class="params">(<span class="keyword">struct</span> Item arr[], <span class="type">int</span> n, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">	sortByValueDensity(arr, n);</span><br><span class="line">	</span><br><span class="line">	<span class="type">double</span> totalValue = <span class="number">0.0</span>;</span><br><span class="line">	<span class="type">int</span> currentWeight = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (currentWeight + arr[i].weight &lt;= capacity) &#123;</span><br><span class="line">			<span class="comment">// 将整个物品放入背包</span></span><br><span class="line">			currentWeight += arr[i].weight;</span><br><span class="line">			totalValue += arr[i].value;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 将物品的一部分放入背包</span></span><br><span class="line">			<span class="type">double</span> remainingCapacity = capacity - currentWeight;</span><br><span class="line">			totalValue += (<span class="type">double</span>)arr[i].value / arr[i].weight * remainingCapacity;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> totalValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 示例物品</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Item</span> <span class="title">items</span>[] =</span> &#123;&#123;<span class="number">10</span>, <span class="number">60</span>&#125;, &#123;<span class="number">20</span>, <span class="number">100</span>&#125;, &#123;<span class="number">30</span>, <span class="number">120</span>&#125;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算物品数组的大小</span></span><br><span class="line">	<span class="type">int</span> n = <span class="keyword">sizeof</span>(items) / <span class="keyword">sizeof</span>(items[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 背包容量</span></span><br><span class="line">	<span class="type">int</span> capacity = <span class="number">50</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 解决分数背包问题并输出结果</span></span><br><span class="line">	<span class="type">double</span> maxValue = fractionalKnapsack(items, n, capacity);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Maximum value in Knapsack = %.2lf\n&quot;</span>, maxValue);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、算法时间复杂度分析"><a href="#三、算法时间复杂度分析" class="headerlink" title="三、算法时间复杂度分析"></a>三、算法时间复杂度分析</h3><p><strong>a</strong>.按结束时间排序函数的时间复杂度为O(n^2^),打印选择活动函数的时间复杂度为O(n),故该算法时间复杂度为O(n^2^)。<br><strong>b</strong>.按照价值密度（value&#x2F;weight）降序排序函数的时间复杂度为 O(n^2^)，解决分数背包问题函数的时间复杂度为O(n),故该算法时间复杂度为O(n^2^)。</p>
<h3 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h3><p><img src="/images/algorithm/greedy/1.PNG"></p>
<p><img src="/images/algorithm/greedy/2.PNG"></p>
<h3 id="五、实验心得"><a href="#五、实验心得" class="headerlink" title="五、实验心得"></a>五、实验心得</h3><blockquote>
<p>贪心算法每次的选择都是基于当前情况下的最优决策。它满足最优子结构的问题，即一个问题的最优解可以通过子问题的最优解来构建。贪心算法不一定能够得到全局最优解，但能够得到局部最优解。简单来说，贪心算法采取局部最优的决策，希望通过每个局部最优解的选择，最终得到全局的最优解。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>实验9</title>
    <url>/2023/11/29/%E5%AE%9E%E9%AA%8C9/</url>
    <content><![CDATA[<h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><blockquote>
<p>​	操作系统中进程通信的作用是允许不同的进程之间交换信息和共享资源，以实现协同工作和数据共享。这有助于多任务处理和分布式系统的有效管理。进程通信可通过各种机制实现，包括共享内存、消息传递、管道等。通过进程通信，不同的进程可以协调完成任务、共享数据，提高系统的整体效率。</p>
</blockquote>
<hr>
<span id="more"></span>

<h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p>进程间通信有多种方式，其中一些主要的方式包括：</p>
<ol>
<li>管道（Pipes）：单向通信，通常用于具有亲缘关系的父子进程间的通信。</li>
<li>消息队列（Message Queues）：允许通过消息进行双向通信，消息被放入队列，其他进程可以读取队列中的消息。</li>
<li>信号（Signals）：用于通知进程发生了特定事件，例如中断或错误。信号机制比较简单，但不能传递大量数据。</li>
<li>共享内存（Shared Memory）：允许多个进程直接访问同一块物理内存，效率较高。需要进行同步以避免冲突。</li>
<li>套接字（Sockets）：提供了网络通信的一种方式，也可用于本地进程通信。适用于不同计算机或同一计算机上的进程。</li>
<li>信号量（Semaphores）：用于进程间同步和互斥，确保在共享资源上的互斥访问。</li>
</ol>
<blockquote>
<p>每种通信方式都有其适用的场景和特点，选择通信方式通常取决于进程间需要传递的数据量、通信的频率、同步需求等因素。</p>
</blockquote>
<hr>
<h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><p><strong>1.</strong>  <strong>fd1 &#x3D; open(“a.txt”, O_RDONLY);</strong></p>
<p>打开文件”a.txt”以只读方式，fd1将被赋予相应的文件描述符值。</p>
<p><strong>2.</strong>  <strong>fd2 &#x3D; open(“b.txt”, O_WRONLY);</strong></p>
<p>打开文件”b.txt”以只写方式，fd2将被赋予相应的文件描述符值。</p>
<p><strong>3.</strong>  <strong>fd3 &#x3D; dup(fd1);</strong></p>
<p>使用dup复制fd1，返回一个新的文件描述符，该描述符是尚未使用的最小值。fd3将获得这个新的文件描述符。</p>
<p><strong>4.</strong>  <strong>fd4 &#x3D; dup2(fd2, 0);</strong></p>
<p>使用dup2复制fd2到0（标准输入），并返回0。fd4将获得这个新的文件描述符。</p>
<p>假设当前终端没有打开任何正常文件，那么：</p>
<ol>
<li><strong>fd1</strong>： 打开”a.txt”，因此其值为 a.txt 的文件描述符。</li>
<li><strong>fd2</strong>： 打开”b.txt”，因此其值为 b.txt 的文件描述符。</li>
<li><strong>fd3</strong>： 使用dup复制fd1，返回的是尚未使用的最小文件描述符，因此 fd3 为 a.txt 的文件描述符。</li>
<li><strong>fd4</strong>： 使用dup2将fd2复制到0（标准输入），返回的是指定的文件描述符，因此 fd4 为 b.txt 的文件描述符。</li>
</ol>
<hr>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> <span class="comment">//printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span> <span class="comment">//open</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span> <span class="comment">//dup fflush close</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 打开文件c.txt以只写方式</span></span><br><span class="line">	<span class="type">int</span> file_fd = open(<span class="string">&quot;c.txt&quot;</span>,O_WRONLY|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 备份标准输出文件描述符</span></span><br><span class="line">	<span class="type">int</span> stdout_backup = dup(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将标准输出重定向到文件c.txt</span></span><br><span class="line">	dup2(file_fd,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一次输出到文件c.txt</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello Linux\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 刷新打开的流</span></span><br><span class="line">	fflush(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 还原标准输出,文件标识符1给stdout_backup，1不再指向file_fd,即还原了</span></span><br><span class="line">	dup2(stdout_backup,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二次输出到屏幕上</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello Linux\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 刷新打开的流</span></span><br><span class="line">	fflush(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭文件描述符</span></span><br><span class="line">	close(file_fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个程序首先打开文件”c.txt”，然后使用dup2将标准输出重定向到该文件。接着执行printf语句，将输出写入文件。之后，通过dup2将标准输出还原到原来的文件描述符，再次执行printf语句，将输出显示在屏幕上。最后，关闭文件描述符。</p>
</blockquote>
<p>在使用 dup 或 dup2 函数进行文件描述符复制时，还原标准输出指的是将原来的标准输出（文件描述符1）恢复到其先前的状态。在涉及重定向标准输出的操作中，程序可能会将标准输出指向其他文件描述符，比如一个文件或管道。为了确保程序后续的输出会回到标准输出，需要在适当的时候还原标准输出。</p>
<p>举例来说，在之前的一个回答中，有这样一段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> stdout_backup = dup(<span class="number">1</span>);   <span class="comment">// 备份标准输出文件描述符</span></span><br><span class="line">dup2(file_fd, <span class="number">1</span>);             <span class="comment">// 将标准输出重定向到文件c.txt</span></span><br><span class="line"><span class="comment">// ... 执行一些操作，比如printf</span></span><br><span class="line">dup2(stdout_backup, <span class="number">1</span>);       <span class="comment">// 还原标准输出</span></span><br></pre></td></tr></table></figure>

<p>这里，stdout_backup &#x3D; dup(1) 备份了标准输出的文件描述符，然后 dup2(file_fd, 1) 将标准输出重定向到文件。之后，通过 dup2(stdout_backup, 1) 将标准输出还原到之前备份的文件描述符，以确保后续的输出会回到标准输出。这个还原操作是为了维持程序的输出正常流程。 </p>
<p><strong>这里，dup(1)创建了标准输出文件描述符的副本，并将其存储在stdout_backup中。稍后，如果标准输出被重定向（例如，使用dup2将其指向一个文件），dup2(stdout_backup, 1)通过将备份的文件描述符复制回标准输出来进行还原。</strong></p>
<p><strong>结果：</strong></p>
<p><img src="/images/Linux_pic/sy9/1.png"></p>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> <span class="comment">//perror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span> <span class="comment">//exit fork close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span> <span class="comment">//strlen</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 50</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 创建管道</span></span><br><span class="line">	<span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">if</span>(pipe(pipe_fd) == <span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;Pipe creation falied&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建子进程</span></span><br><span class="line">	<span class="type">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(child_pid == <span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;Fork failed&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(child_pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">// 父进程</span></span><br><span class="line">		<span class="comment">//close(pipe_fd[0]);// 关闭读取端</span></span><br><span class="line">		<span class="type">char</span> message[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Parent sends:%s\n&quot;</span>,message);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将字符串写入管道</span></span><br><span class="line">		write(pipe_fd[<span class="number">1</span>],message,<span class="built_in">strlen</span>(message) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 等待子进程结束</span></span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 读取子进程传回的消息</span></span><br><span class="line">		<span class="type">char</span> reversed_message[BUFFER_SIZE];</span><br><span class="line">		read(pipe_fd[<span class="number">0</span>],reversed_message,<span class="keyword">sizeof</span>(reversed_message));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Parent receives:%s\n&quot;</span>,reversed_message);</span><br><span class="line"></span><br><span class="line">		close(pipe_fd[<span class="number">1</span>]); <span class="comment">// 关闭写入端</span></span><br><span class="line">		close(pipe_fd[<span class="number">0</span>]); <span class="comment">// 关闭读取端</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 子进程</span></span><br><span class="line">		<span class="comment">//close(pipe_fd[1]);// 关闭写入端</span></span><br><span class="line">		<span class="type">char</span> received_message[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从管道中读取父进程发送的消息</span></span><br><span class="line">		read(pipe_fd[<span class="number">0</span>],received_message,<span class="keyword">sizeof</span>(received_message));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Child receives:%s\n&quot;</span>,received_message);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将字符串倒序</span></span><br><span class="line">		<span class="type">int</span> length = <span class="built_in">strlen</span>(received_message);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">			<span class="type">char</span> temp = received_message[i];</span><br><span class="line">			received_message[i] = received_message[length-i<span class="number">-1</span>];</span><br><span class="line">			received_message[length-i<span class="number">-1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在倒序字符串后附加子进程号</span></span><br><span class="line">		<span class="type">pid_t</span> child_pid = getpid();</span><br><span class="line">		<span class="built_in">snprintf</span>(received_message + length, BUFFER_SIZE - length, <span class="string">&quot;%d&quot;</span>, child_pid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将处理后的消息写回管道</span></span><br><span class="line">	        write(pipe_fd[<span class="number">1</span>], received_message, <span class="built_in">strlen</span>(received_message) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		close(pipe_fd[<span class="number">0</span>]); <span class="comment">// 关闭读取端</span></span><br><span class="line">		close(pipe_fd[<span class="number">1</span>]); <span class="comment">// 关闭写入端</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>父子进程不能关闭写入端和读取端，否则父进程无法接收子进程的字符串</p>
</blockquote>
<p><strong>结果：</strong></p>
<p><img src="/images/Linux_pic/sy9/2.png"></p>
<h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><blockquote>
<p>思路：进程1–&gt;pipe_ps_grep–&gt;进程2–&gt;pipe_grep_wc-&gt;进程3</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pipe_ps_grep[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> pipe_grep_wc[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第一个管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_ps_grep) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe_ps_grep&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> ps_child_pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第一个子进程执行 ps -uax</span></span><br><span class="line">    <span class="keyword">if</span> ((ps_child_pid = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork_ps&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ps_child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*使用STDOUT_FILENO文件描述符指向pipe_ps_grep[1]：写管道，一般情况下对应的文件描述符是4，</span></span><br><span class="line"><span class="comment">        需要关闭原文件描述符*/</span></span><br><span class="line">        dup2(pipe_ps_grep[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        <span class="comment">//关闭原文件描述符</span></span><br><span class="line">        close(pipe_ps_grep[<span class="number">0</span>]);</span><br><span class="line">        close(pipe_ps_grep[<span class="number">1</span>]);</span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;-uax&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp_ps&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第二个管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_grep_wc) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe_grep_wc&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> grep_child_pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第二个子进程执行 grep root</span></span><br><span class="line">    <span class="keyword">if</span> ((grep_child_pid = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork_grep&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (grep_child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">     	<span class="comment">//读pipe_ps_grep[0]端</span></span><br><span class="line">        dup2(pipe_ps_grep[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">        close(pipe_ps_grep[<span class="number">0</span>]);</span><br><span class="line">        close(pipe_ps_grep[<span class="number">1</span>]);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//写pipe_grep_wc[1]端</span></span><br><span class="line">        dup2(pipe_grep_wc[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        close(pipe_grep_wc[<span class="number">0</span>]);</span><br><span class="line">        close(pipe_grep_wc[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        execlp(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;grep&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp_grep&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭第一个管道在父进程中未使用的部分</span></span><br><span class="line">    close(pipe_ps_grep[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_ps_grep[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第三个子进程执行 wc -l</span></span><br><span class="line">    <span class="type">pid_t</span> wc_child_pid;</span><br><span class="line">    <span class="keyword">if</span> ((wc_child_pid = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork_wc&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wc_child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//读pipe_grep_wc[1]端</span></span><br><span class="line">        dup2(pipe_grep_wc[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">        close(pipe_grep_wc[<span class="number">0</span>]);</span><br><span class="line">        close(pipe_grep_wc[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        execlp(<span class="string">&quot;wc&quot;</span>, <span class="string">&quot;wc&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp_wc&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭第二个管道在父进程中未使用的部分</span></span><br><span class="line">    close(pipe_grep_wc[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_grep_wc[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有子进程结束</span></span><br><span class="line">    waitpid(ps_child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    waitpid(grep_child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    waitpid(wc_child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>execlp</code>是一个在Unix&#x2F;Linux系统中用于执行可执行文件的系统调用。它会取代当前进程的内存映像，加载并执行指定的可执行文件。</p>
<p>具体来说，<code>execlp</code>函数的作用是在调用进程中执行一个新的程序。它接受可执行文件的路径，以及一系列的命令行参数，最后一个参数必须是NULL，用于表示参数列表的结束。</p>
<p>在上述C程序的例子中，<code>execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;-uax&quot;, NULL)</code>用于执行<code>ps -uax</code>命令，而<code>execlp(&quot;grep&quot;, &quot;grep&quot;, &quot;root&quot;, NULL)</code>用于执行<code>grep root</code>命令。这两个函数调用使得子进程加载并执行了这两个命令，替代了原有的进程内存映像。</p>
</blockquote>
<p>这是一个使用C语言编写的程序，通过无名管道、fork函数和exec函数实现了模拟命令<code>ps -uax | grep root | wc -l</code>的功能。下面是对程序的解释：</p>
<ol>
<li><p><strong>管道的创建：</strong><br><code>pipe(pipe_ps_grep)</code>: 创建了一个管道，用于连接<code>ps</code>进程和<code>grep</code>进程。</p>
<p>  <code>pipe(pipe_grep_wc)</code>: 创建了另一个管道，用于连接<code>grep</code>进程和<code>wc</code>进程。</p>
</li>
<li><p><strong>ps进程的创建：</strong></p>
<p><code>ps_child_pid = fork()</code>: 创建了第一个子进程，该子进程执行<code>ps -uax</code>命令。</p>
<p>在子进程中，使用<code>dup2</code>将<code>ps</code>的标准输出连接到<code>pipe_ps_grep</code>的写入端口，并通过<code>execlp</code>执行<code>ps</code>命令。</p>
</li>
<li><p><strong>grep进程的创建：</strong></p>
<p><code>grep_child_pid = fork()</code>: 创建了第二个子进程，该子进程执行<code>grep root</code>命令。</p>
<p>在子进程中，使用<code>dup2</code>将<code>ps</code>的标准输出连接到<code>pipe_ps_grep</code>的读取端口，将<code>grep</code>的标准输出连接到<code>pipe_grep_wc</code>的写入端口，并通过<code>execlp</code>执行<code>grep</code>命令。</p>
</li>
<li><p><strong>wc进程的创建：</strong></p>
<p><code>wc_child_pid = fork()</code>: 创建了第三个子进程，该子进程执行<code>wc -l</code>命令。</p>
<p>在子进程中，使用<code>dup2</code>将<code>grep</code>的标准输出连接到<code>pipe_grep_wc</code>的读取端口，并通过<code>execlp</code>执行<code>wc</code>命令。</p>
</li>
<li><p><strong>管道的关闭：</strong></p>
<p>父进程关闭了在子进程中未使用的管道部分。</p>
<blockquote>
<p><code>dup2</code>函数用于复制文件描述符，将一个文件描述符指向另一个文件描述符。当你使用<code>dup2</code>将某个文件描述符指向一个管道的端口时，通常需要关闭原始的文件描述符，因为它已经被复制到了新的文件描述符。</p>
<p>在管道的使用场景中，<code>dup2</code>的典型用法是将标准输入或标准输出重定向到管道的读取端或写入端。一旦重定向完成，原始的标准输入或标准输出就变得多余了，因此可以关闭它。</p>
</blockquote>
</li>
<li><p><strong>等待子进程结束：</strong></p>
<p>使用<code>waitpid</code>函数等待所有子进程执行完毕。</p>
</li>
</ol>
<p>​	这样，通过使用管道连接多个子进程，实现了<code>ps -uax | grep root | wc -l</code>命令的功能。父进程负责创建子进程，并确保正确的管道连接。</p>
<p><strong>结果：</strong></p>
<p><img src="/images/Linux_pic/sy9/3.png"></p>
<h3 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h3><p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//打开一个管道（只读），并执行ps -uax</span></span><br><span class="line">    FILE *pipe_ps = popen(<span class="string">&quot;ps -uax&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pipe_ps == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;popen ps&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开一个管道（只写），并执行ps -uax</span></span><br><span class="line">    FILE *pipe_grep = popen(<span class="string">&quot;grep root&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pipe_grep == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;popen grep&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">size_t</span> bytesRead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从ps的输出读取数据并写入到grep</span></span><br><span class="line">    <span class="keyword">while</span> ((bytesRead = fread(buffer, <span class="number">1</span>, <span class="keyword">sizeof</span>(buffer), pipe_ps)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fwrite(buffer, <span class="number">1</span>, bytesRead, pipe_grep);</span><br><span class="line">        <span class="comment">//size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);</span></span><br><span class="line">        <span class="comment">//size_t fread( void *buffer, size_t size, size_t count, FILE *stream );</span></span><br><span class="line">        <span class="comment">//size--这是要被写入的每个元素的大小，以字节为单位。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭管道</span></span><br><span class="line">    <span class="keyword">if</span> (pclose(pipe_ps) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pclose ps&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pclose(pipe_grep) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pclose grep&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个程序使用两个popen调用分别执行ps -uax和grep root，并将它们通过管道连接起来。然后，通过fread和fwrite从ps的输出读取数据并写入到grep的输入。最后，使用pclose关闭两个管道。</p>
<p>这样，你就完成了模拟ps -uax | grep root的操作，而无需手动创建管道和子进程</p>
</blockquote>
<p><strong>结果：</strong></p>
<p><img src="/images/Linux_pic/sy9/4.png"></p>
<p><code>popen</code>是一个C标准库函数，用于在一个新的进程中打开一个管道并执行一个 shell 命令。它返回一个文件指针，可以用于读取或写入与子进程关联的管道。</p>
<p>函数签名如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>command</code> 参数是要执行的 shell 命令字符串。</li>
<li><code>type</code> 参数是一个字符串，用于指定打开管道的方式。常用的值包括 <code>&quot;r&quot;</code>（只读）和 <code>&quot;w&quot;</code>（只写）。</li>
</ul>
<p>返回值是一个文件指针，可以使用标准文件操作函数（如 <code>fread</code>、<code>fwrite</code>、<code>fclose</code> 等）来读取或写入与子进程关联的管道。</p>
<p>例如，<code>popen(&quot;ps -uax&quot;, &quot;r&quot;)</code> 会执行 <code>ps -uax</code> 命令，并返回一个文件指针，可以用于读取该命令的标准输出。</p>
<p><code>pclose</code> 用于关闭由 <code>popen</code> 打开的管道，并等待相关的子进程结束。它的函数签名如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>stream</code> 是 <code>popen</code> 返回的文件指针。</li>
</ul>
<p>返回值是子进程的终止状态，或者 -1 表示有错误发生。</p>
<p>请注意，<code>popen</code> 和 <code>pclose</code> 在处理大量数据时可能存在一些限制，因为它们依赖于标准I&#x2F;O缓冲区。如果你需要更灵活的控制，或者处理大量数据，可能需要使用其他机制，比如<code>fork</code>和<code>pipe</code>。</p>
]]></content>
      <categories>
        <category>Linux实验</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>分治法</title>
    <url>/2023/12/19/%E5%88%86%E6%B2%BB%E6%B3%95/</url>
    <content><![CDATA[<p>1.<strong>ChessCovering 问题</strong>（棋盘覆盖）</p>
<blockquote>
<p>易知，覆盖任意一个2^k×2^k的特殊棋盘，用到的骨牌数恰好为(4^K-1)&#x2F;3。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 8 <span class="comment">//2^k×2^k</span></span></span><br><span class="line"><span class="type">int</span> Board[N][N];<span class="comment">//定义一个棋盘</span></span><br><span class="line"><span class="type">int</span> tile = <span class="number">1</span>; <span class="comment">//表示骨牌的型号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ChessBoard</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> fr, <span class="type">int</span> fc, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">//r表示棋盘左上角行号，c表示棋盘左上角列号，fr表示特殊方格所在行号，fc表示特殊方格所在列号，size棋盘规格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*原理：为无特殊方格的小棋盘（分之后的）添加特殊方格*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//将棋盘各方格初始化为0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">			Board[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ChessBoard(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, N);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出棋盘</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, Board[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">&quot;PAUSE&quot;</span>); <span class="comment">//因编译器原因，防止运行结果闪退</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ChessBoard</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> fr, <span class="type">int</span> fc, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> t = tile++; 								<span class="comment">//本列用相同数字表示骨牌</span></span><br><span class="line">	<span class="type">int</span> s = size / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fr &lt; r + s &amp;&amp; fc &lt; c + s) 					<span class="comment">//特殊方格在此小棋盘内</span></span><br><span class="line">		ChessBoard(r, c, fr, fc, s);</span><br><span class="line">	<span class="keyword">else</span> &#123; 											<span class="comment">//特殊方格不在此棋盘</span></span><br><span class="line">		Board[r + s - <span class="number">1</span>][c + s - <span class="number">1</span>] = t; 			<span class="comment">//用t号骨牌覆盖右下角</span></span><br><span class="line">		ChessBoard(r, c, r + s - <span class="number">1</span>, c + s - <span class="number">1</span>, s); 	<span class="comment">//继续覆盖其余方格</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后面三个if-else类似于第一个</span></span><br><span class="line">	<span class="keyword">if</span> (fr &gt;= r + s &amp;&amp; fc &lt; c + s) 					<span class="comment">//特殊方格在此小棋盘内（第三象限），人为选定默认认为在</span></span><br><span class="line">		ChessBoard(r + s, c, fr, fc, s); 			<span class="comment">//棋盘左上角坐标为(r+s,c)</span></span><br><span class="line">	<span class="keyword">else</span> &#123; 											<span class="comment">//特殊方格不在此小棋盘内</span></span><br><span class="line">		Board[r + s][c + s - <span class="number">1</span>] = t; 				<span class="comment">//选定(r+s,c+s-1)为特殊方块，用t号骨牌覆盖右上角</span></span><br><span class="line">		ChessBoard(r + s, c, r + s, c + s - <span class="number">1</span>, s); 	<span class="comment">//继续覆盖其余方格</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fr &lt; r + s &amp;&amp; fc &gt;= c + s) 					<span class="comment">//特殊方格在此小棋盘内（第一象限），人为选定默认认为在</span></span><br><span class="line">		ChessBoard(r, c + s, fr, fc, s);</span><br><span class="line">	<span class="keyword">else</span> &#123; 											<span class="comment">//特殊方格不在此小棋盘内</span></span><br><span class="line">		Board[r + s - <span class="number">1</span>][c + s] = t; 				<span class="comment">//用t号骨牌覆盖左下角</span></span><br><span class="line">		ChessBoard(r, c + s, r + s - <span class="number">1</span>, c + s, s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fr &gt;= r + s &amp;&amp; fc &gt;= c + s) 				<span class="comment">//特殊方格在此小棋盘内（第四象限），人为选定默认认为在</span></span><br><span class="line">		ChessBoard(r + s, c + s, fr, fc, s);</span><br><span class="line">	<span class="keyword">else</span> &#123; 											<span class="comment">//特殊方格不在此小棋盘内</span></span><br><span class="line">		Board[r + s][c + s] = t; 					<span class="comment">//用t号骨牌覆盖左上角</span></span><br><span class="line">		ChessBoard(r + s, c + s, r + s, c + s, s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.<strong>最接近点对问题</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个二维点的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于根据x坐标对点进行排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareX</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ((<span class="keyword">struct</span> Point*)a)-&gt;x - ((<span class="keyword">struct</span> Point*)b)-&gt;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于根据y坐标对点进行排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareY</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ((<span class="keyword">struct</span> Point*)a)-&gt;y - ((<span class="keyword">struct</span> Point*)b)-&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两点之间的距离</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">dist</span><span class="params">(<span class="keyword">struct</span> Point p1, <span class="keyword">struct</span> Point p2)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算最小距离的函数</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">min</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (x &lt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在给定点集中找到最小距离的函数,左右区计算最近距离</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">bruteForce</span><span class="params">(<span class="keyword">struct</span> Point P[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">float</span> min_distance = FLT_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dist(P[i], P[j]) &lt; min_distance) &#123;</span><br><span class="line">				min_distance = dist(P[i], P[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> min_distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用分治法找到最小距离的函数</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">closestUtil</span><span class="params">(<span class="keyword">struct</span> Point Px[], <span class="keyword">struct</span> Point Py[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123; <span class="comment">//分为每个区3个，再BF算最小距离</span></span><br><span class="line">		<span class="keyword">return</span> bruteForce(Px, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到中间点</span></span><br><span class="line">	<span class="type">int</span> mid = n / <span class="number">2</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">midPoint</span> =</span> Px[mid];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分别在左右子集中递归查找最小距离</span></span><br><span class="line">	<span class="type">float</span> dl = closestUtil(Px, Py, mid);</span><br><span class="line">	<span class="type">float</span> dr = closestUtil(Px + mid, Py + mid, n - mid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取两个子集中的最小距离</span></span><br><span class="line">	<span class="type">float</span> d = min(dl, dr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建y坐标在(d - 2d, d + 2d)范围内的点集</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">strip</span>[<span class="title">n</span>];</span></span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">abs</span>(Py[i].x - midPoint.x) &lt; d) &#123;</span><br><span class="line">			strip[j] = Py[i];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到strip中的最小距离</span></span><br><span class="line">	<span class="type">float</span> minStrip = bruteForce(strip, j);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回最小距离</span></span><br><span class="line">	<span class="keyword">return</span> min(d, minStrip);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，计算最小距离</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">closest</span><span class="params">(<span class="keyword">struct</span> Point P[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">Px</span>[<span class="title">n</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">Py</span>[<span class="title">n</span>];</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		Px[i] = P[i];</span><br><span class="line">		Py[i] = P[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按x坐标排序</span></span><br><span class="line">	qsort(Px, n, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Point), compareX);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按y坐标排序</span></span><br><span class="line">	qsort(Py, n, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Point), compareY);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用分治法计算最小距离</span></span><br><span class="line">	<span class="keyword">return</span> closestUtil(Px, Py, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">P</span>[] =</span> &#123;</span><br><span class="line">		&#123;<span class="number">8</span>,<span class="number">-15</span>&#125;,&#123;<span class="number">9</span>,<span class="number">-29</span>&#125;,&#123;<span class="number">29</span>,<span class="number">-28</span>&#125;,&#123;<span class="number">-30</span>,<span class="number">-13</span>&#125;,&#123;<span class="number">-3</span>,<span class="number">45</span>&#125;,&#123;<span class="number">-33</span>,<span class="number">-12</span>&#125;,&#123;<span class="number">-7</span>,<span class="number">35</span>&#125;,&#123;<span class="number">47</span>,<span class="number">-45</span>&#125;,&#123;<span class="number">43</span>,<span class="number">-10</span>&#125;,&#123;<span class="number">24</span>,<span class="number">-6</span>&#125;,</span><br><span class="line">		&#123;<span class="number">47</span>,<span class="number">23</span>&#125;,&#123;<span class="number">18</span>,<span class="number">-23</span>&#125;,&#123;<span class="number">-37</span>,<span class="number">16</span>&#125;,&#123;<span class="number">-45</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-43</span>&#125;,&#123;<span class="number">-42</span>,<span class="number">16</span>&#125;,&#123;<span class="number">-16</span>,<span class="number">-50</span>&#125;,&#123;<span class="number">-39</span>,<span class="number">35</span>&#125;,&#123;<span class="number">-48</span>,<span class="number">38</span>&#125;,&#123;<span class="number">-26</span>,<span class="number">-28</span>&#125;,</span><br><span class="line">		&#123;<span class="number">49</span>,<span class="number">31</span>&#125;,&#123;<span class="number">42</span>,<span class="number">-36</span>&#125;,&#123;<span class="number">-50</span>,<span class="number">-33</span>&#125;,&#123;<span class="number">41</span>,<span class="number">36</span>&#125;,&#123;<span class="number">-13</span>,<span class="number">14</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">32</span>,<span class="number">-19</span>&#125;,&#123;<span class="number">0</span>,<span class="number">17</span>&#125;,&#123;<span class="number">-35</span>,<span class="number">15</span>&#125;,&#123;<span class="number">18</span>,<span class="number">-5</span>&#125;,</span><br><span class="line">		&#123;<span class="number">14</span>,<span class="number">46</span>&#125;,&#123;<span class="number">0</span>,<span class="number">23</span>&#125;,&#123;<span class="number">-7</span>,<span class="number">28</span>&#125;,&#123;<span class="number">-45</span>,<span class="number">-28</span>&#125;,&#123;<span class="number">46</span>,<span class="number">10</span>&#125;,&#123;<span class="number">5</span>,<span class="number">-31</span>&#125;,&#123;<span class="number">42</span>,<span class="number">5</span>&#125;,&#123;<span class="number">-28</span>,<span class="number">-22</span>&#125;,&#123;<span class="number">36</span>,<span class="number">-13</span>&#125;,&#123;<span class="number">-24</span>,<span class="number">-39</span>&#125;,</span><br><span class="line">		&#123;<span class="number">-12</span>,<span class="number">-8</span>&#125;,&#123;<span class="number">42</span>,<span class="number">-47</span>&#125;,&#123;<span class="number">29</span>,<span class="number">6</span>&#125;,&#123;<span class="number">30</span>,<span class="number">26</span>&#125;,&#123;<span class="number">30</span>,<span class="number">6</span>&#125;,&#123;<span class="number">-14</span>,<span class="number">-39</span>&#125;,&#123;<span class="number">-49</span>,<span class="number">16</span>&#125;,&#123;<span class="number">39</span>,<span class="number">-20</span>&#125;,&#123;<span class="number">-35</span>,<span class="number">28</span>&#125;,&#123;<span class="number">-33</span>,<span class="number">13</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n = <span class="keyword">sizeof</span>(P) / <span class="keyword">sizeof</span>(P[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最接近点的距离是 %f\n&quot;</span>, closest(P, n));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux期末题目&amp;源码</title>
    <url>/2023/12/19/Linux%E6%9C%9F%E6%9C%AB%E9%A2%98%E7%9B%AE&amp;%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h3 id="1-文件处理"><a href="#1-文件处理" class="headerlink" title="1.文件处理"></a>1.文件处理</h3><p>描述：小林想写一个程序实现文件操作，他想将任意数目的源文件复制到一个目标文件中，若目标文件没有则创建。出现错误时需要显示相应的错误。<br>用法示例：<code>./mycp a.txt dest.txt  ./mycp a.txt b.txt dest.txt</code><br>请编程解决。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mycp.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copyFilesToDestination</span><span class="params">(<span class="type">int</span> numFiles, <span class="type">char</span> *sourceFiles[], <span class="type">char</span> *destinationFile)</span> &#123;</span><br><span class="line">    <span class="comment">// 打开目标文件，使用 &quot;w&quot; 模式，如果文件不存在则创建</span></span><br><span class="line">    FILE *destFile = fopen(destinationFile, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查目标文件是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> (destFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening destination file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为复制设置缓冲区</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历每个待复制的文件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numFiles; ++i) &#123;</span><br><span class="line">        <span class="comment">// 打开当前待复制的源文件</span></span><br><span class="line">        FILE *sourceFile = fopen(sourceFiles[i], <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查源文件是否成功打开</span></span><br><span class="line">        <span class="keyword">if</span> (sourceFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Error opening source file&quot;</span>);</span><br><span class="line">            fclose(destFile);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐块复制源文件到目标文件</span></span><br><span class="line">        <span class="type">size_t</span> bytesRead;</span><br><span class="line">        <span class="keyword">while</span> ((bytesRead = fread(buffer, <span class="number">1</span>, <span class="keyword">sizeof</span>(buffer), sourceFile)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fwrite(buffer, <span class="number">1</span>, bytesRead, destFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭当前源文件</span></span><br><span class="line">        fclose(sourceFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭目标文件</span></span><br><span class="line">    fclose(destFile);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示复制成功的消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d file(s) copied successfully to %s\n&quot;</span>, numFiles, destinationFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 检查命令行参数数量</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s file1 file2 ... fileN destinationFile\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算待复制文件的数量</span></span><br><span class="line">    <span class="type">int</span> numFiles = argc - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用复制文件的函数</span></span><br><span class="line">    copyFilesToDestination(numFiles, argv + <span class="number">1</span>, argv[argc - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-进程通信"><a href="#2-进程通信" class="headerlink" title="2.进程通信"></a>2.进程通信</h3><p>模拟随机密钥，现有8个用户，用户id分别为1,2,3,4,5,6,7,8。程序A定时一次性为8个用户生成一串长度为8的随机数作为密钥并显示用户id和对应密钥，并将其传送给程序B。程序B模拟用户登录，输入用户id和密钥正确才能返回“登录成功”。采用共享内存传递数据，写出程序代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&quot;mmap.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_LENGTH 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_USERS 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_NAME <span class="string">&quot;/myshm&quot;</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">char</span> key[KEY_LENGTH + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 打开或创建共享内存对象</span></span><br><span class="line">	<span class="type">int</span> shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">	<span class="keyword">if</span> (shm_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;shm_open&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置共享内存对象的大小</span></span><br><span class="line">	<span class="keyword">if</span> (ftruncate(shm_fd, NUM_USERS * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> User)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ftruncate&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将共享内存对象映射到进程地址空间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">User</span> *<span class="title">users</span> =</span> (<span class="keyword">struct</span> User *)mmap(<span class="literal">NULL</span>, NUM_USERS * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> User), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (users == MAP_FAILED) &#123;</span><br><span class="line">		perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成一次性的随机数作为密钥，并写入用户信息到共享内存</span></span><br><span class="line">	srand(time(<span class="literal">NULL</span>)); <span class="comment">// 初始化随机数种子</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\033c&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_USERS; ++i) &#123;</span><br><span class="line">			users[i].id = i + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; KEY_LENGTH; ++j) &#123;</span><br><span class="line">				users[i].key[j] = <span class="string">&#x27;0&#x27;</span> + rand() % <span class="number">10</span>; <span class="comment">// 生成数字字符</span></span><br><span class="line">			&#125;</span><br><span class="line">			users[i].key[KEY_LENGTH] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 添加字符串结束符</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 显示生成的用户ID和密钥</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\x1b[32mUser %d:\x1b[0m Key \x1b[31m%s\x1b[0m\n&quot;</span>, users[i].id, users[i].key);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解除共享内存映射</span></span><br><span class="line">	<span class="keyword">if</span> (munmap(users, NUM_USERS * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> User)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭共享内存文件描述符</span></span><br><span class="line">	close(shm_fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mmap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> key[KEY_LENGTH + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开共享内存对象</span></span><br><span class="line">    <span class="type">int</span> shm_fd = shm_open(SHM_NAME, O_RDONLY, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shm_open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将共享内存对象映射到进程地址空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">User</span> *<span class="title">users</span> =</span> (<span class="keyword">struct</span> User *)mmap(<span class="literal">NULL</span>, NUM_USERS * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> User), PROT_READ, MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (users == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取用户信息，并模拟用户登录</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 显示用户ID</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter the ID for User (1-%d): &quot;</span>, NUM_USERS);</span><br><span class="line">        <span class="type">int</span> entered_id;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;entered_id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查用户ID的有效性</span></span><br><span class="line">        <span class="keyword">if</span> (entered_id &lt; <span class="number">1</span> || entered_id &gt; NUM_USERS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid ID. Please enter a valid ID (1-%d).\n&quot;</span>, NUM_USERS);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示用户对应的密钥</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter the key for User %d: &quot;</span>, entered_id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟用户输入</span></span><br><span class="line">        <span class="type">char</span> entered_key[KEY_LENGTH + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, entered_key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较密钥</span></span><br><span class="line">        <span class="type">int</span> user_index = entered_id - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(entered_key, users[user_index].key, KEY_LENGTH) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;User %d: Login successful!\n&quot;</span>, users[user_index].id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;User %d: Login failed. Incorrect key or ID.\n&quot;</span>, users[user_index].id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除共享内存映射</span></span><br><span class="line">    <span class="keyword">if</span> (munmap(users, NUM_USERS * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> User)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭共享内存文件描述符</span></span><br><span class="line">    close(shm_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-线程同步互斥"><a href="#3-线程同步互斥" class="headerlink" title="3.线程同步互斥"></a>3.线程同步互斥</h3><p>用线程同步互斥模拟一个回合制游戏：皮卡丘和卡比兽相互对战。皮卡丘的攻击伤害是5，血量是30。卡比兽的攻击伤害是3，血量是50。轮流攻击对方，即同一时间内只能有一只能攻击对方，另一只只能被攻击。假设皮卡丘先发起攻击，试模拟最后谁赢了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pokemon.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//Pikachu:皮卡丘</span></span><br><span class="line"><span class="comment">//Snorlax：卡比兽</span></span><br><span class="line"><span class="comment">// 定义宝可梦结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pokemon</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> health;</span><br><span class="line">    <span class="type">int</span> attack;</span><br><span class="line">    <span class="type">sem_t</span> turnSemaphore;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：宝可梦攻击</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">attack</span><span class="params">(<span class="keyword">struct</span> Pokemon *attacker, <span class="keyword">struct</span> Pokemon *target)</span> &#123;</span><br><span class="line">    sem_wait(&amp;attacker-&gt;turnSemaphore);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s attacks %s with damage \033[1;31m%d\033[0m\n&quot;</span>, attacker-&gt;name, target-&gt;name, attacker-&gt;attack);</span><br><span class="line">    target-&gt;health -= attacker-&gt;attack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target-&gt;health &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s failed!\n&quot;</span>, target-&gt;name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&#x27;s health: \033[1;32m%d\033[0m, %s&#x27;s health: \033[1;32m%d\033[0m\n&quot;</span>, target-&gt;name, target-&gt;health,attacker-&gt;name,attacker-&gt;health);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;target-&gt;turnSemaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：线程函数，模拟宝可梦对战</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">battle</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pokemon</span> *<span class="title">pikachu</span> =</span> (<span class="keyword">struct</span> Pokemon *)args;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pokemon</span> *<span class="title">snorlax</span> =</span> (<span class="keyword">struct</span> Pokemon *)(args + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Pokemon));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pikachu-&gt;health &gt; <span class="number">0</span> &amp;&amp; snorlax-&gt;health &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        attack(pikachu, snorlax);</span><br><span class="line">        sleep(<span class="number">1</span>);  <span class="comment">// 等待一段时间，模拟回合结束</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (snorlax-&gt;health &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 如果 Snorlax 已经被击败，结束对战</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        attack(snorlax, pikachu);</span><br><span class="line">        sleep(<span class="number">1</span>);  <span class="comment">// 等待一段时间，模拟回合结束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化宝可梦</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pokemon</span> <span class="title">pikachu</span> =</span> &#123;<span class="string">&quot;Pikachu&quot;</span>, <span class="number">30</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pokemon</span> <span class="title">snorlax</span> =</span> &#123;<span class="string">&quot;Snorlax&quot;</span>, <span class="number">50</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;pikachu.turnSemaphore, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 初始值为1表示皮卡丘先攻击</span></span><br><span class="line">    sem_init(&amp;snorlax.turnSemaphore, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="type">pthread_t</span> pikachu_thread, snorlax_thread;</span><br><span class="line">    pthread_create(&amp;pikachu_thread, <span class="literal">NULL</span>, battle, &amp;pikachu);</span><br><span class="line">    pthread_create(&amp;snorlax_thread, <span class="literal">NULL</span>, battle, &amp;snorlax);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    pthread_join(pikachu_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(snorlax_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哪只宝可梦赢得了对战</span></span><br><span class="line">    <span class="keyword">if</span> (pikachu.health &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Snorlax wins!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Pikachu wins!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;pikachu.turnSemaphore);</span><br><span class="line">    sem_destroy(&amp;snorlax.turnSemaphore);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-网络编程"><a href="#4-网络编程" class="headerlink" title="4.网络编程"></a>4.网络编程</h3>]]></content>
      <categories>
        <category>Linux实验</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>暴力算法</title>
    <url>/2023/12/19/%E6%9A%B4%E5%8A%9B%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>a.</strong> 最接近点对问题的BF算法实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">calculateDistance</span><span class="params">(<span class="keyword">struct</span> Point p1, <span class="keyword">struct</span> Point p2)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(p1.x - p2.x, <span class="number">2</span>) + <span class="built_in">pow</span>(p1.y - p2.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">closestPair</span><span class="params">(<span class="keyword">struct</span> Point points[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">float</span> minDistance = FLT_MAX;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="type">float</span> distance = calculateDistance(points[i], points[j]);</span><br><span class="line">			<span class="keyword">if</span> (distance &lt; minDistance) &#123;</span><br><span class="line">				minDistance = distance;</span><br><span class="line">				a = i;</span><br><span class="line">				b = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最近点对的距离是 %f&quot;</span>, minDistance);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最近点对是&lt;%d,%d&gt;,&lt;%d,%d&gt;&quot;</span>, points[a].x, points[a].y, points[b].x, points[b].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">points</span>[] =</span> &#123;</span><br><span class="line">		&#123;<span class="number">8</span>,<span class="number">-15</span>&#125;,&#123;<span class="number">9</span>,<span class="number">-29</span>&#125;,&#123;<span class="number">29</span>,<span class="number">-28</span>&#125;,&#123;<span class="number">-30</span>,<span class="number">-13</span>&#125;,&#123;<span class="number">-3</span>,<span class="number">45</span>&#125;,&#123;<span class="number">-33</span>,<span class="number">-12</span>&#125;,&#123;<span class="number">-7</span>,<span class="number">35</span>&#125;,&#123;<span class="number">47</span>,<span class="number">-45</span>&#125;,&#123;<span class="number">43</span>,<span class="number">-10</span>&#125;,&#123;<span class="number">24</span>,<span class="number">-6</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> n = <span class="keyword">sizeof</span>(points) / <span class="keyword">sizeof</span>(points[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	closestPair(points, n);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>b.</strong> Hamilton回路问题的BF算法实现</p>
<blockquote>
<p>哈密顿图（哈密尔顿图）（英语：Hamiltonian graph，或Traceable graph）是一个无向图，由天文学家哈密顿提出，由指定的起点前往指定的终点，途中经过所有其他节点且只经过一次。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V 4 <span class="comment">// 图的顶点数  </span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printSolution</span><span class="params">(<span class="type">int</span> path[])</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//pos:当前位置，表示当前在构建路径的过程中所处的位置</span></span><br><span class="line"><span class="comment">//函数用于检查在当前路径构建的情况下，是否可以安全地将指定的顶点 v 加入到路径中</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSafe</span><span class="params">(<span class="type">int</span> v, <span class="type">bool</span> graph[V][V], <span class="type">int</span> path[], <span class="type">int</span> pos)</span> &#123;  </span><br><span class="line">	<span class="keyword">if</span> (graph[path[pos - <span class="number">1</span>]][v] == <span class="number">0</span>) &#123;  <span class="comment">//前一个顶点到当前顶点是否有边相连</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pos; i++) &#123;  </span><br><span class="line">		<span class="keyword">if</span> (path[i] == v) &#123;  <span class="comment">//检查路径中是否已经包含了顶点 v</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hamiltonianCycleUtil</span><span class="params">(<span class="type">bool</span> graph[V][V], <span class="type">int</span> path[], <span class="type">int</span> pos)</span> &#123; <span class="comment">//构建哈密尔顿回路的路径</span></span><br><span class="line">	<span class="comment">//最后一个点</span></span><br><span class="line">	<span class="keyword">if</span> (pos == V) &#123;  </span><br><span class="line">		<span class="keyword">if</span> (graph[path[pos - <span class="number">1</span>]][path[<span class="number">0</span>]] == <span class="number">1</span>) &#123;  <span class="comment">//最后一个点和起始点有连接，即构成回路</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt; V; v++) &#123;  </span><br><span class="line">		<span class="keyword">if</span> (isSafe(v, graph, path, pos)) &#123;  </span><br><span class="line">			path[pos] = v;  </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (hamiltonianCycleUtil(graph, path, pos + <span class="number">1</span>)) &#123;  <span class="comment">//构建哈密尔顿回路的路径</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">			&#125;  </span><br><span class="line">			</span><br><span class="line">			path[pos] = <span class="number">-1</span>; <span class="comment">// 否则回溯</span></span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hamiltonianCycle</span><span class="params">(<span class="type">bool</span> graph[V][V])</span> &#123;  </span><br><span class="line">	<span class="type">int</span> path[V];  </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;  </span><br><span class="line">		path[i] = <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line">	path[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 从第一个顶点开始  </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!hamiltonianCycleUtil(graph, path, <span class="number">1</span>)) &#123;  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;No Hamiltonian Cycle exists&quot;</span>);  </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line">	printSolution(path);  </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printSolution</span><span class="params">(<span class="type">int</span> path[])</span> &#123;  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hamiltonian Cycle found: \n&quot;</span>);  </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, path[<span class="number">0</span>]); <span class="comment">//完成循环  </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">	<span class="type">bool</span> graph[V][V] = &#123;  </span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">	&#125;;  </span><br><span class="line">	</span><br><span class="line">	hamiltonianCycle(graph);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BF</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2023/12/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>1.<strong>Trangle Problem</strong>（数字三角形问题）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROWS 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COLS 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算最小路径和并填充值表和路表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(<span class="type">int</span> triangle[ROWS][MAX_COLS], <span class="type">int</span> valueTable[ROWS][MAX_COLS], <span class="type">int</span> pathTable[ROWS][MAX_COLS])</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化最后一行</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; MAX_COLS; j++) &#123;</span><br><span class="line">		valueTable[ROWS - <span class="number">1</span>][j] = triangle[ROWS - <span class="number">1</span>][j];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 从倒数第二层开始向上计算</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = ROWS - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">			<span class="comment">// 当前位置的最小路径和等于当前位置的值加上下一层相邻位置的最小路径和的较小值</span></span><br><span class="line">			valueTable[i][j] = triangle[i][j] + ((valueTable[i + <span class="number">1</span>][j] &lt; valueTable[i + <span class="number">1</span>][j + <span class="number">1</span>]) ? valueTable[i + <span class="number">1</span>][j] : valueTable[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 记录路径信息</span></span><br><span class="line">			pathTable[i][j] = (valueTable[i + <span class="number">1</span>][j] &lt; valueTable[i + <span class="number">1</span>][j + <span class="number">1</span>]) ? j : j + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回最终结果,自底向上</span></span><br><span class="line">	<span class="keyword">return</span> valueTable[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印最短路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printShortestPath</span><span class="params">(<span class="type">int</span> triangle[ROWS][MAX_COLS], <span class="type">int</span> pathTable[ROWS][MAX_COLS])</span> &#123;</span><br><span class="line">	<span class="type">int</span> row = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最短路径: %d&quot;</span>, triangle[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ROWS; i++) &#123;</span><br><span class="line">		<span class="type">int</span> col = pathTable[i - <span class="number">1</span>][row];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; -&gt; %d&quot;</span>, triangle[i][col]);</span><br><span class="line">		row = col;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> triangle[ROWS][MAX_COLS] = &#123;</span><br><span class="line">		&#123;<span class="number">2</span>&#125;,</span><br><span class="line">		&#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">		&#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">11</span>&#125;,</span><br><span class="line">		&#123;<span class="number">12</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> valueTable[ROWS][MAX_COLS];</span><br><span class="line">	<span class="type">int</span> pathTable[ROWS][MAX_COLS];</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> result = minimumTotal(triangle, valueTable, pathTable);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最小路径和: %d\n&quot;</span>, result);</span><br><span class="line">	</span><br><span class="line">	printShortestPath(triangle, pathTable);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.<strong>LCS Promblem</strong>(最长公共子序列)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算最长公共子序列的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lcs</span><span class="params">(<span class="type">char</span> X[], <span class="type">char</span> Y[], <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> dp[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化状态表</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">			dp[i][j] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 填充动态规划表</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">				dp[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (X[i - <span class="number">1</span>] == Y[j - <span class="number">1</span>])<span class="comment">//最后一个相等</span></span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				dp[i][j] = (dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>]) ? dp[i - <span class="number">1</span>][j] : dp[i][j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> X[] = <span class="string">&quot;ABCBDABAABCDBABDDCBABDBCA&quot;</span>;</span><br><span class="line">	<span class="type">char</span> Y[] = <span class="string">&quot;BDCABAABDBCBDABDAAADCABC&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> m = <span class="keyword">sizeof</span>(X) / <span class="keyword">sizeof</span>(X[<span class="number">0</span>]) - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> n = <span class="keyword">sizeof</span>(Y) / <span class="keyword">sizeof</span>(Y[<span class="number">0</span>]) - <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> result = lcs(X, Y, m, n);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最长公共子序列的长度: %d\n&quot;</span>, result);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子段和问题的多算法实现</title>
    <url>/2023/12/19/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%9A%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="最大子段和问题的多算法实现"><a href="#最大子段和问题的多算法实现" class="headerlink" title="最大子段和问题的多算法实现"></a>最大子段和问题的多算法实现</h3><p>1.BF</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">maxSubarrayBruteforce</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxSum = INT_MIN;</span><br><span class="line">    <span class="type">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> endIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//n种可能</span></span><br><span class="line">        <span class="type">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123; <span class="comment">//每种可能每次从j=i开始</span></span><br><span class="line">            currentSum += arr[j];</span><br><span class="line">            <span class="keyword">if</span> (currentSum &gt; maxSum) &#123; <span class="comment">//每次加法后存储最大值</span></span><br><span class="line">                maxSum = currentSum;</span><br><span class="line">                startIndex = i;	<span class="comment">//求到最大后存储当前开始和结束标签</span></span><br><span class="line">                endIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大子段和: %d\n&quot;</span>, maxSum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大子段: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = startIndex; k &lt;= endIndex; k++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">-2</span>, <span class="number">1</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    maxSubarrayBruteforce(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  暴力解法的思路是枚举所有可能的子段，计算它们的和，然后找出最大的和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>2.D&amp;C</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求三个数中的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= b &amp;&amp; a &gt;= c)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b &gt;= a &amp;&amp; b &gt;= c)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在跨越中点的情况下找到最大子段和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCrossingSum</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> leftSum = INT_MIN;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &gt;= low; i--) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; leftSum)</span><br><span class="line">            leftSum = sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rightSum = INT_MIN;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= high; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; rightSum)</span><br><span class="line">            rightSum = sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftSum + rightSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数，找到数组的最大子段和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxSubarraySum</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low == high)</span><br><span class="line">        <span class="keyword">return</span> arr[low];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归求解左右子数组的最大子段和</span></span><br><span class="line">    <span class="type">int</span> leftMax = maxSubarraySum(arr, low, mid);</span><br><span class="line">    <span class="type">int</span> rightMax = maxSubarraySum(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">    <span class="type">int</span> crossMax = maxCrossingSum(arr, low, mid, high);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回左右子数组最大子段和以及跨越中点的最大子段和中的最大值</span></span><br><span class="line">    <span class="keyword">return</span> max(leftMax, rightMax, crossMax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">-2</span>, <span class="number">1</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = maxSubarraySum(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大子段和: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  最大子段和问题也可以使用分治法来解决。</span></span><br><span class="line"><span class="comment">  分治法的基本思想是将问题划分为较小的子问题，</span></span><br><span class="line"><span class="comment">  然后递归地解决这些子问题，</span></span><br><span class="line"><span class="comment">  最后将子问题的解合并得到原问题的解。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>3.DP</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxSubarraySum</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxEndingHere = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> maxSoFar = arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 在当前位置选择要么以前一个位置的子数组结束，要么从当前位置重新开始</span></span><br><span class="line">        maxEndingHere = max(arr[i], maxEndingHere + arr[i]);</span><br><span class="line">        <span class="comment">//最后一个maxEndingHere可能比上一个小了，故不能直接返回maxEndingHere，而要设置一个maxSoFar存当前最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新到目前为止的最大子段和</span></span><br><span class="line">        maxSoFar = max(maxSoFar, maxEndingHere);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSoFar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">-2</span>, <span class="number">1</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = maxSubarraySum(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大子段和: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BF</tag>
        <tag>分治</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程导论概念</title>
    <url>/2024/01/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="第1章-软件工程学概述"><a href="#第1章-软件工程学概述" class="headerlink" title="第1章 软件工程学概述"></a>第1章 软件工程学概述</h3><h4 id="软件危机：计算机软件的开发和维护过程中所遇到的一系列严重问题。"><a href="#软件危机：计算机软件的开发和维护过程中所遇到的一系列严重问题。" class="headerlink" title="软件危机：计算机软件的开发和维护过程中所遇到的一系列严重问题。"></a>软件危机<strong>：</strong>计算机软件的开发和维护过程中所遇到的一系列严重问题。</h4><p><strong>软件危机的典型表现：</strong></p>
<ol>
<li><p>对软件开发成本和进度的估计常常很不准确；</p>
</li>
<li><p>用户对完成的软件系统不满意的现象经常发生；</p>
</li>
<li><p>软件产品的质量往往靠不住；</p>
</li>
<li><p>软件常常是不可维护的；</p>
</li>
<li><p>软件通常没有适当的文档资料；</p>
</li>
<li><p>软件成本在计算机系统总成本中所占的比例逐年上升；</p>
</li>
<li><p>软件开发生产率提高的速度跟不上计算机应用的发展趋势。</p>
</li>
</ol>
<h4 id="产生软件危机的原因"><a href="#产生软件危机的原因" class="headerlink" title="产生软件危机的原因"></a>产生软件危机的原因</h4><ol>
<li><p>软件本身特点造成；对于计算机系统来说，软件是逻辑部件，软件开发过程没有统一的、公认的方法论和规范指导，造成软件维护困难。</p>
</li>
<li><p>软件开发与维护的方法不正确。对软件产品缺乏正确认识，没有真正理解软件产品是一个完整的配置组成。造成开发中制定计划盲目、编程草率，不考虑维护工作的必要性。</p>
</li>
</ol>
<p><strong>主要表现：</strong></p>
<ol>
<li><p>忽视软件需求分析；</p>
</li>
<li><p>认为软件开发就是写程序并使之运行；</p>
</li>
<li><p>轻视软件维护；</p>
</li>
</ol>
<h4 id="解决软件危机的途径"><a href="#解决软件危机的途径" class="headerlink" title="解决软件危机的途径"></a>解决软件危机的途径</h4><ol>
<li><p>推广使用在实践中总结出来的开发软件的成功技术和方法，并研究探索更有效的技术和方法；</p>
</li>
<li><p>开发和使用更好的软件工具<strong>；</strong></p>
</li>
<li><p>良好的组织管理措施。</p>
</li>
</ol>
<h4 id="软件工程的介绍"><a href="#软件工程的介绍" class="headerlink" title="软件工程的介绍"></a>软件工程的介绍</h4><p>早期：软件工程就是为了经济地获得可靠的且能在实际机器上有效地运行的软件，而建立和使用完善的工程原理。</p>
<p>1993年IEEE：软件工程是</p>
<ol>
<li>把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程；</li>
<li>研究（1）中提到的途径。</li>
</ol>
<h4 id="软件工程的本质特性："><a href="#软件工程的本质特性：" class="headerlink" title="软件工程的本质特性："></a>软件工程的本质特性：</h4><ol>
<li><p>软件工程关注于大型程序的构造；</p>
</li>
<li><p>软件工程的中心课题是控制复杂性；</p>
</li>
<li><p>软件经常变化；</p>
</li>
<li><p>开发软件的效率非常重要；</p>
</li>
<li><p>和谐地合作是软件开发的关键；</p>
</li>
<li><p>软件必须有效地支持它的用户；</p>
</li>
<li><p>在软件工程领域中是由具有一种文化背景的人替具有另一种文化背景的人创造产品。</p>
</li>
</ol>
<h4 id="软件工程的基本原理"><a href="#软件工程的基本原理" class="headerlink" title="软件工程的基本原理"></a>软件工程的基本原理</h4><ol>
<li><p>用分阶段的生命周期计划严格管理；</p>
</li>
<li><p>坚持进行阶段评审；</p>
</li>
<li><p>实行严格的产品控制；</p>
</li>
<li><p>采用现代程序设计技术；</p>
</li>
<li><p>结果能清楚地审查；</p>
</li>
<li><p>开发小组的人员应该少而精；</p>
</li>
<li><p>承认不断改进软件工程实践的必要性。</p>
</li>
</ol>
<h4 id="软件工程方法学"><a href="#软件工程方法学" class="headerlink" title="软件工程方法学"></a>软件工程方法学</h4><p><strong>概念：</strong>通常把在软件生命周期全过程中使用的一整套技术方法的集合称为方法学（Methodology），也称为范型（Paradigm）。</p>
<p><strong>软件工程方法学的三要素</strong>：方法、工具和过程</p>
<p><strong>1.</strong> <strong>传统方法学</strong></p>
<p><strong>也称为生命周期方法学或结构化范型。</strong></p>
<p><strong>结构化方法（Structure Method）有：</strong></p>
<ol>
<li><p>结构化设计方法（SD）；</p>
</li>
<li><p>结构化分析方法（SA）；</p>
</li>
<li><p>结构化分析与设计技术（SADT）</p>
</li>
<li><p>JACKSON方法</p>
</li>
<li><p>WARNIER方法</p>
</li>
</ol>
<p><strong>2.</strong> <strong>面向对象方法学</strong></p>
<p><strong>把数据和对数据的操作紧密结合起来的方法，模拟人类认识世界解决问题的方法和过程。</strong></p>
<p><strong>面向对象的方法</strong>&#x3D;对象（属性与服务的封装）+分类+继承+用消息通信</p>
<h4 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h4><p>指软件从提出到最终被淘汰的这个存在期。</p>
<ol>
<li>软件定义；</li>
</ol>
<p>​     A.问题定义 B.可行性研究 C.需求分析</p>
<ol start="2">
<li>软件开发；</li>
</ol>
<p>​     D.总体设计 E.详细设计</p>
<p>​     F.编码和单元测试  G.综合测试</p>
<ol start="3">
<li>运行维护。</li>
</ol>
<p><strong>软件生命周期各个阶段：</strong></p>
<p>  1.问题定义；</p>
<p>  2.可行性研究；</p>
<p>  3.需求分析；</p>
<p>  4.总体设计（概要设计）；</p>
<p>  5.详细设计；</p>
<p>  6.编码与单元测试；</p>
<p>  7.综合测试；</p>
<p>  8.维护。</p>
<p><strong>问题定义报告的内容包括：</strong></p>
<ol>
<li><p>软件项目标题；</p>
</li>
<li><p>软件目标；</p>
</li>
<li><p>软件用户对象；</p>
</li>
<li><p>软件规模。</p>
</li>
</ol>
<h4 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h4><p>为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。</p>
<p>使用资源将输入转化为输出的活动所构成的系统。</p>
<p><strong>瀑布模型:</strong></p>
<ol>
<li><p>阶段间具有顺序性和依赖性</p>
</li>
<li><p>推迟实现的观点</p>
</li>
<li><p>质量保证的观点</p>
</li>
</ol>
<p>优点：采用规范的方法；严格规定每个阶段提交的文档；要求每个阶段交出的产品必须经过验证。</p>
<p><strong>快速原型模型:</strong></p>
<p>优点：不带反馈环，基本上是线性顺序进行。</p>
<p><strong>增量模型:</strong></p>
<p>优点：能较短时间内提交可完成部分工作的产品；可以使用户有充裕的时间学习和适应新产品。</p>
<h3 id="第2章-可行性研究"><a href="#第2章-可行性研究" class="headerlink" title="第2章 可行性研究"></a>第2章 可行性研究</h3><p>可行性研究的<strong>目的</strong>是：用最小的代价在尽可能短的时间内确定问题是否有解，以及是否值得去解。</p>
<h4 id="可行性研究的内容："><a href="#可行性研究的内容：" class="headerlink" title="可行性研究的内容："></a>可行性研究的内容：</h4><ol>
<li><p>技术可行性:使用现有的技术能否实现这个系统</p>
</li>
<li><p>经济可行性:系统的经济效益能否超过它的开发成本</p>
</li>
<li><p>操作可行性:操作可行性评价系统运行后会引起的各方面变化</p>
</li>
<li><p>社会可行性</p>
</li>
</ol>
<h4 id="可行性研究的步骤"><a href="#可行性研究的步骤" class="headerlink" title="可行性研究的步骤"></a>可行性研究的步骤</h4><ol>
<li><p>复查系统规模和目标；</p>
</li>
<li><p>研究目前正在使用的系统；</p>
</li>
<li><p>导出新系统的高层逻辑模型（数据流图、数据字典）；</p>
</li>
<li><p>重新定义问题； </p>
</li>
<li><p>导出和评价供选择的解法（物理解决方案）；</p>
</li>
<li><p>推荐行动方案；</p>
</li>
<li><p>草拟开发计划；</p>
</li>
<li><p>书写文档提交审查。</p>
</li>
</ol>
<h4 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h4><p>数据字典：对数据流图中包含的所有元素的定义的集合；</p>
<p>可行性研究阶段，数据流图与数据字典共同构成系统的逻辑模型。</p>
<p><strong>数据字典应该对下列元素进行定义：</strong></p>
<ol>
<li><p>数据流；</p>
</li>
<li><p>数据元素（数据流分量）；</p>
</li>
<li><p>数据存储；</p>
</li>
<li><p>处理。</p>
</li>
</ol>
<h4 id="成本估计"><a href="#成本估计" class="headerlink" title="成本估计"></a>成本估计</h4><ol>
<li><p>代码行技术:软件成本 <strong>&#x3D;</strong> 每行代码的平均成本×估计的源代码总行数</p>
</li>
<li><p>任务分解技术</p>
</li>
<li><p>自动估计成本技术</p>
</li>
</ol>
<h3 id="第3章-需求分析"><a href="#第3章-需求分析" class="headerlink" title="第3章 需求分析"></a>第3章 需求分析</h3><h4 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h4><p><strong>确定对系统的综合要求</strong></p>
<ol>
<li><p>功能需求</p>
</li>
<li><p>性能需求</p>
</li>
<li><p>可靠性和可用性需求</p>
</li>
<li><p>出错处理需求</p>
</li>
<li><p>接口需求</p>
</li>
<li><p>约束</p>
</li>
<li><p>逆向需求 </p>
</li>
<li><p>将来可能提出的要求</p>
</li>
</ol>
<h4 id="与用户沟通获取需求的方法"><a href="#与用户沟通获取需求的方法" class="headerlink" title="与用户沟通获取需求的方法"></a>与用户沟通获取需求的方法</h4><p><strong>访谈</strong>:</p>
<ol>
<li><p><strong>正式访谈</strong>：系统分析员提出事先准备好的问题。</p>
</li>
<li><p><strong>非正式访谈</strong>：提出一些用户可以自由回答的开放性问题，鼓励被访者说出自己的想法。</p>
</li>
</ol>
<p><strong>面向数据流自顶向下求精</strong></p>
<p><strong>简易的应用规格说明技术</strong></p>
<p><strong>快速建立软件原型</strong> </p>
<h4 id="分析建模与规格说明"><a href="#分析建模与规格说明" class="headerlink" title="分析建模与规格说明"></a><strong>分析建模与规格说明</strong></h4><p><strong>分析建模</strong></p>
<ol>
<li>实体联系图</li>
<li>数据流图</li>
<li>状态转换图</li>
</ol>
<h4 id="数据规范化"><a href="#数据规范化" class="headerlink" title="数据规范化"></a><strong>数据规范化</strong></h4><ol>
<li>第一范式</li>
<li>第二范式</li>
<li>第三范式</li>
</ol>
<h3 id="第5章-总体设计"><a href="#第5章-总体设计" class="headerlink" title="第5章 总体设计"></a>第5章 总体设计</h3><h4 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h4><ol>
<li><p><strong>设想供选择的方案</strong> </p>
</li>
<li><p><strong>选择合理的方案</strong></p>
</li>
</ol>
<p>​	对每个合理的方案要提供：</p>
<pre><code>  A．系统流程图
  
  B．组成系统的物理元素清单
  
   C．成本/效益分析
  
  D．实现这个系统的进度计划
</code></pre>
<ol start="3">
<li><p><strong>推荐最佳方案</strong></p>
</li>
<li><p><strong>功能分解</strong></p>
</li>
<li><p><strong>设计软件结构</strong></p>
</li>
<li><p><strong>数据库设计</strong></p>
</li>
<li><p><strong>制定测试计划</strong></p>
</li>
<li><p><strong>书写文档</strong></p>
<p>   A．系统说明</p>
<p>   B. 用户手册</p>
<p>   C．测试计划</p>
<p>   D．详细的实现计划</p>
</li>
</ol>
<p>​	  E．数据库设计结果</p>
<ol start="9">
<li><strong>审查和复审</strong></li>
</ol>
<h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>模块化</p>
<p>抽象</p>
<p>逐步求精</p>
<p>信息隐蔽和局部化</p>
<h5 id="模块独立："><a href="#模块独立：" class="headerlink" title="模块独立："></a>模块独立：</h5><p><strong>模块的独立性很重要，因为：</strong></p>
<ol>
<li><p>有效的模块化的软件比较容易开发出来;</p>
</li>
<li><p>独立的模块比较容易测试和维护。</p>
</li>
</ol>
<p><strong>模块独立程度可以由两个定性标准度量</strong>：耦合与内聚。</p>
<p><strong>耦合</strong></p>
<p><strong>耦合</strong>：指软件结构内不同模块彼此之间相互依赖（连接）的紧密程度。</p>
<p><strong>模块的偶合分四类：</strong></p>
<ol>
<li><strong>数据耦合</strong></li>
</ol>
<p>​	 两个模块之间只是通过参数交换信息，而且交换的信息仅仅是数据。</p>
<pre><code> 数据耦合是**最低程度**的耦合。 
</code></pre>
<ol start="2">
<li><strong>控制耦合</strong></li>
</ol>
<p>​	两个模块之间所交换的信息包含控制信息。</p>
<pre><code> 控制耦合是中等程度的耦合。
</code></pre>
<ol start="3">
<li><strong>公用耦合</strong></li>
</ol>
<p>​	两个或多个模块通过一个公共区相互作用时的耦合。</p>
<p>​	公共区可以是：全程数据区、共享通信区、内存公共覆盖区、任何介质上的文件、物理设备等。</p>
<p>​	软件结构中存在大量的公用耦合时会给诊断错误带来困难。 </p>
<ol start="4">
<li><strong>内容耦合</strong></li>
</ol>
<p>​	一个模块与另一个模块的内容直接发生联系。</p>
<p>​	内容耦合对维护会带来严重的困难。 </p>
<p>​	内容耦合是<strong>最高程度</strong>的耦合，应该避免采用。</p>
<p><strong>应追求尽可能松散耦合，这样模块间的联系就越小，模块的独立性就越强，对模块的测试、维护就越容易。</strong></p>
<p><strong>尽量使用数据耦合，少用控制耦合，限制公用耦合，完全不用内容偶合</strong>。</p>
<p><strong>内聚</strong></p>
<p><strong>内聚</strong>：一个模块内部各个元素彼此结合的紧密程度。</p>
<ol>
<li><p>功能内聚 ：<strong>功能内聚是最高程度的内聚</strong>。</p>
</li>
<li><p>顺序内聚</p>
<p><code>高内聚</code></p>
<hr>
</li>
<li><p>通信内聚</p>
</li>
<li><p>过程内聚</p>
<p><code>中内聚</code></p>
<hr>
</li>
<li><p>时间内聚</p>
</li>
<li><p>逻辑内聚</p>
</li>
<li><p>偶然内聚：<strong>偶然内聚是最差的一种内聚。</strong></p>
<p><code>地内聚</code></p>
</li>
</ol>
<p><strong>力求做到高内聚，尽量少用中内聚，不用低内聚。</strong></p>
<h4 id="启发式规则"><a href="#启发式规则" class="headerlink" title="启发式规则"></a>启发式规则</h4><ol>
<li><p>改进软件结构提高模块独立性</p>
</li>
<li><p>模块规模应该适中 </p>
</li>
<li><p>深度、宽度、扇出和扇入都应适当</p>
<p>深度：软件结构中控制的层数；</p>
<p>宽度：软件结构内同一个层次上的模块总数的最大值；</p>
<p>扇出：一个模块直接控制（调用）其它模块的数目；</p>
<p>扇入：一个模块被其它模块调用的数目</p>
</li>
<li><p>模块的作用域应该在控制域之内</p>
</li>
</ol>
<p>​	作用域：受该模块内一个判定影响的所有模块的集合。</p>
<p>​	控制域：模块本身以及所有从属于它的模块的集合</p>
<ol start="5">
<li><p>力争降低模块接口的复杂度</p>
</li>
<li><p>设计单入口、单出口的模块 </p>
</li>
<li><p>模块功能应该可以预测</p>
</li>
</ol>
<h4 id="面向数据流的设计方法"><a href="#面向数据流的设计方法" class="headerlink" title="面向数据流的设计方法"></a>面向数据流的设计方法</h4><p><strong>数据流可以分为两种类型：</strong></p>
<ol>
<li>变换型数据流</li>
<li>事务型数据流</li>
</ol>
<h3 id="第6章-详细设计"><a href="#第6章-详细设计" class="headerlink" title="第6章 详细设计"></a>第6章 <strong>详细设计</strong></h3><p><strong>目标</strong>：确定如何具体实现所要求的系统。</p>
<h4 id="结构程序设计"><a href="#结构程序设计" class="headerlink" title="结构程序设计"></a><strong>结构程序设计</strong></h4><p><strong>结构程序设计</strong>： 一种设计程序的技术，它采用自顶向下逐步求精的设计方法和单入口单出口的控制结构。  一种设计程序的技术，它采用自顶向下逐步求精的设计方法和单入口单出口的控制结构。 </p>
<p><strong>使用结构程序设计技术的好处：</strong></p>
<ol>
<li><p>提高软件开发工程的成功率和生产率；</p>
</li>
<li><p>系统有清晰的层次结构，容易阅读理解；</p>
</li>
<li><p>单入口单出口的控制结构，容易诊断纠正；</p>
</li>
<li><p>模块化可以使得软件可以重用；</p>
</li>
<li><p>程序逻辑结构清晰，有利于程序正确性证明。</p>
</li>
</ol>
<p><strong>经典的结构程序设计</strong>：只允许使用顺序、<code>IF_THEN_ELSE</code>选择和<code>DO_WHILE</code>循环；</p>
<p><strong>扩展的结构程序设计</strong>：除了三种基本控制结构，还使用<code>DO_CASE</code>和<code>DO_UNTIL</code>循环；</p>
<p><strong>修正的结构程序设计</strong>：除了三种基本控制结构和两种扩充结构，还使用<code>BREAK</code>等结构。</p>
<h4 id="人机界面设计"><a href="#人机界面设计" class="headerlink" title="人机界面设计"></a><strong>人机界面设计</strong></h4><p><strong>设计问题</strong></p>
<ol>
<li><p>系统响应时间；</p>
</li>
<li><p>用户帮助；</p>
</li>
<li><p>出错信息处理；</p>
</li>
<li><p>命令交互</p>
</li>
</ol>
<p><strong>人机界面设计指南</strong></p>
<ol>
<li><p>一般交互指南；</p>
</li>
<li><p>信息显示指南；</p>
</li>
<li><p>数据输入指南</p>
</li>
</ol>
<h4 id="过程设计的工具"><a href="#过程设计的工具" class="headerlink" title="过程设计的工具"></a><strong>过程设计的工具</strong></h4><p><strong>程序流程图</strong></p>
<p><strong>程序流程图的缺点</strong>：</p>
<ol>
<li><p>程序流程图本质上不是逐步求精的好工具，它诱使程序员过早地考虑程序的控制流程，而不去考虑程序的全局结构。</p>
</li>
<li><p>程序流程图中用箭头代表控制流，因此程序员不受任何约束，可以完全不顾结构程序设计的精神，随意转移控制。</p>
</li>
<li><p>程序流程图不易表示数据结构。</p>
</li>
</ol>
<p><strong>盒图</strong>（N-S图）</p>
<p><strong>PAD图</strong></p>
<p><strong>判定表</strong></p>
<p><strong>判定树</strong></p>
<p><strong>过程设计语言</strong></p>
<h4 id="面向数据结构的设计方法"><a href="#面向数据结构的设计方法" class="headerlink" title="面向数据结构的设计方法"></a>面向数据结构的设计方法</h4><p><strong>Jackson图</strong></p>
<p><strong>改进的Jackson图</strong> </p>
<h4 id="程序复杂度的定量度量"><a href="#程序复杂度的定量度量" class="headerlink" title="程序复杂度的定量度量"></a>程序复杂度的定量度量</h4><p><strong>McCabe方法</strong>:</p>
<ol>
<li><p>流图:仅描绘程序的控制流程</p>
</li>
<li><p>计算环形复杂度的方法</p>
<p>   a.环形复杂度 V（G）等于流图中的区域数；</p>
<p>   b.环形复杂度 V（G）＝E－N+2，其中E是流图中边的条数，N是结点数；</p>
<p>   c.环形复杂度 V（G）＝P＋1，其中P为流图中判定结点的数目。</p>
</li>
<li><p>环形复杂度的用途</p>
<p>对测试难度的一种定量度量，也能对软件最终的可靠性给出某种预测。</p>
</li>
</ol>
<p><strong>Halstead方法</strong>:</p>
<p><strong>根据程序中运算符和操作数的总数来度量程序复杂度。</strong>  </p>
<p>​      <code>N = N1 + N2</code></p>
<p>其中：N定义为程序长度；</p>
<p>​      N1为程序中运算符出现的总次数；</p>
<p>​      N2为操作数出现的总次数。 </p>
<p><strong>Halstead给出预测程序长度的公式为：</strong></p>
<p>​      <code>H = n1log2n1 + n2log2n2</code></p>
<p>其中：H定义为程序预测长度；</p>
<p>​      n1为程序中使用的不同运算符（包括关键字）的个数；</p>
<p>​      n2为程序中使用的不同操作数（变量和常量）的个数。  </p>
<blockquote>
<p>程序的预测长度H和实际程序长度N非常接近。</p>
</blockquote>
<p><strong>Halstead还给出了预测程序中包含错误的个数的公式：</strong></p>
<p>​     <code>E = N log2(n1+n2) / 3000</code></p>
<h3 id="第7章-实现"><a href="#第7章-实现" class="headerlink" title="第7章 实现"></a>第7章 实现</h3><p><strong>编码和测试统称为实现。</strong></p>
<p>编码：把软件设计结果翻译成程序。</p>
<p>测试：检测程序并改正错误的过程。</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p><strong>选择程序设计语言</strong></p>
<ol>
<li><p>汇编语言;</p>
</li>
<li><p>高级语言。</p>
</li>
</ol>
<p><strong>从应用特点看，高级语言可分为：</strong></p>
<ol>
<li>基础语言</li>
<li>结构化语言</li>
<li>专用语言</li>
</ol>
<p><strong>选择一种编程语言的理论标准：</strong></p>
<ol>
<li><p>有理想的模块化机制；</p>
</li>
<li><p>可读性好的控制结构和数据结构；</p>
</li>
<li><p>便于调试和提高软件可靠性；</p>
</li>
<li><p>编译程序发现程序错误的能力强；</p>
</li>
<li><p>有良好的独立编译机制。</p>
</li>
</ol>
<p><strong>主要的实用标准：</strong></p>
<ol>
<li><p>系统用户要求</p>
</li>
<li><p>可以使用的编译程序</p>
</li>
<li><p>可以得到的软件工具</p>
</li>
<li><p>工程规模</p>
</li>
<li><p>程序员知识</p>
</li>
<li><p>软件可移植性要求</p>
</li>
<li><p>软件的应用领域</p>
</li>
</ol>
<p><strong>编码风格：</strong></p>
<p>1.程序内部的文档</p>
<p>2.数据说明</p>
<p>3.语句构造</p>
<p>4.输入&#x2F;输出</p>
<p>5.效率</p>
<p>​	A程序运行时间</p>
<p>​	B．存储器效率</p>
<p>​	C．输入&#x2F;输出效率</p>
<h4 id="软件测试基础"><a href="#软件测试基础" class="headerlink" title="软件测试基础"></a>软件测试基础</h4><p><strong>软件测试的目标</strong></p>
<p>有关测试的一些规则：</p>
<ol>
<li><p>测试是为了发现程序中的错误而执行程序的过程；</p>
</li>
<li><p>好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案；</p>
</li>
<li><p>成功的测试是发现了至今为止尚未发现的错误的测试。</p>
</li>
</ol>
<p><strong>软件测试准则</strong></p>
<ol>
<li><p>所有测试都应该能追溯到用户需求；</p>
</li>
<li><p>应该远在测试前就制定出测试计划；</p>
</li>
<li><p>把Pareto原理应用到软件测试中；</p>
</li>
<li><p>应该从“小规模”测试开始，并逐步进行“大规模”测试；</p>
</li>
<li><p>穷举测试是不可能的；</p>
</li>
<li><p>为了达到最佳测试效果，应该由独立的第三方从事测试工作。</p>
</li>
</ol>
<p><strong>测试方法</strong></p>
<p><strong>黑盒测试</strong>：如果已经知道软件应该具有的功能，可以通过测试来检验是否每个功能都能正常使用，这种测试称黑盒测试。也称功能测试。</p>
<p><strong>白盒测试</strong>：也称结构测试。如果知道软件内部工作过程，可以通过测试来检验软件内部动作是否按照规格说明书的规定正常进行，这种测试称为白盒测试。</p>
<p><strong>软件测试的步骤</strong></p>
<ol>
<li><p>模块测试</p>
</li>
<li><p>子系统测试</p>
</li>
<li><p>系统测试</p>
</li>
<li><p>验收测试</p>
</li>
<li><p>平行运行</p>
</li>
</ol>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>最小的单元-模块</p>
<p><strong>测试重点</strong></p>
<ol>
<li>测试重点</li>
<li>模块接口</li>
<li>局部数据结构</li>
<li>重要的执行路径</li>
<li>出错处理通路</li>
<li>边界条件</li>
</ol>
<p><strong>代码审查</strong></p>
<p><strong>审查小组：</strong></p>
<ol>
<li><p>组长；</p>
</li>
<li><p>程序的设计者；</p>
</li>
<li><p>程序的编写者；</p>
</li>
<li><p>程序的测试者。</p>
</li>
</ol>
<p><strong>计算机测试</strong></p>
<ol>
<li><p>驱动程序:相当于一个“主程序”，用来把测试数据传送给被测试的模块，并打印有关结果。</p>
</li>
<li><p>存根程序:用来代替被测试模块所调用的模块，相当于“虚拟子程序”。</p>
</li>
</ol>
<h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><p><strong>集成测试是组装软件的系统化技术，它将经过单元测试的模块联系在一起进行测试。</strong></p>
<p><strong>由模块组装成程序时有两种方法：</strong></p>
<ol>
<li><p><strong>非渐增式测试方法</strong>:先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序。</p>
</li>
<li><p><strong>渐增式测试方法</strong>:每次增加一个待测试模块，把它同已经测试好的那些模块结合起来进行测试，反复进行直到完成所有模块测试的方法。</p>
</li>
</ol>
<p><strong>使用渐增式测试方法把模块结合到软件系统中去时，有自顶向下和自底向上两种集成方法。</strong></p>
<p><strong>一、自顶向下集成</strong></p>
<p>自顶向下集成是一种递增的装配软件结构的方法，这种方法应用非常广泛。<strong>它需要存根程序，但是不需要驱动程序。</strong></p>
<p>这种方法的思想是：从主控模块（主程序）开始，沿软件的控制层次向下移动，逐渐把各个模块结合起来。 </p>
<p><strong>在自顶向下结合方法中，如何将所有模块组装到软件结构中，又有两种方法：</strong></p>
<ol>
<li><p>深度优先策略</p>
</li>
<li><p>宽度优先策略</p>
</li>
</ol>
<p><strong>二、自底向上集成</strong></p>
<p>自底向上集成方法是从软件结构最底层模块开始进行组装和测试，<strong>它与自顶向下结合方法相反，需要驱动程序，不需要存根程序。</strong></p>
<p><strong>改进：</strong></p>
<ol>
<li><p>改进的自顶向下测试方法；</p>
</li>
<li><p>混合法。</p>
</li>
</ol>
<p><strong>回归测试</strong></p>
<p><strong>指重新执行已经做过的部分测试。</strong></p>
<p><strong>回归测试用于保证由于调试或其他原因引起的程序变化，不会导致额外错误的测试活动。</strong></p>
<hr>
<h4 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h4><p><strong>确认测试的范围</strong>：</p>
<ol>
<li>也称为验收测试，目标是验证软件的有效性。</li>
<li>如果软件的功能和性能符合用户的期待，软件就是有效的。</li>
<li>软件规格说明书是进行确认测试的基础。</li>
</ol>
<p><strong>确认测试的主要特点及内容有：</strong></p>
<ol>
<li><p>某些已经测试过的纯粹技术性的测试项可能不需要再次测试，而对用户特别感兴趣的功能或性能，可能需要增加一些测试；</p>
</li>
<li><p>通常确认测试主要使用实际生产中的数据来进行测试；</p>
</li>
<li><p>确认测试必须有用户的积极参与，甚至以用户为主，可能需要进行一些与用户使用步骤有关的测试。</p>
</li>
</ol>
<p><strong>确认测试一般使用黑盒测试法。</strong></p>
<p><strong>软件配置复查</strong>:</p>
<p>目的：保证软件配置的所有成分都齐全，质量符合要求，文档与程序完全一致，而且已经编好目录。</p>
<p><strong>Alpha和Beta测试</strong></p>
<p><strong>Alpha测试</strong>：用户在<strong>开发者的场所</strong>进行测试，并且在开发者的指导下进行，测试在受控环境中进行，开发者记录发现的错误和问题；</p>
<p><strong>Beta测试</strong>：用户在<strong>一个或多个客户场所</strong>进行测试，不受开发者控制，测试者记录发现的问题和错误，定期将问题报告发送给开发者。</p>
<hr>
<h4 id="白盒测试技术"><a href="#白盒测试技术" class="headerlink" title="白盒测试技术"></a>白盒测试技术</h4><p><strong>逻辑覆盖</strong></p>
<ol>
<li><p><strong>语句覆盖</strong>:设计的测试用例能使程序中每条语句至少执行一次。</p>
</li>
<li><p><strong>判定覆盖</strong>:选取足够的测试用例，使得程序中每个判断的可能结果都至少执行一次，也就是说使程序的每个判断分支至少通过一次。</p>
</li>
<li><p><strong>条件覆盖</strong>:选择足够的测试用例，使得程序中每个判定表达式的每个条件都取到各种可能的结果。</p>
</li>
<li><p><strong>判定&#x2F;条件覆盖</strong>:选取足够的测试用例使得同时满足判定覆盖和条件覆盖的要求。</p>
</li>
<li><p><strong>条件组合覆盖</strong>:选取足够的测试用例，使得每个判定表达式中条件的各种可能的组合都至少出现一次。</p>
</li>
<li><p><strong>点覆盖</strong>:选取足够多的测试用例，使得程序执行路径至少经过程序图中每个节点一次。</p>
</li>
<li><p><strong>边覆盖</strong>:选取足够多的测试用例，使得程序执行路径至少经过程序图中每条边一次。</p>
</li>
<li><p><strong>路径覆盖</strong>:选取足够多的测试用例，使得程序的每条可能路径都至少执行一次。</p>
</li>
</ol>
<hr>
<h4 id="黑盒测试技术"><a href="#黑盒测试技术" class="headerlink" title="黑盒测试技术"></a>黑盒测试技术</h4><p><strong>等价类划分是一种黑盒测试技术。</strong></p>
<p><strong>用等价类划分设计测试用例时，主要分两步：划分等价类、确定测试用例。</strong></p>
<p><strong>边界值分析测试法属黑盒测试。</strong></p>
<p><strong>错误推测法在很大程度上靠直觉和经验进行。</strong></p>
<hr>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p><strong>调试是在测试发现错误之后排除错误的过程。</strong></p>
<p><strong>调试途径</strong>:</p>
<ol>
<li><p>蛮干法</p>
</li>
<li><p>回溯法</p>
</li>
<li><p>原因排除法</p>
</li>
</ol>
<hr>
<h4 id="软件可靠性"><a href="#软件可靠性" class="headerlink" title="软件可靠性"></a>软件可靠性</h4><p><strong>软件可靠性</strong>：是程序在给定的时间间隔内，按照规格说明书的规定成功地运行的概率。</p>
<p><strong>软件可用性</strong>：程序在给定的时间点，按照规格说明书的规定，成功地运行的概率。</p>
<p><strong>可靠性和可用性的区别</strong>：可靠性是在0到t时间间隔内，系统没有失效的概率。而可用性是在t时刻，系统是正常运行的概率。</p>
<p><strong>平均维修时间MTTR</strong>是修复一个故障平均需要用的时间，<strong>取决于</strong>维护人员的技术水平和对系统熟悉程度。</p>
<p><strong>平均无故障时间MTTF</strong>是系统按照规格说明书规定成功地运行的平均时间，<strong>取决于</strong>系统中潜伏的错误数量。 </p>
<p><strong>估计错误总数ET的方法</strong></p>
<ol>
<li><p>植入故障法</p>
</li>
<li><p>分别测试法</p>
</li>
</ol>
<hr>
<h3 id="第8章-维护"><a href="#第8章-维护" class="headerlink" title="第8章 维护"></a>第8章 维护</h3><p><strong>软件维护是软件生命周期的最后一个阶段。</strong></p>
<p><strong>任务</strong>：维护软件的正常运行，不断改进软件的性能和质量，为软件的进一步推广应用和更新替换做积极工作。  </p>
<p><strong>软件交付使用</strong> :</p>
<ol>
<li>软件验收测试以后，就标志着软件设计开发阶段的结束。</li>
<li>而软件交付用户使用，才真正标志漫长的维护阶段的开始。</li>
</ol>
<p><strong>软件交付使用的方式</strong></p>
<ol>
<li>直接方式</li>
</ol>
<p>​	优点：转换简单，费用最省。</p>
<p>​	缺点：风险大</p>
<ol start="2">
<li>并行方式</li>
</ol>
<p>​	优点：</p>
<pre><code>  A. 可以对系统进行全面测试，减少了新系统失灵带来的风险，因为旧系统也仍然存在；
  
  B．用户也能够有一段熟悉新系统的时间。
</code></pre>
<p>​	缺点：</p>
<pre><code> 所需费用较高，双系统要投入更多的人力财力。
</code></pre>
<ol start="3">
<li>逐步方式</li>
</ol>
<p><strong>软件维护的定义</strong>:在软件已经交付使用后，为了改正错误或满足新的需要而进行修改的过程。</p>
<p><strong>软件维护的原因</strong></p>
<ol>
<li><p>改正在特定使用条件下暴露出来的一些潜在程序错误或设计缺陷；</p>
</li>
<li><p>因在软件使用过程中数据环境发生变化（如所要处理的数据发生变化）或处理环境发生变化（如硬件或软件操作系统等发生变化），需要修改软件，以适应这种变化；</p>
</li>
<li><p>用户和数据处理人员在使用时常提出改进现有功能、增加新功能、以及改善总体性能的要求，为满足这些要求，需要修改软件。</p>
</li>
</ol>
<p><strong>软件维护的类型</strong></p>
<ol>
<li><p>改正性维护</p>
</li>
<li><p>适应性维护</p>
</li>
<li><p>完善性维护</p>
</li>
<li><p>预防性维护</p>
</li>
</ol>
<p><strong>完善性维护占软件维护工作的大部分。</strong></p>
<hr>
<h4 id="软件维护的特点"><a href="#软件维护的特点" class="headerlink" title="软件维护的特点"></a>软件维护的特点</h4><p><strong>结构化维护与非结构化维护的差别</strong>:</p>
<ol>
<li><strong>非结构化维护</strong></li>
</ol>
<p>​	软件配置的唯一成分是代码，维护从评价程序代码开始，对软件结构、数据结构、系统接口、设计约束等常产生误解，不能进行回归	测试，维护代价大。  </p>
<ol start="2">
<li><p><strong>结构化维护</strong></p>
<p>   有完整的软件配置，维护从评价设计文档开始，确定软件结构、性能和接口特点，现修改设计，接着修改代码，再进行回归测试。</p>
</li>
</ol>
<p><strong>软件维护的典型问题</strong>:</p>
<ol>
<li><p>如果维护时只有程序代码而没有注释说明，维护起来就相当困难；</p>
</li>
<li><p>由于软件维护阶段时间长，软件开发人员经常流动，所以在维护时，不可能所有的维护工作都依靠原来的开发人员。这会使得维护工作量增加；</p>
</li>
<li><p>软件没有足够的文档资料，或者程序修改后与文档资料不一致；</p>
</li>
<li><p>绝大多数软件在设计时没有考虑将来的修改，所以建议采用功能独立的模块化设计原则，增加软件的可维护性；</p>
</li>
<li><p>软件维护被许多人视为一种毫无吸引力的工作，因为维护工作常常受到挫折。</p>
</li>
</ol>
<hr>
<h4 id="软件维护过程"><a href="#软件维护过程" class="headerlink" title="软件维护过程"></a>软件维护过程</h4><ol>
<li><p>维护组织 </p>
</li>
<li><p>维护报告</p>
</li>
</ol>
<p>​	根据软件问题报告（维护要求），作出的软件修改报告包含的信息主要有：</p>
<p>​	1）满足维护要求表中提出的要求所需要的工作量；</p>
<p>​	2）维护要求的性质；</p>
<p>​	3）这项要求的优先次序；</p>
<p>​	4）与修改有关的事后数据（如测试数据等）。</p>
<ol start="3">
<li><p>维护的事件流 </p>
</li>
<li><p>保存维护记录</p>
</li>
</ol>
<p>​	程序标识源语句数；机器指令数；使用的程序设计语言；程序安装的日期；自安装以来程序运行次数；</p>
<ol start="5">
<li>评价维护活动</li>
</ol>
<p>​	1）每次程序运行平均失效的次数；</p>
<p>​	2）用于每一类维护活动的总人时数；</p>
<p>​	3）平均每个程序、每种维护类型所做的程序变动数；</p>
<p>​	4）维护过程中增加或删除一个源语句平均花费的人时数；</p>
<p>​	5）维护每种语言平均花费的人时数；</p>
<p>​	6）一张维护要求表的平均周转时间；</p>
<p>​	7）不同维护类型所占的百分比。</p>
<hr>
<h4 id="软件的可维护性"><a href="#软件的可维护性" class="headerlink" title="软件的可维护性"></a>软件的可维护性</h4><p><strong>决定软件可维护性的因素</strong>：</p>
<ol>
<li><p>可理解性</p>
</li>
<li><p>可测试性</p>
</li>
<li><p>可修改性</p>
</li>
<li><p>可移植性</p>
</li>
<li><p>可重用性</p>
</li>
</ol>
<p><strong>文档</strong>：影响软件可维护性的决定因素</p>
<ol>
<li><p><strong>用户文档</strong>：主要描述系统功能和使用方法，并不关心这些功能是怎样实现的。</p>
</li>
<li><p><strong>系统文档</strong>：描述系统设计、实现和测试等各方法的内容。</p>
</li>
<li><p><strong>用户文档</strong></p>
</li>
</ol>
<p>​    1）功能描述；</p>
<p>​    2）安装文档；</p>
<p>​    3）使用手册；</p>
<p>​    4）参考手册；</p>
<p>​    5）操作员指南；</p>
<ol start="2">
<li><strong>系统文档</strong></li>
</ol>
<p><strong>可维护性复审</strong></p>
<p><strong>测试结束时进行正式的可维护性复审，称为配置复审，目的是：保证软件配置的所有成分是完整的、一致的和可理解的。</strong></p>
<hr>
<h3 id="第9章-面向对象方法学引论"><a href="#第9章-面向对象方法学引论" class="headerlink" title="第9章 面向对象方法学引论"></a>第9章 面向对象方法学引论</h3><h4 id="面向对象方法学概述"><a href="#面向对象方法学概述" class="headerlink" title="面向对象方法学概述"></a>面向对象方法学概述</h4><p><strong>面向对象方法的优点</strong>:</p>
<ol>
<li><p>与人们习惯的思维方法一致；</p>
</li>
<li><p>稳定性好；</p>
</li>
<li><p>可重用性好；</p>
</li>
<li><p>较易开发大型软件产品；</p>
</li>
<li><p>可维护性好。</p>
</li>
</ol>
<p><strong>对象的特点</strong>:</p>
<ol>
<li><p>以数据为中心；</p>
</li>
<li><p>对象是主动的；</p>
</li>
<li><p>实现了数据封装；</p>
</li>
<li><p>本质上具有并行性；</p>
</li>
<li><p>模块独立性好。</p>
</li>
</ol>
<p><strong>对象是具有相同状态的一组操作的集合。</strong></p>
<p><strong>类就是对具有相同数据和相同操作的一组相似对象的定义</strong></p>
<p><strong>方法，是对象所能执行的操作。</strong></p>
<p><strong>消息就是用来请求对象执行某个处理或回答某些信息的要求。</strong></p>
<p><strong>属性，是类中定义的数据。</strong></p>
<p><strong>封装就是信息隐藏，通过封装对外界隐藏了对象的实现细节。</strong></p>
<p><strong>继承，是指能够直接获得已有的性质和特征，而不必重复定义它们。</strong></p>
<p><strong>多态性，指子类对象可以象父类对象那样使用，同样的消息既可以发送给父类对象，也可以发送给子类对象。</strong></p>
<p><strong>重载</strong>：1. 函数重载 2. 运算符重载</p>
<hr>
<p><strong>面向对象建模</strong></p>
<ol>
<li><p><strong>对象模型</strong>：描述系统的数据结构；</p>
</li>
<li><p><strong>动态模型</strong>：描述系统的控制结构；</p>
</li>
<li><p><strong>功能模型</strong>：描述系统的功能。</p>
</li>
</ol>
<p><strong>对象模型是最基本、最重要的。</strong></p>
<p><strong>泛化（继承）</strong>:</p>
<p><strong>1）普通泛化</strong></p>
<hr>
<h3 id="第11章-面向对象设计"><a href="#第11章-面向对象设计" class="headerlink" title="第11章 面向对象设计"></a>第11章 面向对象设计</h3><p><strong>面向对象设计的准则</strong>：</p>
<ol>
<li><p>模块化：对象就是模块。它把数据结构和操作（方法）紧密地结合在一起构成模块。</p>
</li>
<li><p>抽象：类实际上是一种抽象数据类型</p>
</li>
<li><p>信息隐蔽：信息隐蔽通过对象的封装性实现</p>
</li>
<li><p>弱耦合</p>
</li>
</ol>
<p>​	对象间的耦合有两大类：a.交互耦合 b.继承偶合</p>
<ol start="5">
<li><p>强内聚</p>
</li>
<li><p>可重用</p>
</li>
</ol>
<hr>
<h4 id="启发规则"><a href="#启发规则" class="headerlink" title="启发规则"></a>启发规则</h4><p><strong>1. 设计结果应该清晰易懂；</strong></p>
<p>​	影响的主要因素：1.用词一致；2.使用已有的协议；3.减少消息模式的数目；4.避免模糊的定义。</p>
<p><strong>2.一般—特殊结构的深度应适当</strong></p>
<p><strong>3. 设计简单的类</strong>：<strong>设计小而简单的类，便于开发和管理；</strong></p>
<p>​	<strong>注意几点：</strong></p>
<p>​	1.避免包含过多的属性；</p>
<p>​	2.有明确的定义；</p>
<p>​	3.尽量简化对象之间的合作关系；</p>
<p>​	4.不要提供太多服务。</p>
<p><strong>4.使用简单的协议</strong></p>
<p><strong>5.使用简单的服务</strong></p>
<p><strong>6.把设计变动减至最小</strong></p>
<hr>
<h4 id="软件重用"><a href="#软件重用" class="headerlink" title="软件重用"></a>软件重用</h4><p><strong>重用的三个层次：</strong></p>
<p>​    1）知识重用；</p>
<p>​    2）方法和标准的重用；</p>
<p>​    3）软件成分的重用。</p>
<p><strong>软件成分的重用级别：</strong></p>
<p>  1）代码重用</p>
<p>​    a. 源代码剪贴；</p>
<p>​    b. 源代码包含；</p>
<p>​    c. 继承；</p>
<p>  2）设计结果重用</p>
<p>  3）分析结果重用</p>
<p><strong>典型的可重用软件成分</strong></p>
<p>  <strong>1）项目计划；          2）成本计划；</strong></p>
<p>  <strong>3）体系结构；          4）需求模型和规格说明；</strong></p>
<p>  <strong>5）设计；              6）源代码；</strong></p>
<p>  <strong>7）用户文档和技术文档；8）用户界面；</strong></p>
<p>  <strong>9）数据；              10）测试用例。</strong></p>
<hr>
<h4 id="设计问题域子系统"><a href="#设计问题域子系统" class="headerlink" title="设计问题域子系统"></a>设计问题域子系统</h4><p><strong>1. 调整需求</strong></p>
<p><strong>2. 重用已有的类</strong></p>
<p><strong>3. 组合问题域的类</strong></p>
<p><strong>4. 增添基类以定义公共函数集合</strong></p>
<p><strong>5. 调整继承层次</strong></p>
<hr>
<h4 id="设计人机交互子系统"><a href="#设计人机交互子系统" class="headerlink" title="设计人机交互子系统"></a><strong>设计人机交互子系统</strong></h4><p><strong>设计人机交互子系统的策略：</strong></p>
<ol>
<li><p>分类用户；</p>
</li>
<li><p>描述用户；</p>
</li>
<li><p>设计命令层次；</p>
</li>
<li><p>设计人机交互类。</p>
</li>
</ol>
<hr>
<h4 id="设计数据管理子系统"><a href="#设计数据管理子系统" class="headerlink" title="设计数据管理子系统"></a>设计数据管理子系统</h4><p><strong>选择数据存储管理模式</strong></p>
<ol>
<li><p>文件管理系统</p>
</li>
<li><p>关系数据库管理系统</p>
</li>
<li><p>面向对象数据库管理系统</p>
</li>
</ol>
<hr>
<p><strong>面向对象语言的优点：</strong></p>
<ol>
<li>一致的表示方法</li>
<li>可重用性</li>
<li>可维护性</li>
</ol>
<p><strong>选择面向对象语言时应考虑的技术特点：</strong></p>
<ol>
<li><p>支持类与对象概念的机制</p>
</li>
<li><p>实现整体－部分（聚集）结构的机制</p>
</li>
<li><p>实现一般－特殊（泛化）结构的机制</p>
</li>
<li><p>实现属性和服务的机制</p>
</li>
<li><p>类型检查</p>
</li>
<li><p>类库</p>
</li>
<li><p>效率</p>
</li>
<li><p>持久保存对象</p>
</li>
<li><p>参数化类</p>
</li>
<li><p>开发环境</p>
</li>
</ol>
<p><strong>选择面向对象语言应考虑的因素：</strong></p>
<ol>
<li><p>将来能否占主导地位</p>
</li>
<li><p>可重用性</p>
</li>
<li><p>类库和开发环境</p>
</li>
<li><p>其他因素</p>
</li>
</ol>
<hr>
<h4 id="程序设计风格"><a href="#程序设计风格" class="headerlink" title="程序设计风格"></a>程序设计风格</h4><ol>
<li><strong>提高可重用性</strong></li>
<li><strong>提高可扩充性</strong></li>
<li><strong>提高健壮性</strong></li>
</ol>
<hr>
<p><strong>面向对象的集成测试</strong>：</p>
<p><strong>两种不同的测试策略：</strong></p>
<ol>
<li><p>基于<strong>线程</strong>的测试:将响应系统的一个输入或一个事件所需要的哪些类集成起来测试。</p>
</li>
<li><p>基于<strong>使用</strong>的测试先测试独立类，再测试使用独立类的下一层次的类（依赖类），重复直至完毕。</p>
</li>
</ol>
<p><strong>测试类的方法</strong>:</p>
<ol>
<li><p>随机测试</p>
</li>
<li><p>划分测试</p>
</li>
<li><p>基于故障的测试</p>
</li>
</ol>
<p><strong>集成测试方法</strong>:</p>
<p><strong>1. 多类测试</strong></p>
<p><strong>2. 从动态模型导出测试用例</strong></p>
]]></content>
      <categories>
        <category>软件工程导论</category>
      </categories>
      <tags>
        <tag>软件工程导论</tag>
      </tags>
  </entry>
  <entry>
    <title>问题解决：mybatis插入数据中文乱码</title>
    <url>/2024/05/10/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9Amybatis%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h3 id="问题解决：使用Mybatis向数据库插入数据时，中文数据乱码？"><a href="#问题解决：使用Mybatis向数据库插入数据时，中文数据乱码？" class="headerlink" title="问题解决：使用Mybatis向数据库插入数据时，中文数据乱码？"></a>问题解决：使用Mybatis向数据库插入数据时，中文数据乱码？</h3><hr>
<ul>
<li><p>首先，检查数据库设置是否为UTF-8，如果是数据库设置编码问题，则改正。</p>
</li>
<li><p>如果问题依旧无法解决，则向Mybatis的核心配置文件mybatis-config.xml中的数据库环境配置中的<code>url</code>添加以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;&quot;/&gt;</span><br></pre></td></tr></table></figure>

</li>
<li><p>SpringBoot中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/shop?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC</span><br></pre></td></tr></table></figure>

<pre><code class="spring.datasource.url=jdbc:mysql://localhost:3306/shop?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC">
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis插入中文时乱码</title>
    <url>/2024/05/30/MyBatis%E6%8F%92%E5%85%A5%E4%B8%AD%E6%96%87%E6%97%B6%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h3 id="问题解决：使用Mybatis向数据库插入数据时，中文数据乱码？"><a href="#问题解决：使用Mybatis向数据库插入数据时，中文数据乱码？" class="headerlink" title="问题解决：使用Mybatis向数据库插入数据时，中文数据乱码？"></a>问题解决：使用Mybatis向数据库插入数据时，中文数据乱码？</h3><hr>
<ul>
<li><p>首先，检查数据库设置是否为UTF-8，如果是数据库设置编码问题，则改正。</p>
</li>
<li><p>如果问题依旧无法解决，则向Mybatis的核心配置文件mybatis-config.xml中的数据库环境配置中的<code>url</code>添加以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis笔记</title>
    <url>/2024/05/30/MyBatis%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>一、MyBatis简介</strong><br>1 、MyBatis历史<br>2 、MyBatis特性<br>3 、MyBatis下载<br>4 、和其它持久化层技术对比<br><strong>二、搭建MyBatis</strong><br>1 、开发环境<br>2 、创建maven工程<br>a&gt;打包方式：jar<br>b&gt;引入依赖<br>3 、创建MyBatis的核心配置文件<br>4 、创建mapper接口<br>5 、创建MyBatis的映射文件<br>6 、通过junit测试功能<br>7 、加入log4j日志功能<br>a&gt;加入依赖<br>b&gt;加入log4j的配置文件<br><strong>三、核心配置文件详解<br>四、MyBatis的增删改查<br>五、MyBatis获取参数值的两种方式（重点）</strong><br>1 、单个字面量类型的参数<br>2 、多个字面量类型的参数<br>3 、map集合类型的参数<br>4 、实体类类型的参数<br>5 、使用@Param标识参数<br><strong>六、MyBatis的各种查询功能</strong><br>1 、查询一个实体类对象<br>2 、查询一个list集合<br>3 、查询单个数据<br>4 、查询一条数据为map集合<br>5 、查询多条数据为map集合<br>方式一：<br>方式二：<br><strong>七、特殊SQL的执行</strong><br>1 、模糊查询<br>2 、批量删除<br>3 、动态设置表名<br>4 、添加功能获取自增的主键<br><strong>八、自定义映射resultMap</strong><br>1 、resultMap处理字段和属性的映射关系<br>2 、多对一映射处理<br>a&gt;级联方式处理映射关系<br>b&gt;使用association处理映射关系<br>c&gt;分步查询<br>3 、一对多映射处理<br>a&gt;collection<br>b&gt;分步查询<br><strong>九、动态SQL</strong><br>1 、if<br>2 、where<br>3 、trim<br>4 、choose、when、otherwise<br>5 、foreach<br>6 、SQL片段<br><strong>十、MyBatis的缓存</strong></p>
<p>1 、MyBatis的一级缓存<br>2 、MyBatis的二级缓存<br>3 、二级缓存的相关配置<br>4 、MyBatis缓存查询的顺序<br>5 、整合第三方缓存EHCache<br>a&gt;添加依赖<br>b&gt;各jar包功能<br>c&gt;创建EHCache的配置文件ehcache.xml<br>d&gt;设置二级缓存的类型<br>e&gt;加入logback日志<br>f&gt;EHCache配置文件说明<br><strong>十一、MyBatis的逆向工程</strong><br>1 、创建逆向工程的步骤<br>a&gt;添加依赖和插件<br>b&gt;创建MyBatis的核心配置文件<br>c&gt;创建逆向工程的配置文件<br>d&gt;执行MBG插件的generate目标<br>2 、QBC查询<br><strong>十二、分页插件</strong><br>1 、分页插件使用步骤<br>a&gt;添加依赖<br>b&gt;配置分页插件<br>2 、分页插件的使用</p>
<h1 id="一、MyBatis简介"><a href="#一、MyBatis简介" class="headerlink" title="一、MyBatis简介"></a>一、MyBatis简介</h1><h2 id="1-、MyBatis历史"><a href="#1-、MyBatis历史" class="headerlink" title="1 、MyBatis历史"></a>1 、MyBatis历史</h2><h4 id="MyBatis最初是Apache的一个开源项目-iBatis-2010年-6-月这个项目由Apache-Software-Foundation迁"><a href="#MyBatis最初是Apache的一个开源项目-iBatis-2010年-6-月这个项目由Apache-Software-Foundation迁" class="headerlink" title="MyBatis最初是Apache的一个开源项目 iBatis , 2010年 6 月这个项目由Apache Software Foundation迁"></a>MyBatis最初是Apache的一个开源项目 iBatis , 2010年 6 月这个项目由Apache Software Foundation迁</h4><h4 id="移到了Google-Code。随着开发团队转投Google-Code旗下，-iBatis3-x正式更名为MyBatis。代码于"><a href="#移到了Google-Code。随着开发团队转投Google-Code旗下，-iBatis3-x正式更名为MyBatis。代码于" class="headerlink" title="移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于"></a>移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于</h4><h4 id="2013-年-11-月迁移到Github。"><a href="#2013-年-11-月迁移到Github。" class="headerlink" title="2013 年 11 月迁移到Github。"></a>2013 年 11 月迁移到Github。</h4><h4 id="iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。-iBatis提供的持久层框架"><a href="#iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。-iBatis提供的持久层框架" class="headerlink" title="iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架"></a>iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架</h4><h4 id="包括SQL-Maps和Data-Access-Objects（DAO）。"><a href="#包括SQL-Maps和Data-Access-Objects（DAO）。" class="headerlink" title="包括SQL Maps和Data Access Objects（DAO）。"></a>包括SQL Maps和Data Access Objects（DAO）。</h4><h2 id="2-、MyBatis特性"><a href="#2-、MyBatis特性" class="headerlink" title="2 、MyBatis特性"></a>2 、MyBatis特性</h2><h4 id="1-）-MyBatis-是支持定制化-SQL、存储过程以及高级映射的优秀的持久层框架"><a href="#1-）-MyBatis-是支持定制化-SQL、存储过程以及高级映射的优秀的持久层框架" class="headerlink" title="1 ） MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架"></a>1 ） MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架</h4><h4 id="2-）-MyBatis-避免了几乎所有的-JDBC-代码和手动设置参数以及获取结果集"><a href="#2-）-MyBatis-避免了几乎所有的-JDBC-代码和手动设置参数以及获取结果集" class="headerlink" title="2 ） MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集"></a>2 ） MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</h4><h4 id="3-）-MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain-Old-Java"><a href="#3-）-MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain-Old-Java" class="headerlink" title="3 ） MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java"></a>3 ） MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java</h4><h4 id="Objects，普通的Java对象）映射成数据库中的记录"><a href="#Objects，普通的Java对象）映射成数据库中的记录" class="headerlink" title="Objects，普通的Java对象）映射成数据库中的记录"></a>Objects，普通的Java对象）映射成数据库中的记录</h4><h4 id="4-）-MyBatis-是一个-半自动的ORM（Object-Relation-Mapping）框架"><a href="#4-）-MyBatis-是一个-半自动的ORM（Object-Relation-Mapping）框架" class="headerlink" title="4 ） MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架"></a>4 ） MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架</h4><h2 id="3-、MyBatis下载"><a href="#3-、MyBatis下载" class="headerlink" title="3 、MyBatis下载"></a>3 、MyBatis下载</h2><h4 id="MyBatis下载地址：https-github-com-mybatis-mybatis"><a href="#MyBatis下载地址：https-github-com-mybatis-mybatis" class="headerlink" title="MyBatis下载地址：https://github.com/mybatis/mybatis-"></a>MyBatis下载地址：<a href="https://github.com/mybatis/mybatis-">https://github.com/mybatis/mybatis-</a></h4><h2 id="4-、和其它持久化层技术对比"><a href="#4-、和其它持久化层技术对比" class="headerlink" title="4 、和其它持久化层技术对比"></a>4 、和其它持久化层技术对比</h2><h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><h4 id="SQL-夹杂在Java代码中耦合度高，导致硬编码内伤"><a href="#SQL-夹杂在Java代码中耦合度高，导致硬编码内伤" class="headerlink" title="SQL 夹杂在Java代码中耦合度高，导致硬编码内伤"></a>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤</h4><h4 id="维护不易且实际开发需求中-SQL-有变化，频繁修改的情况多见"><a href="#维护不易且实际开发需求中-SQL-有变化，频繁修改的情况多见" class="headerlink" title="维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见"></a>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见</h4><h4 id="代码冗长，开发效率低"><a href="#代码冗长，开发效率低" class="headerlink" title="代码冗长，开发效率低"></a>代码冗长，开发效率低</h4><h4 id="Hibernate-和-JPA"><a href="#Hibernate-和-JPA" class="headerlink" title="Hibernate 和 JPA"></a>Hibernate 和 JPA</h4><h4 id="操作简便，开发效率高"><a href="#操作简便，开发效率高" class="headerlink" title="操作简便，开发效率高"></a>操作简便，开发效率高</h4><h4 id="程序中的长难复杂-SQL-需要绕过框架"><a href="#程序中的长难复杂-SQL-需要绕过框架" class="headerlink" title="程序中的长难复杂 SQL 需要绕过框架"></a>程序中的长难复杂 SQL 需要绕过框架</h4><h4 id="内部自动生产的-SQL，不容易做特殊优化"><a href="#内部自动生产的-SQL，不容易做特殊优化" class="headerlink" title="内部自动生产的 SQL，不容易做特殊优化"></a>内部自动生产的 SQL，不容易做特殊优化</h4><h4 id="基于全映射的全自动框架，大量字段的-POJO-进行部分映射时比较困难。"><a href="#基于全映射的全自动框架，大量字段的-POJO-进行部分映射时比较困难。" class="headerlink" title="基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。"></a>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。</h4><h4 id="反射操作太多，导致数据库性能下降"><a href="#反射操作太多，导致数据库性能下降" class="headerlink" title="反射操作太多，导致数据库性能下降"></a>反射操作太多，导致数据库性能下降</h4><h4 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h4><h4 id="轻量级，性能出色"><a href="#轻量级，性能出色" class="headerlink" title="轻量级，性能出色"></a>轻量级，性能出色</h4><h4 id="SQL-和-Java-编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据"><a href="#SQL-和-Java-编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据" class="headerlink" title="SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据"></a>SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据</h4><h4 id="开发效率稍逊于HIbernate，但是完全能够接受"><a href="#开发效率稍逊于HIbernate，但是完全能够接受" class="headerlink" title="开发效率稍逊于HIbernate，但是完全能够接受"></a>开发效率稍逊于HIbernate，但是完全能够接受</h4><h1 id="二、搭建MyBatis"><a href="#二、搭建MyBatis" class="headerlink" title="二、搭建MyBatis"></a>二、搭建MyBatis</h1><h2 id="1-、开发环境"><a href="#1-、开发环境" class="headerlink" title="1 、开发环境"></a>1 、开发环境</h2><h4 id="IDE：idea-2019"><a href="#IDE：idea-2019" class="headerlink" title="IDE：idea 2019."></a>IDE：idea 2019.</h4><h4 id="构建工具：maven-3-5"><a href="#构建工具：maven-3-5" class="headerlink" title="构建工具：maven 3.5."></a>构建工具：maven 3.5.</h4><h4 id="MySQL版本：MySQL-5"><a href="#MySQL版本：MySQL-5" class="headerlink" title="MySQL版本：MySQL 5."></a>MySQL版本：MySQL 5.</h4><h4 id="MyBatis版本：MyBatis-3-5"><a href="#MyBatis版本：MyBatis-3-5" class="headerlink" title="MyBatis版本：MyBatis 3.5."></a>MyBatis版本：MyBatis 3.5.</h4><h2 id="2-、创建maven工程"><a href="#2-、创建maven工程" class="headerlink" title="2 、创建maven工程"></a>2 、创建maven工程</h2><h2 id="a-打包方式：jar"><a href="#a-打包方式：jar" class="headerlink" title="a&gt;打包方式：jar"></a>a&gt;打包方式：jar</h2><h2 id="b-引入依赖"><a href="#b-引入依赖" class="headerlink" title="b&gt;引入依赖"></a>b&gt;引入依赖</h2><h2 id="3-、创建MyBatis的核心配置文件"><a href="#3-、创建MyBatis的核心配置文件" class="headerlink" title="3 、创建MyBatis的核心配置文件"></a>3 、创建MyBatis的核心配置文件</h2><h4 id="习惯上命名为mybatis-config-xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring"><a href="#习惯上命名为mybatis-config-xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring" class="headerlink" title="习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring"></a>习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring</h4><h4 id="之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。"><a href="#之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。" class="headerlink" title="之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。"></a>之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。</h4><h4 id="核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息"><a href="#核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息" class="headerlink" title="核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息"></a>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;!-- Mybatis核心 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.5.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- junit测试 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- MySQL驱动 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.1.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h4 id="核心配置文件存放的位置是src-main-resources目录下"><a href="#核心配置文件存放的位置是src-main-resources目录下" class="headerlink" title="核心配置文件存放的位置是src&#x2F;main&#x2F;resources目录下"></a>核心配置文件存放的位置是src&#x2F;main&#x2F;resources目录下</h4><h2 id="4-、创建mapper接口"><a href="#4-、创建mapper接口" class="headerlink" title="4 、创建mapper接口"></a>4 、创建mapper接口</h2><h4 id="MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要"><a href="#MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要" class="headerlink" title="MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要"></a>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要</h4><h4 id="提供实现类。"><a href="#提供实现类。" class="headerlink" title="提供实现类。"></a>提供实现类。</h4><h2 id="5-、创建MyBatis的映射文件"><a href="#5-、创建MyBatis的映射文件" class="headerlink" title="5 、创建MyBatis的映射文件"></a>5 、创建MyBatis的映射文件</h2><h4 id="相关概念：-ORM-（-O-bject-R-elationship-M-apping）对象关系映射。"><a href="#相关概念：-ORM-（-O-bject-R-elationship-M-apping）对象关系映射。" class="headerlink" title="相关概念： ORM （ O bject R elationship M apping）对象关系映射。"></a>相关概念： ORM （ O bject R elationship M apping）对象关系映射。</h4><h4 id="对象：Java的实体类对象"><a href="#对象：Java的实体类对象" class="headerlink" title="对象：Java的实体类对象"></a>对象：Java的实体类对象</h4><h4 id="关系：关系型数据库"><a href="#关系：关系型数据库" class="headerlink" title="关系：关系型数据库"></a>关系：关系型数据库</h4><h4 id="映射：二者之间的对应关系"><a href="#映射：二者之间的对应关系" class="headerlink" title="映射：二者之间的对应关系"></a>映射：二者之间的对应关系</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!--设置连接数据库的环境--&gt;</span><br><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">&lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">&lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">&lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;url&quot;</span><br><span class="line">value=&quot;jdbc:mysql://localhost:3306/MyBatis&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;</span><br><span class="line">&lt;/dataSource&gt;</span><br><span class="line">&lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br><span class="line">&lt;!--引入映射文件--&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br></pre></td></tr></table></figure>
<h5 id=""><a href="#" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="添加用户信息"><a href="#添加用户信息" class="headerlink" title="* 添加用户信息"></a>* 添加用户信息</h5><h5 id="-1"><a href="#-1" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int insertUser();</span><br></pre></td></tr></table></figure>
<h5 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h5><h4 id="Java概念-数据库概念"><a href="#Java概念-数据库概念" class="headerlink" title="Java概念 数据库概念"></a>Java概念 数据库概念</h4><h4 id="类-表"><a href="#类-表" class="headerlink" title="类 表"></a>类 表</h4><h4 id="属性-字段-列"><a href="#属性-字段-列" class="headerlink" title="属性 字段&#x2F;列"></a>属性 字段&#x2F;列</h4><h4 id="对象-记录-行"><a href="#对象-记录-行" class="headerlink" title="对象 记录&#x2F;行"></a>对象 记录&#x2F;行</h4><h4 id="1-、映射文件的命名规则："><a href="#1-、映射文件的命名规则：" class="headerlink" title="1 、映射文件的命名规则："></a>1 、映射文件的命名规则：</h4><h4 id="表所对应的实体类的类名-Mapper-xml"><a href="#表所对应的实体类的类名-Mapper-xml" class="headerlink" title="表所对应的实体类的类名+Mapper.xml"></a>表所对应的实体类的类名+Mapper.xml</h4><h4 id="例如：表t-user，映射的实体类为User，所对应的映射文件为UserMapper-xml"><a href="#例如：表t-user，映射的实体类为User，所对应的映射文件为UserMapper-xml" class="headerlink" title="例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml"></a>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml</h4><h4 id="因此一个映射文件对应一个实体类，对应一张表的操作"><a href="#因此一个映射文件对应一个实体类，对应一张表的操作" class="headerlink" title="因此一个映射文件对应一个实体类，对应一张表的操作"></a>因此一个映射文件对应一个实体类，对应一张表的操作</h4><h4 id="MyBatis映射文件用于编写SQL，访问以及操作表中的数据"><a href="#MyBatis映射文件用于编写SQL，访问以及操作表中的数据" class="headerlink" title="MyBatis映射文件用于编写SQL，访问以及操作表中的数据"></a>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</h4><h4 id="MyBatis映射文件存放的位置是src-main-resources-mappers目录下"><a href="#MyBatis映射文件存放的位置是src-main-resources-mappers目录下" class="headerlink" title="MyBatis映射文件存放的位置是src&#x2F;main&#x2F;resources&#x2F;mappers目录下"></a>MyBatis映射文件存放的位置是src&#x2F;main&#x2F;resources&#x2F;mappers目录下</h4><h4 id="2-、MyBatis中可以面向接口操作数据，要保证两个一致："><a href="#2-、MyBatis中可以面向接口操作数据，要保证两个一致：" class="headerlink" title="2 、MyBatis中可以面向接口操作数据，要保证两个一致："></a>2 、MyBatis中可以面向接口操作数据，要保证两个一致：</h4><h4 id="a-mapper接口的全类名和映射文件的命名空间（namespace）保持一致"><a href="#a-mapper接口的全类名和映射文件的命名空间（namespace）保持一致" class="headerlink" title="a&gt;mapper接口的全类名和映射文件的命名空间（namespace）保持一致"></a>a&gt;mapper接口的全类名和映射文件的命名空间（namespace）保持一致</h4><h4 id="b-mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致"><a href="#b-mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致" class="headerlink" title="b&gt;mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致"></a>b&gt;mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</h4><h2 id="6-、通过junit测试功能"><a href="#6-、通过junit测试功能" class="headerlink" title="6 、通过junit测试功能"></a>6 、通过junit测试功能</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.UserMapper&quot;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--int insertUser();--&gt;</span><br><span class="line">&lt;insert id=&quot;insertUser&quot;&gt;</span><br><span class="line">insert into t_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,23,&#x27;女&#x27;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//读取MyBatis的核心配置文件</span><br><span class="line">InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">//创建SqlSessionFactoryBuilder对象</span><br><span class="line">SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new</span><br><span class="line">SqlSessionFactoryBuilder();</span><br><span class="line">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span><br><span class="line">SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务</span><br><span class="line">//SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交</span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">//通过代理模式创建UserMapper接口的代理实现类对象</span><br><span class="line">UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配</span><br><span class="line">映射文件中的SQL标签，并执行标签中的SQL语句</span><br><span class="line">int result = userMapper.insertUser();</span><br><span class="line">//sqlSession.commit();</span><br></pre></td></tr></table></figure>

<h4 id="SqlSession：代表Java程序和-数据库-之间的-会话-。（HttpSession是Java程序和浏览器之间的"><a href="#SqlSession：代表Java程序和-数据库-之间的-会话-。（HttpSession是Java程序和浏览器之间的" class="headerlink" title="SqlSession：代表Java程序和 数据库 之间的 会话 。（HttpSession是Java程序和浏览器之间的"></a>SqlSession：代表Java程序和 数据库 之间的 会话 。（HttpSession是Java程序和浏览器之间的</h4><h4 id="会话）"><a href="#会话）" class="headerlink" title="会话）"></a>会话）</h4><h4 id="SqlSessionFactory：是“生产”SqlSession的“工厂”。"><a href="#SqlSessionFactory：是“生产”SqlSession的“工厂”。" class="headerlink" title="SqlSessionFactory：是“生产”SqlSession的“工厂”。"></a>SqlSessionFactory：是“生产”SqlSession的“工厂”。</h4><h4 id="工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的"><a href="#工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的" class="headerlink" title="工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的"></a>工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的</h4><h4 id="相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。"><a href="#相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。" class="headerlink" title="相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。"></a>相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。</h4><h2 id="7-、加入log4j日志功能"><a href="#7-、加入log4j日志功能" class="headerlink" title="7 、加入log4j日志功能"></a>7 、加入log4j日志功能</h2><h3 id="a-加入依赖"><a href="#a-加入依赖" class="headerlink" title="a&gt;加入依赖"></a>a&gt;加入依赖</h3><h3 id="b-加入log4j的配置文件"><a href="#b-加入log4j的配置文件" class="headerlink" title="b&gt;加入log4j的配置文件"></a>b&gt;加入log4j的配置文件</h3><h4 id="log4j的配置文件名为log4j-xml，存放的位置是src-main-resources目录下"><a href="#log4j的配置文件名为log4j-xml，存放的位置是src-main-resources目录下" class="headerlink" title="log4j的配置文件名为log4j.xml，存放的位置是src&#x2F;main&#x2F;resources目录下"></a>log4j的配置文件名为log4j.xml，存放的位置是src&#x2F;main&#x2F;resources目录下</h4><h3 id="日志的级别"><a href="#日志的级别" class="headerlink" title="日志的级别"></a>日志的级别</h3><h4 id="FATAL-致命-ERROR-错误-WARN-警告-INFO-信息-DEBUG-调试"><a href="#FATAL-致命-ERROR-错误-WARN-警告-INFO-信息-DEBUG-调试" class="headerlink" title="FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试)"></a>FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试)</h4><h4 id="从左到右打印的内容越来越详细"><a href="#从左到右打印的内容越来越详细" class="headerlink" title="从左到右打印的内容越来越详细"></a>从左到右打印的内容越来越详细</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;结果：&quot;+result);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- log4j日志 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;</span><br><span class="line">&lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt;</span><br><span class="line">&lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">&lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125;</span><br><span class="line">%m (%F:%L) \n&quot; /&gt;</span><br><span class="line">&lt;/layout&gt;</span><br><span class="line">&lt;/appender&gt;</span><br><span class="line">&lt;logger name=&quot;java.sql&quot;&gt;</span><br><span class="line">&lt;level value=&quot;debug&quot; /&gt;</span><br><span class="line">&lt;/logger&gt;</span><br><span class="line">&lt;logger name=&quot;org.apache.ibatis&quot;&gt;</span><br><span class="line">&lt;level value=&quot;info&quot; /&gt;</span><br><span class="line">&lt;/logger&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;level value=&quot;debug&quot; /&gt;</span><br><span class="line">&lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line">&lt;/log4j:configuration&gt;</span><br></pre></td></tr></table></figure>

<h1 id="三、核心配置文件详解"><a href="#三、核心配置文件详解" class="headerlink" title="三、核心配置文件详解"></a>三、核心配置文件详解</h1><h4 id="核心配置文件中的标签必须按照固定的顺序："><a href="#核心配置文件中的标签必须按照固定的顺序：" class="headerlink" title="核心配置文件中的标签必须按照固定的顺序："></a>核心配置文件中的标签必须按照固定的顺序：</h4><h4 id="properties-settings-typeAliases-typeHandlers-objectFactory-objectWrapperFactory-reflectorF"><a href="#properties-settings-typeAliases-typeHandlers-objectFactory-objectWrapperFactory-reflectorF" class="headerlink" title="properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorF"></a>properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorF</h4><h4 id="actory-plugins-environments-databaseIdProvider-mappers"><a href="#actory-plugins-environments-databaseIdProvider-mappers" class="headerlink" title="actory?,plugins?,environments?,databaseIdProvider?,mappers?"></a>actory?,plugins?,environments?,databaseIdProvider?,mappers?</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">PUBLIC &quot;-//MyBatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">&quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span><br><span class="line">&lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span><br><span class="line">&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;!--开启延迟加载--&gt;</span><br><span class="line">&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">typeAlias：设置某个具体的类型的别名</span><br><span class="line">属性：</span><br><span class="line">type：需要设置别名的类型的全类名</span><br><span class="line">alias：设置此类型的别名，若不设置此属性，该类型拥有默认的别名，即类名且不区分大小</span><br><span class="line">写</span><br><span class="line">若设置此属性，此时该类型的别名只能使用alias所设置的值</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt;</span><br><span class="line">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;abc&quot;&gt;</span><br><span class="line">&lt;/typeAlias&gt;--&gt;</span><br><span class="line">&lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;</span><br><span class="line">&lt;package name=&quot;com.atguigu.mybatis.bean&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-3"><a href="#-3" class="headerlink" title="&lt;!–"></a>&lt;!–</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">environments：设置多个连接数据库的环境</span><br><span class="line">属性：</span><br><span class="line">default：设置默认使用的环境的id</span><br><span class="line">--&gt;</span><br><span class="line">&lt;environments default=&quot;mysql_test&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">environment：设置具体的连接数据库的环境信息</span><br><span class="line">属性：</span><br><span class="line">id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，</span><br><span class="line">表示默认使用的环境</span><br><span class="line">--&gt;</span><br><span class="line">&lt;environment id=&quot;mysql_test&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">transactionManager：设置事务管理方式</span><br><span class="line">属性：</span><br></pre></td></tr></table></figure>

<h1 id="四、MyBatis的增删改查"><a href="#四、MyBatis的增删改查" class="headerlink" title="四、MyBatis的增删改查"></a>四、MyBatis的增删改查</h1><h4 id="1-、添加"><a href="#1-、添加" class="headerlink" title="1 、添加"></a>1 、添加</h4><h4 id="2-、删除"><a href="#2-、删除" class="headerlink" title="2 、删除"></a>2 、删除</h4><h4 id="3-、修改"><a href="#3-、修改" class="headerlink" title="3 、修改"></a>3 、修改</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span><br><span class="line">type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span><br><span class="line">type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span><br><span class="line">--&gt;</span><br><span class="line">&lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">dataSource：设置数据源</span><br><span class="line">属性：</span><br><span class="line">type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span><br><span class="line">type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从</span><br><span class="line">缓存中直接获取，不需要重新创建</span><br><span class="line">type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span><br><span class="line">type=&quot;JNDI&quot;：调用上下文中的数据源</span><br><span class="line">--&gt;</span><br><span class="line">&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">&lt;!--设置驱动类的全类名--&gt;</span><br><span class="line">&lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;</span><br><span class="line">&lt;!--设置连接数据库的连接地址--&gt;</span><br><span class="line">&lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">&lt;!--设置连接数据库的用户名--&gt;</span><br><span class="line">&lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">&lt;!--设置连接数据库的密码--&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">&lt;/dataSource&gt;</span><br><span class="line">&lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br><span class="line">&lt;!--引入映射文件--&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">以包为单位，将包下所有的映射文件引入核心配置文件</span><br><span class="line">注意：此方式必须保证mapper接口和mapper映射文件必须在相同的包下</span><br><span class="line">--&gt;</span><br><span class="line">&lt;package name=&quot;com.atguigu.mybatis.mapper&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--int insertUser();--&gt;</span><br><span class="line">&lt;insert id=&quot;insertUser&quot;&gt;</span><br><span class="line">insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--int deleteUser();--&gt;</span><br><span class="line">&lt;delete id=&quot;deleteUser&quot;&gt;</span><br><span class="line">delete from t_user where id = 7</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-、查询一个实体类对象"><a href="#4-、查询一个实体类对象" class="headerlink" title="4 、查询一个实体类对象"></a>4 、查询一个实体类对象</h4><h4 id="5-、查询集合"><a href="#5-、查询集合" class="headerlink" title="5 、查询集合"></a>5 、查询集合</h4><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><h4 id="1-、查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射"><a href="#1-、查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射" class="headerlink" title="1 、查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射"></a>1 、查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射</h4><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><h4 id="resultType：自动映射，用于属性名和表中字段名一致的情况"><a href="#resultType：自动映射，用于属性名和表中字段名一致的情况" class="headerlink" title="resultType：自动映射，用于属性名和表中字段名一致的情况"></a>resultType：自动映射，用于属性名和表中字段名一致的情况</h4><h4 id="resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况"><a href="#resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况" class="headerlink" title="resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况"></a>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</h4><h4 id="2-、当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常"><a href="#2-、当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常" class="headerlink" title="2 、当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常"></a>2 、当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常</h4><h4 id="TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值"><a href="#TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值" class="headerlink" title="TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值"></a>TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</h4><h1 id="五、MyBatis获取参数值的两种方式（重点）"><a href="#五、MyBatis获取参数值的两种方式（重点）" class="headerlink" title="五、MyBatis获取参数值的两种方式（重点）"></a>五、MyBatis获取参数值的两种方式（重点）</h1><h4 id="MyBatis获取参数值的两种方式：-和"><a href="#MyBatis获取参数值的两种方式：-和" class="headerlink" title="MyBatis获取参数值的两种方式： ${} 和 #{}"></a>MyBatis获取参数值的两种方式： ${} 和 #{}</h4><h4 id="的本质就是字符串拼接，-的本质就是占位符赋值"><a href="#的本质就是字符串拼接，-的本质就是占位符赋值" class="headerlink" title="${}的本质就是字符串拼接，#{}的本质就是占位符赋值"></a>${}的本质就是字符串拼接，#{}的本质就是占位符赋值</h4><h4 id="使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引"><a href="#使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引" class="headerlink" title="${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引"></a>${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引</h4><h4 id="号；但是-使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自"><a href="#号；但是-使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自" class="headerlink" title="号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自"></a>号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自</h4><h4 id="动添加单引号"><a href="#动添加单引号" class="headerlink" title="动添加单引号"></a>动添加单引号</h4><h2 id="1-、单个字面量类型的参数"><a href="#1-、单个字面量类型的参数" class="headerlink" title="1 、单个字面量类型的参数"></a>1 、单个字面量类型的参数</h2><h4 id="若mapper接口中的方法参数为单个的字面量类型"><a href="#若mapper接口中的方法参数为单个的字面量类型" class="headerlink" title="若mapper接口中的方法参数为单个的字面量类型"></a>若mapper接口中的方法参数为单个的字面量类型</h4><h4 id="此时可以使用-和-以任意的名称获取参数的值，注意-需要手动加单引号"><a href="#此时可以使用-和-以任意的名称获取参数的值，注意-需要手动加单引号" class="headerlink" title="此时可以使用${}和#{}以任意的名称获取参数的值，注意${}需要手动加单引号"></a>此时可以使用${}和#{}以任意的名称获取参数的值，注意${}需要手动加单引号</h4><h2 id="2-、多个字面量类型的参数"><a href="#2-、多个字面量类型的参数" class="headerlink" title="2 、多个字面量类型的参数"></a>2 、多个字面量类型的参数</h2><h4 id="若mapper接口中的方法参数为多个时"><a href="#若mapper接口中的方法参数为多个时" class="headerlink" title="若mapper接口中的方法参数为多个时"></a>若mapper接口中的方法参数为多个时</h4><h4 id="此时MyBatis会自动将这些参数放在一个map集合中，以arg0-arg1…为键，以参数为值；以"><a href="#此时MyBatis会自动将这些参数放在一个map集合中，以arg0-arg1…为键，以参数为值；以" class="headerlink" title="此时MyBatis会自动将这些参数放在一个map集合中，以arg0,arg1…为键，以参数为值；以"></a>此时MyBatis会自动将这些参数放在一个map集合中，以arg0,arg1…为键，以参数为值；以</h4><h4 id="param1-param2…为键，以参数为值；因此只需要通过-和-访问map集合的键就可以获取相对应的"><a href="#param1-param2…为键，以参数为值；因此只需要通过-和-访问map集合的键就可以获取相对应的" class="headerlink" title="param1,param2…为键，以参数为值；因此只需要通过${}和#{}访问map集合的键就可以获取相对应的"></a>param1,param2…为键，以参数为值；因此只需要通过${}和#{}访问map集合的键就可以获取相对应的</h4><h4 id="值，注意-需要手动加单引号"><a href="#值，注意-需要手动加单引号" class="headerlink" title="值，注意${}需要手动加单引号"></a>值，注意${}需要手动加单引号</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--int updateUser();--&gt;</span><br><span class="line">&lt;update id=&quot;updateUser&quot;&gt;</span><br><span class="line">update t_user set username=&#x27;ybc&#x27;,password=&#x27;123&#x27; where id = 6</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--User getUserById();--&gt;</span><br><span class="line">&lt;select id=&quot;getUserById&quot; resultType=&quot;com.atguigu.mybatis.bean.User&quot;&gt;</span><br><span class="line">select * from t_user where id = 2</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--List&lt;User&gt; getUserList();--&gt;</span><br><span class="line">&lt;select id=&quot;getUserList&quot; resultType=&quot;com.atguigu.mybatis.bean.User&quot;&gt;</span><br><span class="line">select * from t_user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-、map集合类型的参数"><a href="#3-、map集合类型的参数" class="headerlink" title="3 、map集合类型的参数"></a>3 、map集合类型的参数</h2><h4 id="若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中"><a href="#若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中" class="headerlink" title="若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中"></a>若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中</h4><h4 id="只需要通过-和-访问map集合的键就可以获取相对应的值，注意-需要手动加单引号"><a href="#只需要通过-和-访问map集合的键就可以获取相对应的值，注意-需要手动加单引号" class="headerlink" title="只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号"></a>只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</h4><h2 id="4-、实体类类型的参数"><a href="#4-、实体类类型的参数" class="headerlink" title="4 、实体类类型的参数"></a>4 、实体类类型的参数</h2><h4 id="若mapper接口中的方法参数为实体类对象时"><a href="#若mapper接口中的方法参数为实体类对象时" class="headerlink" title="若mapper接口中的方法参数为实体类对象时"></a>若mapper接口中的方法参数为实体类对象时</h4><h4 id="此时可以使用-和-，通过访问实体类对象中的属性名获取属性值，注意-需要手动加单引号"><a href="#此时可以使用-和-，通过访问实体类对象中的属性名获取属性值，注意-需要手动加单引号" class="headerlink" title="此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号"></a>此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号</h4><h2 id="5-、使用-Param标识参数"><a href="#5-、使用-Param标识参数" class="headerlink" title="5 、使用@Param标识参数"></a>5 、使用@Param标识参数</h2><h4 id="可以通过-Param注解标识mapper接口中的方法参数"><a href="#可以通过-Param注解标识mapper接口中的方法参数" class="headerlink" title="可以通过@Param注解标识mapper接口中的方法参数"></a>可以通过@Param注解标识mapper接口中的方法参数</h4><h4 id="此时，会将这些参数放在map集合中，以-Param注解的value属性值为键，以参数为值；以"><a href="#此时，会将这些参数放在map集合中，以-Param注解的value属性值为键，以参数为值；以" class="headerlink" title="此时，会将这些参数放在map集合中，以@Param注解的value属性值为键，以参数为值；以"></a>此时，会将这些参数放在map集合中，以@Param注解的value属性值为键，以参数为值；以</h4><h4 id="param1-param2…为键，以参数为值；只需要通过-和-访问map集合的键就可以获取相对应的值，"><a href="#param1-param2…为键，以参数为值；只需要通过-和-访问map集合的键就可以获取相对应的值，" class="headerlink" title="param1,param2…为键，以参数为值；只需要通过${}和#{}访问map集合的键就可以获取相对应的值，"></a>param1,param2…为键，以参数为值；只需要通过${}和#{}访问map集合的键就可以获取相对应的值，</h4><h4 id="注意-需要手动加单引号"><a href="#注意-需要手动加单引号" class="headerlink" title="注意${}需要手动加单引号"></a>注意${}需要手动加单引号</h4><h1 id="六、MyBatis的各种查询功能"><a href="#六、MyBatis的各种查询功能" class="headerlink" title="六、MyBatis的各种查询功能"></a>六、MyBatis的各种查询功能</h1><h2 id="1-、查询一个实体类对象"><a href="#1-、查询一个实体类对象" class="headerlink" title="1 、查询一个实体类对象"></a>1 、查询一个实体类对象</h2><h2 id="2-、查询一个list集合"><a href="#2-、查询一个list集合" class="headerlink" title="2 、查询一个list集合"></a>2 、查询一个list集合</h2><h2 id="3-、查询单个数据"><a href="#3-、查询单个数据" class="headerlink" title="3 、查询单个数据"></a>3 、查询单个数据</h2><h5 id="-4"><a href="#-4" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 根据用户id查询用户信息</span><br><span class="line">* @param id</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">User getUserById(@Param(&quot;id&quot;) int id);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&gt;</span><br><span class="line">&lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">select * from t_user where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-5"><a href="#-5" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="查询所有用户信息"><a href="#查询所有用户信息" class="headerlink" title="* 查询所有用户信息"></a>* 查询所有用户信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">List&lt;User&gt; getUserList();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--List&lt;User&gt; getUserList();--&gt;</span><br><span class="line">&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">select * from t_user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-、查询一条数据为map集合"><a href="#4-、查询一条数据为map集合" class="headerlink" title="4 、查询一条数据为map集合"></a>4 、查询一条数据为map集合</h2><h2 id="5-、查询多条数据为map集合"><a href="#5-、查询多条数据为map集合" class="headerlink" title="5 、查询多条数据为map集合"></a>5 、查询多条数据为map集合</h2><h3 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h3><h3 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h3><h5 id="-6"><a href="#-6" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="查询用户的总记录数"><a href="#查询用户的总记录数" class="headerlink" title="* 查询用户的总记录数"></a>* 查询用户的总记录数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* @return</span><br><span class="line">* 在MyBatis中，对于Java中常用的类型都设置了类型别名</span><br><span class="line">* 例如：java.lang.Integer--&gt;int|integer</span><br><span class="line">* 例如：int--&gt;_int|_integer</span><br><span class="line">* 例如：Map--&gt;map,List--&gt;list</span><br><span class="line">*/</span><br><span class="line">int getCount();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--int getCount();--&gt;</span><br><span class="line">&lt;select id=&quot;getCount&quot; resultType=&quot;_integer&quot;&gt;</span><br><span class="line">select count(id) from t_user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-7"><a href="#-7" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 根据用户id查询用户信息为map集合</span><br><span class="line">* @param id</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);--&gt;</span><br><span class="line">&lt;select id=&quot;getUserToMap&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">select * from t_user where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;!--结果：&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;--&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-8"><a href="#-8" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 查询所有用户信息为map集合</span><br><span class="line">* @return</span><br><span class="line">* 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此</span><br><span class="line">时可以将这些map放在一个list集合中获取</span><br><span class="line">*/</span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span><br><span class="line">&lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">select * from t_user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h1 id="七、特殊SQL的执行"><a href="#七、特殊SQL的执行" class="headerlink" title="七、特殊SQL的执行"></a>七、特殊SQL的执行</h1><h2 id="1-、模糊查询"><a href="#1-、模糊查询" class="headerlink" title="1 、模糊查询"></a>1 、模糊查询</h2><h2 id="2-、批量删除"><a href="#2-、批量删除" class="headerlink" title="2 、批量删除"></a>2 、批量删除</h2><h5 id="-9"><a href="#-9" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 查询所有用户信息为map集合</span><br><span class="line">* @return</span><br><span class="line">* 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并</span><br><span class="line">且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的</span><br><span class="line">map集合</span><br><span class="line">*/</span><br><span class="line">@MapKey(&quot;id&quot;)</span><br><span class="line">Map&lt;String, Object&gt; getAllUserToMap();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span><br><span class="line">&lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">select * from t_user</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">结果：</span><br><span class="line">&lt;!--</span><br><span class="line">&#123;</span><br><span class="line">1=&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span><br><span class="line">2=&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span><br><span class="line">3=&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;</span><br><span class="line">&#125;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-10"><a href="#-10" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="测试模糊查询"><a href="#测试模糊查询" class="headerlink" title="* 测试模糊查询"></a>* 测试模糊查询</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* @param mohu</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">List&lt;User&gt; testMohu(@Param(&quot;mohu&quot;) String mohu);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--List&lt;User&gt; testMohu(@Param(&quot;mohu&quot;) String mohu);--&gt;</span><br><span class="line">&lt;select id=&quot;testMohu&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt;</span><br><span class="line">&lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)--&gt;</span><br><span class="line">select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-11"><a href="#-11" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="批量删除"><a href="#批量删除" class="headerlink" title="* 批量删除"></a>* 批量删除</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* @param ids</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">int deleteMore(@Param(&quot;ids&quot;) String ids);</span><br></pre></td></tr></table></figure>

<h2 id="3-、动态设置表名"><a href="#3-、动态设置表名" class="headerlink" title="3 、动态设置表名"></a>3 、动态设置表名</h2><h2 id="4-、添加功能获取自增的主键"><a href="#4-、添加功能获取自增的主键" class="headerlink" title="4 、添加功能获取自增的主键"></a>4 、添加功能获取自增的主键</h2><h4 id="t-clazz-clazz-id-clazz-name"><a href="#t-clazz-clazz-id-clazz-name" class="headerlink" title="t_clazz(clazz_id,clazz_name)"></a>t_clazz(clazz_id,clazz_name)</h4><h4 id="t-student-student-id-student-name-clazz-id"><a href="#t-student-student-id-student-name-clazz-id" class="headerlink" title="t_student(student_id,student_name,clazz_id)"></a>t_student(student_id,student_name,clazz_id)</h4><h4 id="1-、添加班级信息"><a href="#1-、添加班级信息" class="headerlink" title="1 、添加班级信息"></a>1 、添加班级信息</h4><h4 id="2-、获取新添加的班级的id"><a href="#2-、获取新添加的班级的id" class="headerlink" title="2 、获取新添加的班级的id"></a>2 、获取新添加的班级的id</h4><h4 id="3-、为班级分配学生，即将某学的班级id修改为新添加的班级的id"><a href="#3-、为班级分配学生，即将某学的班级id修改为新添加的班级的id" class="headerlink" title="3 、为班级分配学生，即将某学的班级id修改为新添加的班级的id"></a>3 、为班级分配学生，即将某学的班级id修改为新添加的班级的id</h4><h1 id="八、自定义映射resultMap"><a href="#八、自定义映射resultMap" class="headerlink" title="八、自定义映射resultMap"></a>八、自定义映射resultMap</h1><h2 id="1-、resultMap处理字段和属性的映射关系"><a href="#1-、resultMap处理字段和属性的映射关系" class="headerlink" title="1 、resultMap处理字段和属性的映射关系"></a>1 、resultMap处理字段和属性的映射关系</h2><h4 id="若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射"><a href="#若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射" class="headerlink" title="若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射"></a>若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--int deleteMore(@Param(&quot;ids&quot;) String ids);--&gt;</span><br><span class="line">&lt;delete id=&quot;deleteMore&quot;&gt;</span><br><span class="line">delete from t_user where id in ($&#123;ids&#125;)</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-12"><a href="#-12" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="动态设置表名，查询所有的用户信息"><a href="#动态设置表名，查询所有的用户信息" class="headerlink" title="* 动态设置表名，查询所有的用户信息"></a>* 动态设置表名，查询所有的用户信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* @param tableName</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">List&lt;User&gt; getAllUser(@Param(&quot;tableName&quot;) String tableName);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--List&lt;User&gt; getAllUser(@Param(&quot;tableName&quot;) String tableName);--&gt;</span><br><span class="line">&lt;select id=&quot;getAllUser&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">select * from $&#123;tableName&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-13"><a href="#-13" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="添加用户信息-1"><a href="#添加用户信息-1" class="headerlink" title="* 添加用户信息"></a>* 添加用户信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* @param user</span><br><span class="line">* @return</span><br><span class="line">* useGeneratedKeys：设置使用自增的主键</span><br><span class="line">* keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参</span><br><span class="line">数user对象的某个属性中</span><br><span class="line">*/</span><br><span class="line">int insertUser(User user);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--int insertUser(User user);--&gt;</span><br><span class="line">&lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<h4 id="若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用-），实体类中的属性"><a href="#若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用-），实体类中的属性" class="headerlink" title="若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性"></a>若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性</h4><h4 id="名符合Java的规则（使用驼峰）"><a href="#名符合Java的规则（使用驼峰）" class="headerlink" title="名符合Java的规则（使用驼峰）"></a>名符合Java的规则（使用驼峰）</h4><h4 id="此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系"><a href="#此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系" class="headerlink" title="此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系"></a>此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系</h4><h4 id="a-可以通过为字段起别名的方式，保证和实体类中的属性名保持一致"><a href="#a-可以通过为字段起别名的方式，保证和实体类中的属性名保持一致" class="headerlink" title="a&gt;可以通过为字段起别名的方式，保证和实体类中的属性名保持一致"></a>a&gt;可以通过为字段起别名的方式，保证和实体类中的属性名保持一致</h4><h4 id="b-可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，可"><a href="#b-可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，可" class="headerlink" title="b&gt;可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，可"></a>b&gt;可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，可</h4><h4 id="以在查询表中数据时，自动将-类型的字段名转换为驼峰"><a href="#以在查询表中数据时，自动将-类型的字段名转换为驼峰" class="headerlink" title="以在查询表中数据时，自动将_类型的字段名转换为驼峰"></a>以在查询表中数据时，自动将_类型的字段名转换为驼峰</h4><h4 id="例如：字段名user-name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为"><a href="#例如：字段名user-name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为" class="headerlink" title="例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为"></a>例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为</h4><h4 id="userName"><a href="#userName" class="headerlink" title="userName"></a>userName</h4><h2 id="2-、多对一映射处理"><a href="#2-、多对一映射处理" class="headerlink" title="2 、多对一映射处理"></a>2 、多对一映射处理</h2><h4 id="查询员工信息以及员工所对应的部门信息"><a href="#查询员工信息以及员工所对应的部门信息" class="headerlink" title="查询员工信息以及员工所对应的部门信息"></a>查询员工信息以及员工所对应的部门信息</h4><h3 id="a-级联方式处理映射关系"><a href="#a-级联方式处理映射关系" class="headerlink" title="a&gt;级联方式处理映射关系"></a>a&gt;级联方式处理映射关系</h3><h5 id="-14"><a href="#-14" class="headerlink" title="&lt;!–"></a>&lt;!–</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resultMap：设置自定义映射</span><br><span class="line">属性：</span><br><span class="line">id：表示自定义映射的唯一标识</span><br><span class="line">type：查询的数据要映射的实体类的类型</span><br><span class="line">子标签：</span><br><span class="line">id：设置主键的映射关系</span><br><span class="line">result：设置普通字段的映射关系</span><br><span class="line">association：设置多对一的映射关系</span><br><span class="line">collection：设置一对多的映射关系</span><br><span class="line">属性：</span><br><span class="line">property：设置映射关系中实体类中的属性名</span><br><span class="line">column：设置映射关系中表中的字段名</span><br><span class="line">--&gt;</span><br><span class="line">&lt;resultMap id=&quot;userMap&quot; type=&quot;User&quot;&gt;</span><br><span class="line">&lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;</span><br><span class="line">&lt;result property=&quot;userName&quot; column=&quot;user_name&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;result property=&quot;password&quot; column=&quot;password&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;!--List&lt;User&gt; testMohu(@Param(&quot;mohu&quot;) String mohu);--&gt;</span><br><span class="line">&lt;select id=&quot;testMohu&quot; resultMap=&quot;userMap&quot;&gt;</span><br><span class="line">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt;</span><br><span class="line">select id,user_name,password,age,sex from t_user where user_name like</span><br><span class="line">concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="b-使用association处理映射关系"><a href="#b-使用association处理映射关系" class="headerlink" title="b&gt;使用association处理映射关系"></a>b&gt;使用association处理映射关系</h3><h3 id="c-分步查询"><a href="#c-分步查询" class="headerlink" title="c&gt;分步查询"></a>c&gt;分步查询</h3><h4 id="1-）查询员工信息"><a href="#1-）查询员工信息" class="headerlink" title="1 ）查询员工信息"></a>1 ）查询员工信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;empDeptMap&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">&lt;id column=&quot;eid&quot; property=&quot;eid&quot;&gt;&lt;/id&gt;</span><br><span class="line">&lt;result column=&quot;ename&quot; property=&quot;ename&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;result column=&quot;did&quot; property=&quot;dept.did&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;result column=&quot;dname&quot; property=&quot;dept.dname&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;!--Emp getEmpAndDeptByEid(@Param(&quot;eid&quot;) int eid);--&gt;</span><br><span class="line">&lt;select id=&quot;getEmpAndDeptByEid&quot; resultMap=&quot;empDeptMap&quot;&gt;</span><br><span class="line">select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did =</span><br><span class="line">dept.did where emp.eid = #&#123;eid&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;empDeptMap&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">&lt;id column=&quot;eid&quot; property=&quot;eid&quot;&gt;&lt;/id&gt;</span><br><span class="line">&lt;result column=&quot;ename&quot; property=&quot;ename&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt;</span><br><span class="line">&lt;id column=&quot;did&quot; property=&quot;did&quot;&gt;&lt;/id&gt;</span><br><span class="line">&lt;result column=&quot;dname&quot; property=&quot;dname&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;!--Emp getEmpAndDeptByEid(@Param(&quot;eid&quot;) int eid);--&gt;</span><br><span class="line">&lt;select id=&quot;getEmpAndDeptByEid&quot; resultMap=&quot;empDeptMap&quot;&gt;</span><br><span class="line">select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did =</span><br><span class="line">dept.did where emp.eid = #&#123;eid&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-15"><a href="#-15" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="通过分步查询查询员工信息"><a href="#通过分步查询查询员工信息" class="headerlink" title="* 通过分步查询查询员工信息"></a>* 通过分步查询查询员工信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* @param eid</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">Emp getEmpByStep(@Param(&quot;eid&quot;) int eid);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;empDeptStepMap&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">&lt;id column=&quot;eid&quot; property=&quot;eid&quot;&gt;&lt;/id&gt;</span><br><span class="line">&lt;result column=&quot;ename&quot; property=&quot;ename&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">select：设置分步查询，查询某个属性的值的sql的标识（namespace.sqlId）</span><br><span class="line">column：将sql以及查询结果中的某个字段设置为分步查询的条件</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-）根据员工所对应的部门id查询部门信息"><a href="#2-）根据员工所对应的部门id查询部门信息" class="headerlink" title="2 ）根据员工所对应的部门id查询部门信息"></a>2 ）根据员工所对应的部门id查询部门信息</h4><h2 id="3-、一对多映射处理"><a href="#3-、一对多映射处理" class="headerlink" title="3 、一对多映射处理"></a>3 、一对多映射处理</h2><h3 id="a-collection"><a href="#a-collection" class="headerlink" title="a&gt;collection"></a>a&gt;collection</h3><h3 id="b-分步查询"><a href="#b-分步查询" class="headerlink" title="b&gt;分步查询"></a>b&gt;分步查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;association property=&quot;dept&quot;</span><br><span class="line">select=&quot;com.atguigu.MyBatis.mapper.DeptMapper.getEmpDeptByStep&quot; column=&quot;did&quot;&gt;</span><br><span class="line">&lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;!--Emp getEmpByStep(@Param(&quot;eid&quot;) int eid);--&gt;</span><br><span class="line">&lt;select id=&quot;getEmpByStep&quot; resultMap=&quot;empDeptStepMap&quot;&gt;</span><br><span class="line">select * from t_emp where eid = #&#123;eid&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-16"><a href="#-16" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 分步查询的第二步：根据员工所对应的did查询部门信息</span><br><span class="line">* @param did</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">Dept getEmpDeptByStep(@Param(&quot;did&quot;) int did);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--Dept getEmpDeptByStep(@Param(&quot;did&quot;) int did);--&gt;</span><br><span class="line">&lt;select id=&quot;getEmpDeptByStep&quot; resultType=&quot;Dept&quot;&gt;</span><br><span class="line">select * from t_dept where did = #&#123;did&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-17"><a href="#-17" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 根据部门id查新部门以及部门中的员工信息</span><br><span class="line">* @param did</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">Dept getDeptEmpByDid(@Param(&quot;did&quot;) int did);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;deptEmpMap&quot; type=&quot;Dept&quot;&gt;</span><br><span class="line">&lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt;</span><br><span class="line">&lt;result property=&quot;dname&quot; column=&quot;dname&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">ofType：设置collection标签所处理的集合属性中存储数据的类型</span><br><span class="line">--&gt;</span><br><span class="line">&lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt;</span><br><span class="line">&lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;</span><br><span class="line">&lt;result property=&quot;ename&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;!--Dept getDeptEmpByDid(@Param(&quot;did&quot;) int did);--&gt;</span><br><span class="line">&lt;select id=&quot;getDeptEmpByDid&quot; resultMap=&quot;deptEmpMap&quot;&gt;</span><br><span class="line">select dept.*,emp.* from t_dept dept left join t_emp emp on dept.did =</span><br><span class="line">emp.did where dept.did = #&#123;did&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-）查询部门信息"><a href="#1-）查询部门信息" class="headerlink" title="1 ）查询部门信息"></a>1 ）查询部门信息</h4><h4 id="2-）根据部门id查询部门中的所有员工"><a href="#2-）根据部门id查询部门中的所有员工" class="headerlink" title="2 ）根据部门id查询部门中的所有员工"></a>2 ）根据部门id查询部门中的所有员工</h4><h4 id="分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息："><a href="#分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：" class="headerlink" title="分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息："></a>分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：</h4><h4 id="lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载"><a href="#lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载" class="headerlink" title="lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载"></a>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载</h4><h4 id="aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。-否则，每个"><a href="#aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。-否则，每个" class="headerlink" title="aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个"></a>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个</h4><h4 id="属性会按需加载"><a href="#属性会按需加载" class="headerlink" title="属性会按需加载"></a>属性会按需加载</h4><h4 id="此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和"><a href="#此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和" class="headerlink" title="此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和"></a>此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和</h4><h4 id="collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType-”lazy-延迟加"><a href="#collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType-”lazy-延迟加" class="headerlink" title="collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType&#x3D;”lazy(延迟加"></a>collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType&#x3D;”lazy(延迟加</h4><h4 id="载-eager-立即加载-”"><a href="#载-eager-立即加载-”" class="headerlink" title="载)|eager(立即加载)”"></a>载)|eager(立即加载)”</h4><h1 id="九、动态SQL"><a href="#九、动态SQL" class="headerlink" title="九、动态SQL"></a>九、动态SQL</h1><h4 id="Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决"><a href="#Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决" class="headerlink" title="Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决"></a>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决</h4><h4 id="拼接SQL语句字符串时的痛点问题。"><a href="#拼接SQL语句字符串时的痛点问题。" class="headerlink" title="拼接SQL语句字符串时的痛点问题。"></a>拼接SQL语句字符串时的痛点问题。</h4><h2 id="1-、if"><a href="#1-、if" class="headerlink" title="1 、if"></a>1 、if</h2><h5 id="-18"><a href="#-18" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="分步查询部门和部门中的员工"><a href="#分步查询部门和部门中的员工" class="headerlink" title="* 分步查询部门和部门中的员工"></a>* 分步查询部门和部门中的员工</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* @param did</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">Dept getDeptByStep(@Param(&quot;did&quot;) int did);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;deptEmpStep&quot; type=&quot;Dept&quot;&gt;</span><br><span class="line">&lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt;</span><br><span class="line">&lt;result property=&quot;dname&quot; column=&quot;dname&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;collection property=&quot;emps&quot; fetchType=&quot;eager&quot;</span><br><span class="line">select=&quot;com.atguigu.MyBatis.mapper.EmpMapper.getEmpListByDid&quot; column=&quot;did&quot;&gt;</span><br><span class="line">&lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;!--Dept getDeptByStep(@Param(&quot;did&quot;) int did);--&gt;</span><br><span class="line">&lt;select id=&quot;getDeptByStep&quot; resultMap=&quot;deptEmpStep&quot;&gt;</span><br><span class="line">select * from t_dept where did = #&#123;did&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-19"><a href="#-19" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 根据部门id查询员工信息</span><br><span class="line">* @param did</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">List&lt;Emp&gt; getEmpListByDid(@Param(&quot;did&quot;) int did);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--List&lt;Emp&gt; getEmpListByDid(@Param(&quot;did&quot;) int did);--&gt;</span><br><span class="line">&lt;select id=&quot;getEmpListByDid&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">select * from t_emp where did = #&#123;did&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h4 id="if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中"><a href="#if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中" class="headerlink" title="if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中"></a>if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中</h4><h4 id="的内容不会执行"><a href="#的内容不会执行" class="headerlink" title="的内容不会执行"></a>的内容不会执行</h4><h2 id="2-、where"><a href="#2-、where" class="headerlink" title="2 、where"></a>2 、where</h2><h4 id="where和if一般结合使用："><a href="#where和if一般结合使用：" class="headerlink" title="where和if一般结合使用："></a>where和if一般结合使用：</h4><h4 id="a-若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字"><a href="#a-若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字" class="headerlink" title="a&gt;若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字"></a>a&gt;若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字</h4><h4 id="b-若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的"><a href="#b-若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的" class="headerlink" title="b&gt;若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的"></a>b&gt;若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的</h4><h4 id="and去掉"><a href="#and去掉" class="headerlink" title="and去掉"></a>and去掉</h4><h4 id="注意：where标签不能去掉条件最后多余的and"><a href="#注意：where标签不能去掉条件最后多余的and" class="headerlink" title="注意：where标签不能去掉条件最后多余的and"></a>注意：where标签不能去掉条件最后多余的and</h4><h2 id="3-、trim"><a href="#3-、trim" class="headerlink" title="3 、trim"></a>3 、trim</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--List&lt;Emp&gt; getEmpListByMoreTJ(Emp emp);--&gt;</span><br><span class="line">&lt;select id=&quot;getEmpListByMoreTJ&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">select * from t_emp where 1=</span><br><span class="line">&lt;if test=&quot;ename != &#x27;&#x27; and ename != null&quot;&gt;</span><br><span class="line">and ename = #&#123;ename&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;age != &#x27;&#x27; and age != null&quot;&gt;</span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;sex != &#x27;&#x27; and sex != null&quot;&gt;</span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getEmpListByMoreTJ2&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">select * from t_emp</span><br><span class="line">&lt;where&gt;</span><br><span class="line">&lt;if test=&quot;ename != &#x27;&#x27; and ename != null&quot;&gt;</span><br><span class="line">ename = #&#123;ename&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;age != &#x27;&#x27; and age != null&quot;&gt;</span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;sex != &#x27;&#x27; and sex != null&quot;&gt;</span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getEmpListByMoreTJ&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">select * from t_emp</span><br><span class="line">&lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and&quot;&gt;</span><br><span class="line">&lt;if test=&quot;ename != &#x27;&#x27; and ename != null&quot;&gt;</span><br><span class="line">ename = #&#123;ename&#125; and</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;age != &#x27;&#x27; and age != null&quot;&gt;</span><br><span class="line">age = #&#123;age&#125; and</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;sex != &#x27;&#x27; and sex != null&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="trim用于去掉或添加标签中的内容"><a href="#trim用于去掉或添加标签中的内容" class="headerlink" title="trim用于去掉或添加标签中的内容"></a>trim用于去掉或添加标签中的内容</h4><h4 id="常用属性："><a href="#常用属性：" class="headerlink" title="常用属性："></a>常用属性：</h4><h4 id="prefix：在trim标签中的内容的前面添加某些内容"><a href="#prefix：在trim标签中的内容的前面添加某些内容" class="headerlink" title="prefix：在trim标签中的内容的前面添加某些内容"></a>prefix：在trim标签中的内容的前面添加某些内容</h4><h4 id="prefixOverrides：在trim标签中的内容的前面去掉某些内容"><a href="#prefixOverrides：在trim标签中的内容的前面去掉某些内容" class="headerlink" title="prefixOverrides：在trim标签中的内容的前面去掉某些内容"></a>prefixOverrides：在trim标签中的内容的前面去掉某些内容</h4><h4 id="suffix：在trim标签中的内容的后面添加某些内容"><a href="#suffix：在trim标签中的内容的后面添加某些内容" class="headerlink" title="suffix：在trim标签中的内容的后面添加某些内容"></a>suffix：在trim标签中的内容的后面添加某些内容</h4><h4 id="suffixOverrides：在trim标签中的内容的后面去掉某些内容"><a href="#suffixOverrides：在trim标签中的内容的后面去掉某些内容" class="headerlink" title="suffixOverrides：在trim标签中的内容的后面去掉某些内容"></a>suffixOverrides：在trim标签中的内容的后面去掉某些内容</h4><h2 id="4-、choose、when、otherwise"><a href="#4-、choose、when、otherwise" class="headerlink" title="4 、choose、when、otherwise"></a>4 、choose、when、otherwise</h2><h4 id="choose、when、otherwise相当于if…else-if-else"><a href="#choose、when、otherwise相当于if…else-if-else" class="headerlink" title="choose、when、otherwise相当于if…else if..else"></a>choose、when、otherwise相当于if…else if..else</h4><h2 id="5-、foreach"><a href="#5-、foreach" class="headerlink" title="5 、foreach"></a>5 、foreach</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sex = #&#123;sex&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/trim&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--List&lt;Emp&gt; getEmpListByChoose(Emp emp);--&gt;</span><br><span class="line">&lt;select id=&quot;getEmpListByChoose&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp</span><br><span class="line">&lt;where&gt;</span><br><span class="line">&lt;choose&gt;</span><br><span class="line">&lt;when test=&quot;ename != &#x27;&#x27; and ename != null&quot;&gt;</span><br><span class="line">ename = #&#123;ename&#125;</span><br><span class="line">&lt;/when&gt;</span><br><span class="line">&lt;when test=&quot;age != &#x27;&#x27; and age != null&quot;&gt;</span><br><span class="line">age = #&#123;age&#125;</span><br><span class="line">&lt;/when&gt;</span><br><span class="line">&lt;when test=&quot;sex != &#x27;&#x27; and sex != null&quot;&gt;</span><br><span class="line">sex = #&#123;sex&#125;</span><br><span class="line">&lt;/when&gt;</span><br><span class="line">&lt;when test=&quot;email != &#x27;&#x27; and email != null&quot;&gt;</span><br><span class="line">email = #&#123;email&#125;</span><br><span class="line">&lt;/when&gt;</span><br><span class="line">&lt;/choose&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--int insertMoreEmp(List&lt;Emp&gt; emps);--&gt;</span><br><span class="line">&lt;insert id=&quot;insertMoreEmp&quot;&gt;</span><br><span class="line">insert into t_emp values</span><br><span class="line">&lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">(null,#&#123;emp.ename&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line">&lt;!--int deleteMoreByArray(int[] eids);--&gt;</span><br><span class="line">&lt;delete id=&quot;deleteMoreByArray&quot;&gt;</span><br><span class="line">delete from t_emp where</span><br><span class="line">&lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">eid = #&#123;eid&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br></pre></td></tr></table></figure>

<h4 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h4><h4 id="collection：设置要循环的数组或集合"><a href="#collection：设置要循环的数组或集合" class="headerlink" title="collection：设置要循环的数组或集合"></a>collection：设置要循环的数组或集合</h4><h4 id="item：表示集合或数组中的每一个数据"><a href="#item：表示集合或数组中的每一个数据" class="headerlink" title="item：表示集合或数组中的每一个数据"></a>item：表示集合或数组中的每一个数据</h4><h4 id="separator：设置循环体之间的分隔符"><a href="#separator：设置循环体之间的分隔符" class="headerlink" title="separator：设置循环体之间的分隔符"></a>separator：设置循环体之间的分隔符</h4><h4 id="open：设置foreach标签中的内容的开始符"><a href="#open：设置foreach标签中的内容的开始符" class="headerlink" title="open：设置foreach标签中的内容的开始符"></a>open：设置foreach标签中的内容的开始符</h4><h4 id="close：设置foreach标签中的内容的结束符"><a href="#close：设置foreach标签中的内容的结束符" class="headerlink" title="close：设置foreach标签中的内容的结束符"></a>close：设置foreach标签中的内容的结束符</h4><h2 id="6-、SQL片段"><a href="#6-、SQL片段" class="headerlink" title="6 、SQL片段"></a>6 、SQL片段</h2><h4 id="sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入"><a href="#sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入" class="headerlink" title="sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入"></a>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</h4><h1 id="十、MyBatis的缓存"><a href="#十、MyBatis的缓存" class="headerlink" title="十、MyBatis的缓存"></a>十、MyBatis的缓存</h1><h2 id="1-、MyBatis的一级缓存"><a href="#1-、MyBatis的一级缓存" class="headerlink" title="1 、MyBatis的一级缓存"></a>1 、MyBatis的一级缓存</h2><h4 id="一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就"><a href="#一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就" class="headerlink" title="一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就"></a>一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就</h4><h4 id="会从缓存中直接获取，不会从数据库重新访问"><a href="#会从缓存中直接获取，不会从数据库重新访问" class="headerlink" title="会从缓存中直接获取，不会从数据库重新访问"></a>会从缓存中直接获取，不会从数据库重新访问</h4><h4 id="使一级缓存失效的四种情况："><a href="#使一级缓存失效的四种情况：" class="headerlink" title="使一级缓存失效的四种情况："></a>使一级缓存失效的四种情况：</h4><h4 id="1-不同的SqlSession对应不同的一级缓存"><a href="#1-不同的SqlSession对应不同的一级缓存" class="headerlink" title="1) 不同的SqlSession对应不同的一级缓存"></a>1) 不同的SqlSession对应不同的一级缓存</h4><h4 id="2-同一个SqlSession但是查询条件不同"><a href="#2-同一个SqlSession但是查询条件不同" class="headerlink" title="2) 同一个SqlSession但是查询条件不同"></a>2) 同一个SqlSession但是查询条件不同</h4><h4 id="3-同一个SqlSession两次查询期间执行了任何一次增删改操作"><a href="#3-同一个SqlSession两次查询期间执行了任何一次增删改操作" class="headerlink" title="3) 同一个SqlSession两次查询期间执行了任何一次增删改操作"></a>3) 同一个SqlSession两次查询期间执行了任何一次增删改操作</h4><h4 id="4-同一个SqlSession两次查询期间手动清空了缓存"><a href="#4-同一个SqlSession两次查询期间手动清空了缓存" class="headerlink" title="4) 同一个SqlSession两次查询期间手动清空了缓存"></a>4) 同一个SqlSession两次查询期间手动清空了缓存</h4><h2 id="2-、MyBatis的二级缓存"><a href="#2-、MyBatis的二级缓存" class="headerlink" title="2 、MyBatis的二级缓存"></a>2 、MyBatis的二级缓存</h2><h4 id="二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被"><a href="#二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被" class="headerlink" title="二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被"></a>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被</h4><h4 id="缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取"><a href="#缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取" class="headerlink" title="缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取"></a>缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</h4><h4 id="二级缓存开启的条件："><a href="#二级缓存开启的条件：" class="headerlink" title="二级缓存开启的条件："></a>二级缓存开启的条件：</h4><h4 id="a-在核心配置文件中，设置全局配置属性cacheEnabled-”true”，默认为true，不需要设置"><a href="#a-在核心配置文件中，设置全局配置属性cacheEnabled-”true”，默认为true，不需要设置" class="headerlink" title="a&gt;在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;”true”，默认为true，不需要设置"></a>a&gt;在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;”true”，默认为true，不需要设置</h4><h4 id="b-在映射文件中设置标签"><a href="#b-在映射文件中设置标签" class="headerlink" title="b&gt;在映射文件中设置标签"></a>b&gt;在映射文件中设置标签<cache /></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/delete&gt;</span><br><span class="line">&lt;!--int deleteMoreByArray(int[] eids);--&gt;</span><br><span class="line">&lt;delete id=&quot;deleteMoreByArray&quot;&gt;</span><br><span class="line">delete from t_emp where eid in</span><br><span class="line">&lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;</span><br><span class="line">#&#123;eid&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sql id=&quot;empColumns&quot;&gt;</span><br><span class="line">eid,ename,age,sex,did</span><br><span class="line">&lt;/sql&gt;</span><br><span class="line">select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp</span><br></pre></td></tr></table></figure>

<h4 id="c-二级缓存必须在SqlSession关闭或提交之后有效"><a href="#c-二级缓存必须在SqlSession关闭或提交之后有效" class="headerlink" title="c&gt;二级缓存必须在SqlSession关闭或提交之后有效"></a>c&gt;二级缓存必须在SqlSession关闭或提交之后有效</h4><h4 id="d-查询的数据所转换的实体类类型必须实现序列化的接口"><a href="#d-查询的数据所转换的实体类类型必须实现序列化的接口" class="headerlink" title="d&gt;查询的数据所转换的实体类类型必须实现序列化的接口"></a>d&gt;查询的数据所转换的实体类类型必须实现序列化的接口</h4><h4 id="使二级缓存失效的情况："><a href="#使二级缓存失效的情况：" class="headerlink" title="使二级缓存失效的情况："></a>使二级缓存失效的情况：</h4><h4 id="两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效"><a href="#两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效" class="headerlink" title="两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效"></a>两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</h4><h2 id="3-、二级缓存的相关配置"><a href="#3-、二级缓存的相关配置" class="headerlink" title="3 、二级缓存的相关配置"></a>3 、二级缓存的相关配置</h2><h4 id="在mapper配置文件中添加的cache标签可以设置一些属性："><a href="#在mapper配置文件中添加的cache标签可以设置一些属性：" class="headerlink" title="在mapper配置文件中添加的cache标签可以设置一些属性："></a>在mapper配置文件中添加的cache标签可以设置一些属性：</h4><h4 id="eviction属性：缓存回收策略"><a href="#eviction属性：缓存回收策略" class="headerlink" title="eviction属性：缓存回收策略"></a>eviction属性：缓存回收策略</h4><h4 id="LRU（Least-Recently-Used）-–-最近最少使用的：移除最长时间不被使用的对象。"><a href="#LRU（Least-Recently-Used）-–-最近最少使用的：移除最长时间不被使用的对象。" class="headerlink" title="LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。"></a>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。</h4><h4 id="FIFO（First-in-First-out）-–-先进先出：按对象进入缓存的顺序来移除它们。"><a href="#FIFO（First-in-First-out）-–-先进先出：按对象进入缓存的顺序来移除它们。" class="headerlink" title="FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。"></a>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。</h4><h4 id="SOFT-–-软引用：移除基于垃圾回收器状态和软引用规则的对象。"><a href="#SOFT-–-软引用：移除基于垃圾回收器状态和软引用规则的对象。" class="headerlink" title="SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。"></a>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</h4><h4 id="WEAK-–-弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。"><a href="#WEAK-–-弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。" class="headerlink" title="WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。"></a>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</h4><h4 id="默认的是-LRU。"><a href="#默认的是-LRU。" class="headerlink" title="默认的是 LRU。"></a>默认的是 LRU。</h4><h4 id="flushInterval属性：刷新间隔，单位毫秒"><a href="#flushInterval属性：刷新间隔，单位毫秒" class="headerlink" title="flushInterval属性：刷新间隔，单位毫秒"></a>flushInterval属性：刷新间隔，单位毫秒</h4><h4 id="默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新"><a href="#默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新" class="headerlink" title="默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新"></a>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</h4><h4 id="size属性：引用数目，正整数"><a href="#size属性：引用数目，正整数" class="headerlink" title="size属性：引用数目，正整数"></a>size属性：引用数目，正整数</h4><h4 id="代表缓存最多可以存储多少个对象，太大容易导致内存溢出"><a href="#代表缓存最多可以存储多少个对象，太大容易导致内存溢出" class="headerlink" title="代表缓存最多可以存储多少个对象，太大容易导致内存溢出"></a>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</h4><h4 id="readOnly属性：只读，true-false"><a href="#readOnly属性：只读，true-false" class="headerlink" title="readOnly属性：只读，true&#x2F;false"></a>readOnly属性：只读，true&#x2F;false</h4><h4 id="true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了"><a href="#true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了" class="headerlink" title="true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了"></a>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了</h4><h4 id="很重要的性能优势。"><a href="#很重要的性能优势。" class="headerlink" title="很重要的性能优势。"></a>很重要的性能优势。</h4><h4 id="false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是"><a href="#false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是" class="headerlink" title="false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是"></a>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是</h4><h4 id="false。"><a href="#false。" class="headerlink" title="false。"></a>false。</h4><h2 id="4-、MyBatis缓存查询的顺序"><a href="#4-、MyBatis缓存查询的顺序" class="headerlink" title="4 、MyBatis缓存查询的顺序"></a>4 、MyBatis缓存查询的顺序</h2><h4 id="先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。"><a href="#先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。" class="headerlink" title="先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。"></a>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。</h4><h4 id="如果二级缓存没有命中，再查询一级缓存"><a href="#如果二级缓存没有命中，再查询一级缓存" class="headerlink" title="如果二级缓存没有命中，再查询一级缓存"></a>如果二级缓存没有命中，再查询一级缓存</h4><h4 id="如果一级缓存也没有命中，则查询数据库"><a href="#如果一级缓存也没有命中，则查询数据库" class="headerlink" title="如果一级缓存也没有命中，则查询数据库"></a>如果一级缓存也没有命中，则查询数据库</h4><h4 id="SqlSession关闭之后，一级缓存中的数据会写入二级缓存"><a href="#SqlSession关闭之后，一级缓存中的数据会写入二级缓存" class="headerlink" title="SqlSession关闭之后，一级缓存中的数据会写入二级缓存"></a>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</h4><h2 id="5-、整合第三方缓存EHCache"><a href="#5-、整合第三方缓存EHCache" class="headerlink" title="5 、整合第三方缓存EHCache"></a>5 、整合第三方缓存EHCache</h2><h3 id="a-添加依赖"><a href="#a-添加依赖" class="headerlink" title="a&gt;添加依赖"></a>a&gt;添加依赖</h3><h4 id="jar包名称-作用"><a href="#jar包名称-作用" class="headerlink" title="jar包名称 作用"></a>jar包名称 作用</h4><h4 id="mybatis-ehcache-Mybatis和EHCache的整合包"><a href="#mybatis-ehcache-Mybatis和EHCache的整合包" class="headerlink" title="mybatis-ehcache Mybatis和EHCache的整合包"></a>mybatis-ehcache Mybatis和EHCache的整合包</h4><h4 id="ehcache-EHCache核心包"><a href="#ehcache-EHCache核心包" class="headerlink" title="ehcache EHCache核心包"></a>ehcache EHCache核心包</h4><h4 id="slf4j-api-SLF4J日志门面包"><a href="#slf4j-api-SLF4J日志门面包" class="headerlink" title="slf4j-api SLF4J日志门面包"></a>slf4j-api SLF4J日志门面包</h4><h4 id="logback-classic-支持SLF4J门面接口的一个具体实现"><a href="#logback-classic-支持SLF4J门面接口的一个具体实现" class="headerlink" title="logback-classic 支持SLF4J门面接口的一个具体实现"></a>logback-classic 支持SLF4J门面接口的一个具体实现</h4><h3 id="b-各jar包功能"><a href="#b-各jar包功能" class="headerlink" title="b&gt;各jar包功能"></a>b&gt;各jar包功能</h3><h3 id="c-创建EHCache的配置文件ehcache-xml"><a href="#c-创建EHCache的配置文件ehcache-xml" class="headerlink" title="c&gt;创建EHCache的配置文件ehcache.xml"></a>c&gt;创建EHCache的配置文件ehcache.xml</h3><h3 id="d-设置二级缓存的类型"><a href="#d-设置二级缓存的类型" class="headerlink" title="d&gt;设置二级缓存的类型"></a>d&gt;设置二级缓存的类型</h3><h3 id="e-加入logback日志"><a href="#e-加入logback日志" class="headerlink" title="e&gt;加入logback日志"></a>e&gt;加入logback日志</h3><h4 id="存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。"><a href="#存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。" class="headerlink" title="存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。"></a>存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。</h4><h4 id="创建logback的配置文件logback-xml"><a href="#创建logback的配置文件logback-xml" class="headerlink" title="创建logback的配置文件logback.xml"></a>创建logback的配置文件logback.xml</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Mybatis EHCache整合包 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- slf4j日志门面的一个具体实现 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt;</span><br><span class="line">&lt;!-- 磁盘保存路径 --&gt;</span><br><span class="line">&lt;diskStore path=&quot;D:\atguigu\ehcache&quot;/&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;defaultCache</span><br><span class="line">maxElementsInMemory=&quot;1000&quot;</span><br><span class="line">maxElementsOnDisk=&quot;10000000&quot;</span><br><span class="line">eternal=&quot;false&quot;</span><br><span class="line">overflowToDisk=&quot;true&quot;</span><br><span class="line">timeToIdleSeconds=&quot;120&quot;</span><br><span class="line">timeToLiveSeconds=&quot;120&quot;</span><br><span class="line">diskExpiryThreadIntervalSeconds=&quot;120&quot;</span><br><span class="line">memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;</span><br><span class="line">&lt;/defaultCache&gt;</span><br><span class="line">&lt;/ehcache&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="f-EHCache配置文件说明"><a href="#f-EHCache配置文件说明" class="headerlink" title="f&gt;EHCache配置文件说明"></a>f&gt;EHCache配置文件说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration debug=&quot;true&quot;&gt;</span><br><span class="line">&lt;!-- 指定日志输出的位置 --&gt;</span><br><span class="line">&lt;appender name=&quot;STDOUT&quot;</span><br><span class="line">class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">&lt;encoder&gt;</span><br><span class="line">&lt;!-- 日志输出的格式 --&gt;</span><br><span class="line">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 -</span><br><span class="line">-&gt;</span><br><span class="line">&lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger]</span><br><span class="line">[%msg]%n&lt;/pattern&gt;</span><br><span class="line">&lt;/encoder&gt;</span><br><span class="line">&lt;/appender&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-20"><a href="#-20" class="headerlink" title=""></a><!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --></h5><h5 id="-21"><a href="#-21" class="headerlink" title=""></a><!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;root level=&quot;DEBUG&quot;&gt;</span><br><span class="line">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span><br><span class="line">&lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-22"><a href="#-22" class="headerlink" title=""></a><!-- 根据特殊需求指定局部日志级别 --></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;logger name=&quot;com.atguigu.crowd.mapper&quot; level=&quot;DEBUG&quot;/&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h4 id="属性名"><a href="#属性名" class="headerlink" title="属性名"></a>属性名</h4><h4 id="是"><a href="#是" class="headerlink" title="是"></a>是</h4><h4 id="否"><a href="#否" class="headerlink" title="否"></a>否</h4><h4 id="必"><a href="#必" class="headerlink" title="必"></a>必</h4><h4 id="须"><a href="#须" class="headerlink" title="须"></a>须</h4><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><h4 id="maxElementsInMemory-是-在内存中缓存的element的最大数目"><a href="#maxElementsInMemory-是-在内存中缓存的element的最大数目" class="headerlink" title="maxElementsInMemory 是 在内存中缓存的element的最大数目"></a>maxElementsInMemory 是 在内存中缓存的element的最大数目</h4><h4 id="maxElementsOnDisk-是"><a href="#maxElementsOnDisk-是" class="headerlink" title="maxElementsOnDisk 是"></a>maxElementsOnDisk 是</h4><h4 id="在磁盘上缓存的element的最大数目，若是-0-表示无"><a href="#在磁盘上缓存的element的最大数目，若是-0-表示无" class="headerlink" title="在磁盘上缓存的element的最大数目，若是 0 表示无"></a>在磁盘上缓存的element的最大数目，若是 0 表示无</h4><h4 id="穷大"><a href="#穷大" class="headerlink" title="穷大"></a>穷大</h4><h4 id="eternal-是"><a href="#eternal-是" class="headerlink" title="eternal 是"></a>eternal 是</h4><h4 id="设定缓存的elements是否永远不过期。-如果为"><a href="#设定缓存的elements是否永远不过期。-如果为" class="headerlink" title="设定缓存的elements是否永远不过期。 如果为"></a>设定缓存的elements是否永远不过期。 如果为</h4><h4 id="true，则缓存的数据始终有效，-如果为false那么还"><a href="#true，则缓存的数据始终有效，-如果为false那么还" class="headerlink" title="true，则缓存的数据始终有效， 如果为false那么还"></a>true，则缓存的数据始终有效， 如果为false那么还</h4><h4 id="要根据timeToIdleSeconds、timeToLiveSeconds"><a href="#要根据timeToIdleSeconds、timeToLiveSeconds" class="headerlink" title="要根据timeToIdleSeconds、timeToLiveSeconds"></a>要根据timeToIdleSeconds、timeToLiveSeconds</h4><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><h4 id="overflowToDisk-是"><a href="#overflowToDisk-是" class="headerlink" title="overflowToDisk 是"></a>overflowToDisk 是</h4><h4 id="设定当内存缓存溢出的时候是否将过期的element"><a href="#设定当内存缓存溢出的时候是否将过期的element" class="headerlink" title="设定当内存缓存溢出的时候是否将过期的element"></a>设定当内存缓存溢出的时候是否将过期的element</h4><h4 id="缓存到磁盘上"><a href="#缓存到磁盘上" class="headerlink" title="缓存到磁盘上"></a>缓存到磁盘上</h4><h4 id="timeToIdleSeconds-否"><a href="#timeToIdleSeconds-否" class="headerlink" title="timeToIdleSeconds 否"></a>timeToIdleSeconds 否</h4><h4 id="当缓存在EhCache中的数据前后两次访问的时间超"><a href="#当缓存在EhCache中的数据前后两次访问的时间超" class="headerlink" title="当缓存在EhCache中的数据前后两次访问的时间超"></a>当缓存在EhCache中的数据前后两次访问的时间超</h4><h4 id="过timeToIdleSeconds的属性取值时，-这些数据便"><a href="#过timeToIdleSeconds的属性取值时，-这些数据便" class="headerlink" title="过timeToIdleSeconds的属性取值时， 这些数据便"></a>过timeToIdleSeconds的属性取值时， 这些数据便</h4><h4 id="会删除，默认值是0-也就是可闲置时间无穷大"><a href="#会删除，默认值是0-也就是可闲置时间无穷大" class="headerlink" title="会删除，默认值是0,也就是可闲置时间无穷大"></a>会删除，默认值是0,也就是可闲置时间无穷大</h4><h4 id="timeToLiveSeconds-否"><a href="#timeToLiveSeconds-否" class="headerlink" title="timeToLiveSeconds 否"></a>timeToLiveSeconds 否</h4><h4 id="缓存element的有效生命期，默认是0-也就是"><a href="#缓存element的有效生命期，默认是0-也就是" class="headerlink" title="缓存element的有效生命期，默认是0.,也就是"></a>缓存element的有效生命期，默认是0.,也就是</h4><h4 id="element存活时间无穷大"><a href="#element存活时间无穷大" class="headerlink" title="element存活时间无穷大"></a>element存活时间无穷大</h4><h4 id="diskSpoolBufferSizeMB-否"><a href="#diskSpoolBufferSizeMB-否" class="headerlink" title="diskSpoolBufferSizeMB 否"></a>diskSpoolBufferSizeMB 否</h4><h4 id="DiskStore-磁盘缓存-的缓存区大小。默认是"><a href="#DiskStore-磁盘缓存-的缓存区大小。默认是" class="headerlink" title="DiskStore(磁盘缓存)的缓存区大小。默认是"></a>DiskStore(磁盘缓存)的缓存区大小。默认是</h4><h4 id="30MB。每个Cache都应该有自己的一个缓冲区"><a href="#30MB。每个Cache都应该有自己的一个缓冲区" class="headerlink" title="30MB。每个Cache都应该有自己的一个缓冲区"></a>30MB。每个Cache都应该有自己的一个缓冲区</h4><h4 id="diskPersistent-否"><a href="#diskPersistent-否" class="headerlink" title="diskPersistent 否"></a>diskPersistent 否</h4><h4 id="在VM重启的时候是否启用磁盘保存EhCache中的数"><a href="#在VM重启的时候是否启用磁盘保存EhCache中的数" class="headerlink" title="在VM重启的时候是否启用磁盘保存EhCache中的数"></a>在VM重启的时候是否启用磁盘保存EhCache中的数</h4><h4 id="据，默认是false。"><a href="#据，默认是false。" class="headerlink" title="据，默认是false。"></a>据，默认是false。</h4><h4 id="diskExpiryThreadIntervalSeconds-否"><a href="#diskExpiryThreadIntervalSeconds-否" class="headerlink" title="diskExpiryThreadIntervalSeconds 否"></a>diskExpiryThreadIntervalSeconds 否</h4><h4 id="磁盘缓存的清理线程运行间隔，默认是-120-秒。每"><a href="#磁盘缓存的清理线程运行间隔，默认是-120-秒。每" class="headerlink" title="磁盘缓存的清理线程运行间隔，默认是 120 秒。每"></a>磁盘缓存的清理线程运行间隔，默认是 120 秒。每</h4><h4 id="个120s，-相应的线程会进行一次EhCache中数据的"><a href="#个120s，-相应的线程会进行一次EhCache中数据的" class="headerlink" title="个120s， 相应的线程会进行一次EhCache中数据的"></a>个120s， 相应的线程会进行一次EhCache中数据的</h4><h4 id="清理工作"><a href="#清理工作" class="headerlink" title="清理工作"></a>清理工作</h4><h4 id="memoryStoreEvictionPolicy-否"><a href="#memoryStoreEvictionPolicy-否" class="headerlink" title="memoryStoreEvictionPolicy 否"></a>memoryStoreEvictionPolicy 否</h4><h4 id="当内存缓存达到最大，有新的element加入的时"><a href="#当内存缓存达到最大，有新的element加入的时" class="headerlink" title="当内存缓存达到最大，有新的element加入的时"></a>当内存缓存达到最大，有新的element加入的时</h4><h4 id="候，-移除缓存中element的策略。-默认是LRU（最"><a href="#候，-移除缓存中element的策略。-默认是LRU（最" class="headerlink" title="候， 移除缓存中element的策略。 默认是LRU（最"></a>候， 移除缓存中element的策略。 默认是LRU（最</h4><h4 id="近最少使用），可选的有LFU（最不常使用）和"><a href="#近最少使用），可选的有LFU（最不常使用）和" class="headerlink" title="近最少使用），可选的有LFU（最不常使用）和"></a>近最少使用），可选的有LFU（最不常使用）和</h4><h4 id="FIFO（先进先出）"><a href="#FIFO（先进先出）" class="headerlink" title="FIFO（先进先出）"></a>FIFO（先进先出）</h4><h1 id="十一、MyBatis的逆向工程"><a href="#十一、MyBatis的逆向工程" class="headerlink" title="十一、MyBatis的逆向工程"></a>十一、MyBatis的逆向工程</h1><h4 id="正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程"><a href="#正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程" class="headerlink" title="正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程"></a>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程</h4><h4 id="的。"><a href="#的。" class="headerlink" title="的。"></a>的。</h4><h4 id="逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源："><a href="#逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：" class="headerlink" title="逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源："></a>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：</h4><h4 id="Java实体类"><a href="#Java实体类" class="headerlink" title="Java实体类"></a>Java实体类</h4><h4 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h4><h4 id="Mapper映射文件"><a href="#Mapper映射文件" class="headerlink" title="Mapper映射文件"></a>Mapper映射文件</h4><h2 id="1-、创建逆向工程的步骤"><a href="#1-、创建逆向工程的步骤" class="headerlink" title="1 、创建逆向工程的步骤"></a>1 、创建逆向工程的步骤</h2><h2 id="a-添加依赖和插件"><a href="#a-添加依赖和插件" class="headerlink" title="a&gt;添加依赖和插件"></a>a&gt;添加依赖和插件</h2><h3 id="b-创建MyBatis的核心配置文件"><a href="#b-创建MyBatis的核心配置文件" class="headerlink" title="b&gt;创建MyBatis的核心配置文件"></a>b&gt;创建MyBatis的核心配置文件</h3><h3 id="c-创建逆向工程的配置文件"><a href="#c-创建逆向工程的配置文件" class="headerlink" title="c&gt;创建逆向工程的配置文件"></a>c&gt;创建逆向工程的配置文件</h3><h4 id="文件名必须是：generatorConfig-xml"><a href="#文件名必须是：generatorConfig-xml" class="headerlink" title="文件名必须是：generatorConfig.xml"></a>文件名必须是：generatorConfig.xml</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 依赖MyBatis核心包 --&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.5.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span><br><span class="line">&lt;build&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-23"><a href="#-23" class="headerlink" title=""></a><!-- 构建过程中用到的插件 --></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-24"><a href="#-24" class="headerlink" title=""></a><!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.0&lt;/version&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-25"><a href="#-25" class="headerlink" title=""></a><!-- 插件的依赖 --></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-26"><a href="#-26" class="headerlink" title=""></a><!-- 逆向工程的核心依赖 --></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h5 id="-27"><a href="#-27" class="headerlink" title=""></a><!-- 数据库连接池 --></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.mchange&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- MySQL驱动 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.1.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br></pre></td></tr></table></figure>

<h3 id="d-执行MBG插件的generate目标"><a href="#d-执行MBG插件的generate目标" class="headerlink" title="d&gt;执行MBG插件的generate目标"></a>d&gt;执行MBG插件的generate目标</h3><h4 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">targetRuntime: 执行生成的逆向工程的版本</span><br><span class="line">MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span><br><span class="line">MyBatis3: 生成带条件的CRUD（奢华尊享版）</span><br><span class="line">--&gt;</span><br><span class="line">&lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3Simple&quot;&gt;</span><br><span class="line">&lt;!-- 数据库的连接信息 --&gt;</span><br><span class="line">&lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span><br><span class="line">userId=&quot;root&quot;</span><br><span class="line">password=&quot;123456&quot;&gt;</span><br><span class="line">&lt;/jdbcConnection&gt;</span><br><span class="line">&lt;!-- javaBean的生成策略--&gt;</span><br><span class="line">&lt;javaModelGenerator targetPackage=&quot;com.atguigu.mybatis.bean&quot;</span><br><span class="line">targetProject=&quot;.\src\main\java&quot;&gt;</span><br><span class="line">&lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/javaModelGenerator&gt;</span><br><span class="line">&lt;!-- SQL映射文件的生成策略 --&gt;</span><br><span class="line">&lt;sqlMapGenerator targetPackage=&quot;com.atguigu.mybatis.mapper&quot;</span><br><span class="line">targetProject=&quot;.\src\main\resources&quot;&gt;</span><br><span class="line">&lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/sqlMapGenerator&gt;</span><br><span class="line">&lt;!-- Mapper接口的生成策略 --&gt;</span><br><span class="line">&lt;javaClientGenerator type=&quot;XMLMAPPER&quot;</span><br><span class="line">targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\src\main\java&quot;&gt;</span><br><span class="line">&lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/javaClientGenerator&gt;</span><br><span class="line">&lt;!-- 逆向分析的表 --&gt;</span><br><span class="line">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span><br><span class="line">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span><br><span class="line">&lt;table tableName=&quot;t_emp&quot; domainObjectName=&quot;Emp&quot;/&gt;</span><br><span class="line">&lt;table tableName=&quot;t_dept&quot; domainObjectName=&quot;Dept&quot;/&gt;</span><br><span class="line">&lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-、QBC查询"><a href="#2-、QBC查询" class="headerlink" title="2 、QBC查询"></a>2 、QBC查询</h2><h1 id="十二、分页插件"><a href="#十二、分页插件" class="headerlink" title="十二、分页插件"></a>十二、分页插件</h1><h2 id="1-、分页插件使用步骤"><a href="#1-、分页插件使用步骤" class="headerlink" title="1 、分页插件使用步骤"></a>1 、分页插件使用步骤</h2><h2 id="a-添加依赖-1"><a href="#a-添加依赖-1" class="headerlink" title="a&gt;添加依赖"></a>a&gt;添加依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testMBG() throws IOException &#123;</span><br><span class="line">InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">SqlSession sqlSession = new</span><br><span class="line">SqlSessionFactoryBuilder().build(is).openSession(true);</span><br><span class="line">EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">EmpExample empExample = new EmpExample();</span><br><span class="line">//创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">empExample.createCriteria().andEnameLike(&quot;a&quot;).andAgeGreaterThan( 20 ).andDidIsNot</span><br><span class="line">Null();</span><br><span class="line">//将之前添加的条件通过or拼接其他条件</span><br><span class="line">empExample.or().andSexEqualTo(&quot;男&quot;);</span><br><span class="line">List&lt;Emp&gt; list = mapper.selectByExample(empExample);</span><br><span class="line">for (Emp emp : list) &#123;</span><br><span class="line">System.out.println(emp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="b-配置分页插件"><a href="#b-配置分页插件" class="headerlink" title="b&gt;配置分页插件"></a>b&gt;配置分页插件</h3><h4 id="在MyBatis的核心配置文件中配置插件"><a href="#在MyBatis的核心配置文件中配置插件" class="headerlink" title="在MyBatis的核心配置文件中配置插件"></a>在MyBatis的核心配置文件中配置插件</h4><h2 id="2-、分页插件的使用"><a href="#2-、分页插件的使用" class="headerlink" title="2 、分页插件的使用"></a>2 、分页插件的使用</h2><h4 id="a-在查询功能之前使用PageHelper-startPage-int-pageNum-int-pageSize-开启分页功能"><a href="#a-在查询功能之前使用PageHelper-startPage-int-pageNum-int-pageSize-开启分页功能" class="headerlink" title="a&gt;在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能"></a>a&gt;在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能</h4><h4 id="pageNum：当前页的页码"><a href="#pageNum：当前页的页码" class="headerlink" title="pageNum：当前页的页码"></a>pageNum：当前页的页码</h4><h4 id="pageSize：每页显示的条数"><a href="#pageSize：每页显示的条数" class="headerlink" title="pageSize：每页显示的条数"></a>pageSize：每页显示的条数</h4><h4 id="b-在查询获取list集合之后，使用PageInfo-pageInfo-new-PageInfo-List-list-int"><a href="#b-在查询获取list集合之后，使用PageInfo-pageInfo-new-PageInfo-List-list-int" class="headerlink" title="b&gt;在查询获取list集合之后，使用PageInfo pageInfo &#x3D; new PageInfo&lt;&gt;(List list, int"></a>b&gt;在查询获取list集合之后，使用PageInfo<T> pageInfo &#x3D; new PageInfo&lt;&gt;(List<T> list, int</h4><h4 id="navigatePages-获取分页相关数据"><a href="#navigatePages-获取分页相关数据" class="headerlink" title="navigatePages)获取分页相关数据"></a>navigatePages)获取分页相关数据</h4><h4 id="list：分页之后的数据"><a href="#list：分页之后的数据" class="headerlink" title="list：分页之后的数据"></a>list：分页之后的数据</h4><h4 id="navigatePages：导航分页的页码数"><a href="#navigatePages：导航分页的页码数" class="headerlink" title="navigatePages：导航分页的页码数"></a>navigatePages：导航分页的页码数</h4><h4 id="c-分页相关数据"><a href="#c-分页相关数据" class="headerlink" title="c&gt;分页相关数据"></a>c&gt;分页相关数据</h4><h4 id="PageInfo"><a href="#PageInfo" class="headerlink" title="PageInfo{"></a>PageInfo{</h4><h4 id="pageNum-8-pageSize-4-size-2-startRow-29-endRow-30-total-30-pages-8"><a href="#pageNum-8-pageSize-4-size-2-startRow-29-endRow-30-total-30-pages-8" class="headerlink" title="pageNum&#x3D;8, pageSize&#x3D;4, size&#x3D;2, startRow&#x3D;29, endRow&#x3D;30, total&#x3D;30, pages&#x3D;8,"></a>pageNum&#x3D;8, pageSize&#x3D;4, size&#x3D;2, startRow&#x3D;29, endRow&#x3D;30, total&#x3D;30, pages&#x3D;8,</h4><h4 id="list-Page-count-true-pageNum-8-pageSize-4-startRow-28-endRow-32-total-30"><a href="#list-Page-count-true-pageNum-8-pageSize-4-startRow-28-endRow-32-total-30" class="headerlink" title="list&#x3D;Page{count&#x3D;true, pageNum&#x3D;8, pageSize&#x3D;4, startRow&#x3D;28, endRow&#x3D;32, total&#x3D;30,"></a>list&#x3D;Page{count&#x3D;true, pageNum&#x3D;8, pageSize&#x3D;4, startRow&#x3D;28, endRow&#x3D;32, total&#x3D;30,</h4><h4 id="pages-8-reasonable-false-pageSizeZero-false"><a href="#pages-8-reasonable-false-pageSizeZero-false" class="headerlink" title="pages&#x3D;8, reasonable&#x3D;false, pageSizeZero&#x3D;false},"></a>pages&#x3D;8, reasonable&#x3D;false, pageSizeZero&#x3D;false},</h4><h4 id="prePage-7-nextPage-0-isFirstPage-false-isLastPage-true-hasPreviousPage-true"><a href="#prePage-7-nextPage-0-isFirstPage-false-isLastPage-true-hasPreviousPage-true" class="headerlink" title="prePage&#x3D;7, nextPage&#x3D;0, isFirstPage&#x3D;false, isLastPage&#x3D;true, hasPreviousPage&#x3D;true,"></a>prePage&#x3D;7, nextPage&#x3D;0, isFirstPage&#x3D;false, isLastPage&#x3D;true, hasPreviousPage&#x3D;true,</h4><h4 id="hasNextPage-false-navigatePages-5-navigateFirstPage4-navigateLastPage8"><a href="#hasNextPage-false-navigatePages-5-navigateFirstPage4-navigateLastPage8" class="headerlink" title="hasNextPage&#x3D;false, navigatePages&#x3D;5, navigateFirstPage4, navigateLastPage8,"></a>hasNextPage&#x3D;false, navigatePages&#x3D;5, navigateFirstPage4, navigateLastPage8,</h4><h4 id="navigatepageNums-4-5-6-7-8"><a href="#navigatepageNums-4-5-6-7-8" class="headerlink" title="navigatepageNums&#x3D;[4, 5, 6, 7, 8]"></a>navigatepageNums&#x3D;[4, 5, 6, 7, 8]</h4><h4 id="-28"><a href="#-28" class="headerlink" title="}"></a>}</h4><h4 id="常用数据："><a href="#常用数据：" class="headerlink" title="常用数据："></a>常用数据：</h4><h4 id="pageNum：当前页的页码-1"><a href="#pageNum：当前页的页码-1" class="headerlink" title="pageNum：当前页的页码"></a>pageNum：当前页的页码</h4><h4 id="pageSize：每页显示的条数-1"><a href="#pageSize：每页显示的条数-1" class="headerlink" title="pageSize：每页显示的条数"></a>pageSize：每页显示的条数</h4><h4 id="size：当前页显示的真实条数"><a href="#size：当前页显示的真实条数" class="headerlink" title="size：当前页显示的真实条数"></a>size：当前页显示的真实条数</h4><h4 id="total：总记录数"><a href="#total：总记录数" class="headerlink" title="total：总记录数"></a>total：总记录数</h4><h4 id="pages：总页数"><a href="#pages：总页数" class="headerlink" title="pages：总页数"></a>pages：总页数</h4><h4 id="prePage：上一页的页码"><a href="#prePage：上一页的页码" class="headerlink" title="prePage：上一页的页码"></a>prePage：上一页的页码</h4><h4 id="nextPage：下一页的页码"><a href="#nextPage：下一页的页码" class="headerlink" title="nextPage：下一页的页码"></a>nextPage：下一页的页码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;!--设置分页插件--&gt;</span><br><span class="line">&lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>

<h4 id="isFirstPage-isLastPage：是否为第一页-最后一页"><a href="#isFirstPage-isLastPage：是否为第一页-最后一页" class="headerlink" title="isFirstPage&#x2F;isLastPage：是否为第一页&#x2F;最后一页"></a>isFirstPage&#x2F;isLastPage：是否为第一页&#x2F;最后一页</h4><h4 id="hasPreviousPage-hasNextPage：是否存在上一页-下一页"><a href="#hasPreviousPage-hasNextPage：是否存在上一页-下一页" class="headerlink" title="hasPreviousPage&#x2F;hasNextPage：是否存在上一页&#x2F;下一页"></a>hasPreviousPage&#x2F;hasNextPage：是否存在上一页&#x2F;下一页</h4><h4 id="navigatePages：导航分页的页码数-1"><a href="#navigatePages：导航分页的页码数-1" class="headerlink" title="navigatePages：导航分页的页码数"></a>navigatePages：导航分页的页码数</h4><h4 id="navigatepageNums：导航分页的页码，-1-2-3-4-5"><a href="#navigatepageNums：导航分页的页码，-1-2-3-4-5" class="headerlink" title="navigatepageNums：导航分页的页码，[1,2,3,4,5]"></a>navigatepageNums：导航分页的页码，[1,2,3,4,5]</h4>]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题</title>
    <url>/2024/06/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="一、CSS"><a href="#一、CSS" class="headerlink" title="一、CSS"></a>一、CSS</h3><h4 id="1-说一下CSS的盒模型。"><a href="#1-说一下CSS的盒模型。" class="headerlink" title="1.说一下CSS的盒模型。"></a>1.说一下CSS的盒模型。</h4><p>盒模型的属性：</p>
<p><em>width、height、padding、border、margin</em></p>
<p>​        在HTML页面中的所有元素都可以看成是一个盒子<br>​        盒子的组成：内容content、内边距padding、边框border、外边距margin<br>​        盒模型的类型：<br>​            标准盒模型<br>​                margin + border + padding + content<br>​            IE盒模型<br>​                margin + content(border + padding)<br>​        控制盒模型的模式：box-sizing:content-box（默认值，标准盒模型）、border-box（IE盒模型）;</p>
<h4 id="2-CSS选择器的优先级？"><a href="#2-CSS选择器的优先级？" class="headerlink" title="2.CSS选择器的优先级？"></a>2.CSS选择器的优先级？</h4><p>​        CSS的特性：继承性、层叠性、优先级<br>​        优先级：写CSS样式的时候，会给同一个元素添加多个样式，此时谁的权重高就显示谁的样式<br>​        标签、类&#x2F;伪类&#x2F;属性、全局选择器、行内样式、id、!important<br>​        !important &gt; 行内样式 &gt; id &gt; 类&#x2F;伪类&#x2F;属性 &gt; 标签 &gt; 全局选择器</p>
<h4 id="3-隐藏元素的方法有哪些，特点是？"><a href="#3-隐藏元素的方法有哪些，特点是？" class="headerlink" title="3.隐藏元素的方法有哪些，特点是？"></a>3.隐藏元素的方法有哪些，特点是？</h4><ol>
<li>display:none;元素在页面上消失，不占据空间</li>
<li>opacity:0;​设置了元素的透明度为0，元素不可见，占据空间位置</li>
<li>visibility:hidden;让元素消失，占据空间位置，一种不可见的状态</li>
<li>利用缩放：transform: scale(0);</li>
<li>利用定位：position:absolute;</li>
<li>clip-path</li>
</ol>
<h4 id="4-px和rem的区别是什么？"><a href="#4-px和rem的区别是什么？" class="headerlink" title="4.px和rem的区别是什么？"></a>4.px和rem的区别是什么？</h4><p>​        px是像素，显示器上给我们呈现画面的像素，每个像素的大小是一样，绝对单位长度<br>​        rem，相对单位，相对于html根节点的font-size的值，直接给html节点的font-size:62.5%;<br>​            1rem &#x3D; 10px; （16px*62.5%&#x3D;10px）</p>
<h4 id="5-重绘重排有什么区别？"><a href="#5-重绘重排有什么区别？" class="headerlink" title="5.重绘重排有什么区别？"></a>5.重绘重排有什么区别？</h4><p>​        重排（回流）：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小<br>​        重绘：计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制<br>​        浏览器的渲染机制<br>​        对DOM的大小、位置进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排<br>​        对DOM的样式进行修改，比如color和background-color，浏览器不需要重新计算几何属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘</p>
<h4 id="6-让一个元素水平垂直居中的方式有哪些？"><a href="#6-让一个元素水平垂直居中的方式有哪些？" class="headerlink" title="6.让一个元素水平垂直居中的方式有哪些？"></a>6.让一个元素水平垂直居中的方式有哪些？</h4><p>​        1.定位+margin<br>​        2.定位+transform<br>​        3.flex布局<br>​        4.grid布局<br>​        5.table布局</p>
<h4 id="7-CSS的哪些属性哪些可以继承？哪些不可以继承？"><a href="#7-CSS的哪些属性哪些可以继承？哪些不可以继承？" class="headerlink" title="7.CSS的哪些属性哪些可以继承？哪些不可以继承？"></a>7.CSS的哪些属性哪些可以继承？哪些不可以继承？</h4><p>​        CSS的三大特性：继承、层叠、优先级<br>​        子元素可以继承父类元素的样式<br>​        1.字体的一些属性：font<br>​        2.文本的一些属性：line-height<br>​        3.元素的可见性：visibility:hidden<br>​        4.表格布局的属性：border-spacing<br>​        5.列表的属性：list-style<br>​        6.页面样式属性：page<br>​        7.声音的样式属性</p>
<h4 id="8-有没有用过预处理器？"><a href="#8-有没有用过预处理器？" class="headerlink" title="8.有没有用过预处理器？"></a>8.有没有用过预处理器？</h4><p>​        预处理语言增加了变量、函数、混入等强大的功能<br>​        SASS  LESS</p>
<h4 id="9-如何画一条0-5px线"><a href="#9-如何画一条0-5px线" class="headerlink" title="9. 如何画一条0.5px线"></a>9. 如何画一条0.5px线</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.line&#123;</span><br><span class="line">	border-top:1px solid black;</span><br><span class="line">	transform:scaleY(0.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-定位"><a href="#10-定位" class="headerlink" title="10.定位"></a>10.定位</h4><ol>
<li><p>相对定位，相对于元素原来的位置，不会脱离文档流。</p>
</li>
<li><p>绝对定位，参考它的包含块，脱离文档流。配合相对定位使用。</p>
</li>
<li><p>固定定位，参考它的视口，脱离文档流。</p>
</li>
<li><p>粘性定位，参考离它最近的一个拥有“滚动机制”的祖先元素，不会脱离文档流。</p>
</li>
</ol>
<h4 id="11-消除浮动"><a href="#11-消除浮动" class="headerlink" title="11.消除浮动"></a>11.消除浮动</h4><ol>
<li><p><code>clear:both</code> clear属性指定元素两侧不能出现浮动元素,添加一个空的块级元素，给其<code>clear:both</code>属性。</p>
</li>
<li><p>将父元素设置为flex布局。</p>
</li>
<li><p>父元素设置<code>overflow:hidden/auto/scoll</code>。</p>
</li>
<li><p>将父元素也设置为浮动。</p>
</li>
<li><p>添加伪元素 ，在父元素内的最后添加一个伪元素。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.clearfix::after&#123;</span><br><span class="line"> content:&#x27;&#x27;;</span><br><span class="line"> display:block;</span><br><span class="line"> clear:both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;clearfix&quot;&gt;</span><br><span class="line"> &lt;div class=&quot;box1&quot;&gt;</span><br><span class="line"> ...</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>display:inline&#x2F;block&#x2F;inline-block:设置为行内&#x2F;内联，块级，行内块级元素</p>
</blockquote>
<h3 id="二、JavaScript"><a href="#二、JavaScript" class="headerlink" title="二、JavaScript"></a>二、JavaScript</h3><h4 id="1-JS由哪三部分组成？"><a href="#1-JS由哪三部分组成？" class="headerlink" title="1.JS由哪三部分组成？"></a>1.JS由哪三部分组成？</h4><ol>
<li>ECMAScript：JS的核心内容，描述了语言的基础语法，比如var,for，数据类型（数组、字符串），</li>
<li>文档对象模型（DOM）：DOM把整个HTML页面规划为元素构成的文档</li>
<li>浏览器对象模型（BOM）：对浏览器窗口进行访问和操作</li>
</ol>
<h4 id="2-JS有哪些内置对象？"><a href="#2-JS有哪些内置对象？" class="headerlink" title="2.JS有哪些内置对象？"></a>2.JS有哪些内置对象？</h4><pre><code>String Boolean Number Array Object Function Math Date RegExp...
Math
    abs() sqrt() max() min()
Data
    new Data() getYear() 
Array
String
    concat() length  slice() split()
</code></pre>
<h4 id="3-操作数组的方法有哪些？"><a href="#3-操作数组的方法有哪些？" class="headerlink" title="3.操作数组的方法有哪些？"></a>3.操作数组的方法有哪些？</h4><pre><code>push() pop() sort() splice() unshift() shift() reverse() concat() join() map() filter()
ervery() some() reduce() isArray() findIndex()
哪些方法会改变原数组？
    push() pop() unshift() shift() sort() reverse() splice()
</code></pre>
<h4 id="4-JS对数据类的检测方式有哪些？"><a href="#4-JS对数据类的检测方式有哪些？" class="headerlink" title="4.JS对数据类的检测方式有哪些？"></a>4.JS对数据类的检测方式有哪些？</h4><pre><code>typeof()--基本数据类型
instanceof()--引用数据类型
constructor
Object.prototype.toString.call()
</code></pre>
<h4 id="5-说一下闭包，闭包有什么特点？"><a href="#5-说一下闭包，闭包有什么特点？" class="headerlink" title="5.说一下闭包，闭包有什么特点？"></a>5.说一下闭包，闭包有什么特点？</h4><pre><code>什么是闭包？函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包。
特点：可以重复利用变量，并且这个变量不会污染全局的一种机制；这个变量是一直保存再内存中，不会被垃圾回收机制回收
缺点：闭包较多的时候，会消耗内存，导致页面的性能下降，在IE浏览器中才会导致内存泄漏
使用场景：防抖，节流，函数嵌套函数避免全局污染的时候
</code></pre>
<h4 id="6-前端的内存泄漏怎么理解？"><a href="#6-前端的内存泄漏怎么理解？" class="headerlink" title="6.前端的内存泄漏怎么理解？"></a>6.前端的内存泄漏怎么理解？</h4><pre><code>JS里已经分配内存地址的对象，但是由于长时间没有释放或者没办法清除，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。
垃圾回收机制
因素：一些为生命直接赋值的变量；一些未清空的定时器；过度的闭包；一些引用元素没有被清除。
</code></pre>
<h4 id="7-事件委托是什么？"><a href="#7-事件委托是什么？" class="headerlink" title="7.事件委托是什么？"></a>7.事件委托是什么？</h4><pre><code>又叫事件代理，原理就是利用了事件冒泡的机制来实现，也就是说把子元素的事件绑定到了父元素的身上
如果子元素阻止了事件冒泡，那么委托也就不成立
组织事件冒泡：event.stopPropagation()
addEventListener(&#39;click&#39;,函数名，true/false) 默认是false（事件冒泡），true（事件捕获）
好处：提高性能，减少事件的绑定，也就减少了内存的占用。
</code></pre>
<h4 id="8-基本数据类型和引用数据类型的区别？"><a href="#8-基本数据类型和引用数据类型的区别？" class="headerlink" title="8.基本数据类型和引用数据类型的区别？"></a>8.基本数据类型和引用数据类型的区别？</h4><pre><code>基本数据类型：String Number Boolean undefined null Symbol
    基本数据类型保存在栈内存当中，保存的就是一个具体的值
引用数据类型（复杂数据类型）：Object Function Array
    保存在堆内存当中，声明一个引用类型的变量，它保存的是引用类型数据的地址
    假如声明两个引用类型同时指向了一个地址的时候，修改其中一个那么另外一个也会改变
</code></pre>
<h4 id="9-说一下原型链。"><a href="#9-说一下原型链。" class="headerlink" title="9.说一下原型链。"></a>9.说一下原型链。</h4><pre><code>原型就是一个普通对象，它是为构造函数的实例共享属性和方法；所有实例中引用的原型都是同一个对象
使用prototype可以把方法挂在原型上，内存值保存一份
__proto__可以理解为指针，实例对象中的属性，指向了构造函数的原型（prototype）
</code></pre>
<h4 id="10-new操作符具体做了什么？"><a href="#10-new操作符具体做了什么？" class="headerlink" title="10.new操作符具体做了什么？"></a>10.new操作符具体做了什么？</h4><pre><code>1.先创建一个空对象
2.把空对象和构造函数通过原型链进行链接
3.把构造函数的this绑定到新的空对象身上
4.根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要返回这个引用类型
</code></pre>
<h4 id="11-JS是如何实现继承的？"><a href="#11-JS是如何实现继承的？" class="headerlink" title="11.JS是如何实现继承的？"></a>11.JS是如何实现继承的？</h4><pre><code>1.原型链继承
2.借用构造函数继承
3.组合式继承
4.ES6的class类继承
</code></pre>
<h4 id="12-JS的设计原理是什么？"><a href="#12-JS的设计原理是什么？" class="headerlink" title="12.JS的设计原理是什么？"></a>12.JS的设计原理是什么？</h4><pre><code>JS引擎 运行上下文 调用栈 事件循环 回调
</code></pre>
<h4 id="13-JS中关于this指向的问题"><a href="#13-JS中关于this指向的问题" class="headerlink" title="13.JS中关于this指向的问题"></a>13.JS中关于this指向的问题</h4><pre><code>1. 全局对象中的this指向
指向的是window
2. 全局作用域或者普通函数中的this
指向全局window
3. this永远指向最后调用它的那个对象
在不是箭头函数的情况下
4. new 关键词改变了this的指向
5. apply,call,bind
可以改变this指向，不是箭头函数
6. 箭头函数中的this
它的指向在定义的时候就已经确定了
箭头函数它没有this,看外层是否有函数，有就是外层函数的this，没有就是window
7. 匿名函数中的this
永远指向了window,匿名函数的执行环境具有全局性，因此this指向window
</code></pre>
<h4 id="14-script标签里的async和defer有什么区别？"><a href="#14-script标签里的async和defer有什么区别？" class="headerlink" title="14.script标签里的async和defer有什么区别？"></a>14.script标签里的async和defer有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当没有async和defer这两个属性的时候，浏览器会立刻加载并执行指定的脚本</span><br><span class="line">有async</span><br><span class="line">加载和渲染后面元素的过程将和script的加载和执行并行进行（异步）</span><br><span class="line">有defer</span><br><span class="line">加载和渲染后面元素的过程将和script的加载并行进行（异步），但是它的执行事件要等所有元素解析完成之后才会执行</span><br></pre></td></tr></table></figure>

<h4 id="15-setTimeout最小执行时间是多少？"><a href="#15-setTimeout最小执行时间是多少？" class="headerlink" title="15.setTimeout最小执行时间是多少？"></a>15.setTimeout最小执行时间是多少？</h4><p>HTML5规定的内容：</p>
<ul>
<li>setTimeout最小执行时间是4ms</li>
<li>setInterval最小执行时间是10ms</li>
</ul>
<h4 id="16-ES6和ES5有什么区别？"><a href="#16-ES6和ES5有什么区别？" class="headerlink" title="16.ES6和ES5有什么区别？"></a>16.ES6和ES5有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JS的组成：ECMAScript BOM  DOM</span><br><span class="line">ES5:ECMAScript5,2009年ECMAScript的第五次修订，ECMAScript2009</span><br><span class="line">ES6:ECMAScript6,2015年ECMAScript的第六次修订，ECMAScript2015，是JS的下一个版本标准</span><br></pre></td></tr></table></figure>

<h4 id="17-ES6的新特性有哪些？"><a href="#17-ES6的新特性有哪些？" class="headerlink" title="17.ES6的新特性有哪些？"></a>17.ES6的新特性有哪些？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.  新增块级作用域（let,const）</span><br><span class="line">   不存在变量提升</span><br><span class="line">   存在暂时性死区的问题</span><br><span class="line">   块级作用域的内容</span><br><span class="line">   不能在同一个作用域内重复声明</span><br><span class="line">2.  新增了定义类的语法糖（class）</span><br><span class="line">3.  新增了一种基本数据类型（symbol）</span><br><span class="line">4.  新增了解构赋值</span><br><span class="line">   从数组或者对象中取值，然后给变量赋值</span><br><span class="line">5.  新增了函数参数的默认值</span><br><span class="line">6.  给数组新增了API</span><br><span class="line">7.  对象和数组新增了扩展运算符</span><br><span class="line">8.  Promise</span><br><span class="line">   解决回调地狱的问题。</span><br><span class="line">   自身有all,reject,resolve,race方法</span><br><span class="line">   原型上有then,catch</span><br><span class="line">   把异步操作队列化</span><br><span class="line">   三种状态：pending初始状态,fulfilled操作成功,rejected操作失败</span><br><span class="line">   状态：pending -&gt; fulfilled;pending -&gt; rejected 一旦发生，状态就会凝固，不会再变</span><br><span class="line">   async  await</span><br><span class="line">   同步代码做异步的操作，两者必须搭配使用</span><br><span class="line">   async表明函数内有异步操作，调用函数会返回promise</span><br><span class="line">   await是组成async的表达式，结果是取决于它等待的内容，如果是promise那就是promise的结果，如果是普通函数就进行链式调用</span><br><span class="line">   await后的promise如果是reject状态，那么整个async函数都会中断，后面的代码不执行</span><br><span class="line"></span><br><span class="line">9.  新增了模块化（import,export）</span><br><span class="line">10.  新增了set和map数据结构</span><br><span class="line">    set就是不重复</span><br><span class="line">    map的key的类型不受限制</span><br><span class="line">11.  新增了generator</span><br><span class="line">12.  新增了箭头函数</span><br><span class="line">    不能作为构造函数使用，不能用new</span><br><span class="line">    箭头函数就没有原型</span><br><span class="line">    箭头函数没有arguments</span><br><span class="line">    箭头函数不能用call,apply,bind去改变this的执行</span><br><span class="line">    this指向外层第一个函数的this</span><br></pre></td></tr></table></figure>

<h4 id="18-call-aply-bind三者有什么区别？"><a href="#18-call-aply-bind三者有什么区别？" class="headerlink" title="18.call,aply,bind三者有什么区别？"></a>18.call,aply,bind三者有什么区别？</h4><p>都是改变this指向和函数的调用，call和apply的功能类似，只是传参的方法不同<br>call方法传的是一个参数列表<br>apply传递的是一个数组<br>bind传参后不会立刻执行，会返回一个改变了this指向的函数，这个函数还是可以传参的，bind()()<br>call方法的性能要比apply好一些，所以call用的更多一点</p>
<h4 id="19-用递归的时候有没有遇到什么问题？"><a href="#19-用递归的时候有没有遇到什么问题？" class="headerlink" title="19.用递归的时候有没有遇到什么问题？"></a>19.用递归的时候有没有遇到什么问题？</h4><p>如果一个函数内可以调用函数本身，那么这个就是递归函数<br>函数内部调用自己<br>特别注意：写递归必须要有<strong>退出条件</strong>return</p>
<h4 id="20-如何实现一个深拷贝？"><a href="#20-如何实现一个深拷贝？" class="headerlink" title="20.如何实现一个深拷贝？"></a>20.如何实现一个深拷贝？</h4><p>深拷贝就是完全拷贝一份新的对象，会在堆内存中开辟新的空间，拷贝的对象被修改后，原对象不受影响<br>主要针对的是引用数据类型</p>
<ol>
<li>lodash的_.deepClone实现</li>
<li>JSON.parse(JSON.stringify())</li>
<li>利用递归函数实现</li>
</ol>
<h4 id="21-说一下事件循环。"><a href="#21-说一下事件循环。" class="headerlink" title="21.说一下事件循环。"></a>21.说一下事件循环。</h4><p>JS是一个单线程的脚本语言<br>主线程 执行栈 任务队列  宏任务 微任务<br>主线程先执行同步任务，然后才去执行任务队列里的任务，如果在执行宏任务之前有微任务，那么要先执行微任务<br>全部执行完之后等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环！</p>
<p>主线程同步任务&gt;任务队列(异步)&gt;微任务&gt;宏任务</p>
<h4 id="22-ajax是什么？怎么实现的？"><a href="#22-ajax是什么？怎么实现的？" class="headerlink" title="22.ajax是什么？怎么实现的？"></a>22.ajax是什么？怎么实现的？</h4><p>创建<strong>交互式网页应用的网页开发技术</strong><br>    在不重新加载整个网页的前提下，与服务器交换数据并更新部分内容<br>通过XmlHttpRequest对象向服务器发送异步请求，然后从服务器拿到数据，最后通过JS操作DOM更新页面<br>1.创建XmlHttpRequest对象 xhr<br>2.通过xhr对象里的open()方法和服务器建立连接<br>3.构建请求所需的数据，并通过xhr对象的send()发送给服务器<br>4.通过xhr对象的onreadystate changes事件监听服务器和你的通信状态<br>5.接收并处理服务器响应的数据结果<br>6.把处理的数据更新到HTML页面上</p>
<h4 id="23-get和post有什么区别？"><a href="#23-get和post有什么区别？" class="headerlink" title="23.get和post有什么区别？***"></a>23.get和post有什么区别？***</h4><p>1.get一般是获取数据，post一般是提交数据<br>2.get参数会放在url&#x2F;query上，post是放在body中<br>3.get请求刷新服务器或退回是没有影响的，post请求退回时会重新提交数据<br>4.<strong>get请求时会被缓存,post请求不会被缓存</strong><br>5.get请求会被保存在浏览器历史记录中,post不会<br>6.get请求只能进行url编码，post请求支持多种编码方式（json，xml，form-data表单数据）</p>
<blockquote>
<p>第一次发送请求头响应100，再次响应返回200，成功</p>
<p>先发起一个OPTIONS请求，然后再发送实际的 POST 请求。</p>
</blockquote>
<h4 id="24-promise的内部原理是什么？它的优缺点是什么？"><a href="#24-promise的内部原理是什么？它的优缺点是什么？" class="headerlink" title="24. promise的内部原理是什么？它的优缺点是什么？"></a>24. promise的内部原理是什么？它的优缺点是什么？</h4><p>Promise对象，封装了一个异步操作并且还可以获取成功或失败的结果<br>Promise主要就是解决<strong>回调地狱</strong>的问题，之前如果异步任务比较多，同时他们之间有相互依赖的关系，就只能使用回调函数处理，这样就容易形成回调地狱，代码的可读性差，可维护性也很差<br>有三种状态：pending初始状态  fulfilled成功状态  rejected失败状态<br>状态改变只会有两种情况，<br>    pending -&gt; fulfilled; pending -&gt; rejected 一旦发生，状态就会凝固，不会再变<br>首先就是我们无法取消promise，一旦创建它就会立即执行，不能中途取消<br>如果不设置回调，promise内部抛出的测u哦呜就无法反馈到外面<br>若当前处于pending状态时，无法得知目前在哪个阶段。<br>原理：<br>    构造一个Promise实例，实例需要传递函数的参数，这个函数有两个形参，分别都是函数类型，一个是<strong>resolve</strong>一个是<strong>reject</strong><br>    promise上还有then方法，这个方法就是来指定状态改变时的确定操作，resolve是执行第一个函数，reject是执行第二个函数</p>
<h4 id="25-promise和async-await的区别是什么？"><a href="#25-promise和async-await的区别是什么？" class="headerlink" title="25.promise和async await的区别是什么？"></a>25.promise和async await的区别是什么？</h4><p>1.都是处理异步请求的方式<br>2.promise是ES6，async await 是ES7的语法<br>3.async await是基于promise实现的，他和promise都是<strong>非阻塞性</strong>的<br>优缺点：<br>1.promise是返回对象我们要用then，catch方法去处理和捕获异常，并且书写方式是链式，容易造成代码重叠，不好维护，async await 是通过try catch进行捕获异常<br>2.async await最大的优点就是能让代码看起来像同步一样，只要遇到await就会立刻返回结果，然后再执行后面的操作<br>promise.then()的方式返回，会出现请求还没返回，就执行了后面的操作</p>
<h4 id="26-浏览器的存储方式有哪些？"><a href="#26-浏览器的存储方式有哪些？" class="headerlink" title="26.浏览器的存储方式有哪些？"></a>26.浏览器的存储方式有哪些？</h4><p>1.cookies<br>    H5标准前的本地存储方式<br>    兼容性好，请求头自带cookie<br>    存储量小，资源浪费，使用麻烦（封装）<br>2.localstorage<br>    H5加入的以键值对为标准的方式<br>    操作方便，永久存储，兼容性较好<br>    保存值的类型被限定，浏览器在隐私模式下不可读取，不能被爬虫<br>3.sessionstorage<br>    当前页面关闭后就会立刻清理，会话级别的存储方式<br>4.indexedDB<br>    H5标准的存储方式，他是以键值对进行存储，可以快速读取，适合WEB场景</p>
<h4 id="27-token存在sessionstorage还是loaclstorage？"><a href="#27-token存在sessionstorage还是loaclstorage？" class="headerlink" title="27.token存在sessionstorage还是loaclstorage？"></a>27.token存在sessionstorage还是loaclstorage？</h4><p>token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串<br>1.存loaclstorage里，后期每次请求接口都需要把它当作一个字段传给后台<br>2.存cookie中，会自动发送，缺点就是不能跨域<br>如果存在localstorage中，容易被XSS攻击，但是如果做好了对应的措施，那么是利大于弊<br>如果存在cookie中会有CSRF攻击</p>
<h4 id="28-token的登录流程。"><a href="#28-token的登录流程。" class="headerlink" title="28.token的登录流程。"></a>28.token的登录流程。</h4><p>1.客户端用账号密码请求登录<br>2.服务端收到请求后，需要去验证账号密码<br>3.验证成功之后，服务端会签发一个token，把这个token发送给客户端<br>4.客户端收到token后保存起来，可以放在cookie也可以是localstorage<br>5.客户端每次向服务端发送请求资源的时候，都需要携带这个token<br>6.服务端收到请求，接着去验证客户端里的token，验证成功才会返回客户端请求的数据</p>
<h4 id="29-页面渲染的过程是怎样的？"><a href="#29-页面渲染的过程是怎样的？" class="headerlink" title="29.页面渲染的过程是怎样的？"></a>29.页面渲染的过程是怎样的？</h4><p>DNS解析<br>建立TCP连接<br>发送HTTP请求<br>服务器处理请求<br>渲染页面<br>    浏览器会获取HTML和CSS的资源，然后把HTML解析成DOM树<br>    再把CSS解析成CSSOM<br>    把DOM和CSSOM合并为渲染树<br>    布局<br>    把渲染树的每个节点渲染到屏幕上（绘制）<br>断开TCP连接</p>
<h4 id="30-DOM树和渲染树有什么区别？"><a href="#30-DOM树和渲染树有什么区别？" class="headerlink" title="30.DOM树和渲染树有什么区别？"></a>30.DOM树和渲染树有什么区别？</h4><p>DOM树是和HTML标签一一对应的，包括head和隐藏元素<br>渲染树是不包含head和隐藏元素</p>
<h4 id="31-精灵图和base64的区别是什么？"><a href="#31-精灵图和base64的区别是什么？" class="headerlink" title="31.精灵图和base64的区别是什么？"></a>31.精灵图和base64的区别是什么？</h4><p>精灵图：把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，当访问页面可以减少请求，提高加载速度<br>base64：传输8Bit字节代码的编码方式，把原本二进制形式转为64个字符的单位，最后组成字符串<br>base64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，但是一些低版本不支持，若base64体积比原图片大，不利于css的加载。</p>
<h4 id="32-svg格式了解多少？"><a href="#32-svg格式了解多少？" class="headerlink" title="32.svg格式了解多少？"></a>32.svg格式了解多少？</h4><p>可缩放矢量图，基于<strong>XML语法格式</strong>的图像格式，其他图像是基于像素的，SVG是属于对图像形状的描述，本质是文本文件，体积小，并且不管放大多少倍都不会失真<br>1.SVG可直接插入页面中，成为DOM一部分，然后用JS或CSS进行操作</p>
<pre><code>    &lt;svg&gt;&lt;/svg&gt;
</code></pre>
<p>​    2.SVG可作为文件被引入<br>​        <img src="F:/BaiduNetdiskDownload/pic.svg" /><br>​    3.SVG可以转为base64引入页面</p>
<h4 id="33-了解过JWT吗？"><a href="#33-了解过JWT吗？" class="headerlink" title="33.了解过JWT吗？"></a>33.了解过JWT吗？</h4><p>​    JSON Web Token 通过JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输<br>​    信息传输、授权<br>​    JWT的认证流程<br>​    1.前端把账号密码发送给后端的接口<br>​    2.后端核对账号密码成功后，把用户id等其他信息作为JWT 负载，把它和头部分别进行base64编码拼接后签名，形成一个JWT（token）。<br>​    3.前端每日请求时都会把JWT放在HTTP请求头的Authorization字段内<br>​    4.后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期）<br>​    5.验证通过后后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果<br>​    简洁、包含性、因为Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何web形式都支持。</p>
<h4 id="34-npm的底层环境是什么？"><a href="#34-npm的底层环境是什么？" class="headerlink" title="34.npm的底层环境是什么？"></a>34.npm的底层环境是什么？</h4><p>​    node package manager,node的包管理和分发工具，已经成为分发node模块的标准，是JS的运行环境<br>​    npm的组成：网站、注册表、命令行工具</p>
<h4 id="35-HTTP协议规定的协议头和请求头有什么？"><a href="#35-HTTP协议规定的协议头和请求头有什么？" class="headerlink" title="35.HTTP协议规定的协议头和请求头有什么？"></a>35.HTTP协议规定的协议头和请求头有什么？</h4><p>​    1.请求头信息：<br>​        Accept:浏览器告诉服务器所支持的数据类型<br>​        Host:浏览器告诉服务器我想访问服务器的哪台主机<br>​        Referer:浏览器告诉服务器我是从哪里来的（防盗链）<br>​        User-Agent:浏览器类型、版本信息<br>​        Date:浏览器告诉服务器我是什么时候访问的<br>​        Connection:连接方式<br>​        Cookie<br>​        X-Request-With:请求方式<br>​    2.响应头信息：<br>​        Location:这个就是告诉浏览器你要去找谁<br>​        Server:告诉浏览器服务器的类型<br>​        Content-Type:告诉浏览器返回的数据类型<br>​        Refresh:控制了的定时刷新</p>
<h4 id="36-说一下浏览器的缓存策略。"><a href="#36-说一下浏览器的缓存策略。" class="headerlink" title="36.说一下浏览器的缓存策略。"></a>36.说一下浏览器的缓存策略。</h4><p>​    强缓存（本地缓存）、协商缓存（弱缓存）<br>​    强缓：不发起请求，直接使用缓存里的内容，浏览器把JS，CSS，image等存到内存中，下次用户访问直接从内存中取，提高性能<br>​    协缓：需要向后台发请求，通过判断来决定是否使用协商缓存，如果请求内容没有变化，则返回304，浏览器就用缓存里的内容<br>​    强缓存的触发：<br>​        HTTP1.0:时间戳响应标头<br>​        HTTP1.1:Cache-Control响应标头<br>​    协商缓存触发：<br>​        HTTP1.0:请求头：if-modified-since 响应头：last-modified<br>​        HTTP1.1:请求头：if-none-match 响应头：Etag</p>
<h4 id="37-说一下什么是“同源策略”？"><a href="#37-说一下什么是“同源策略”？" class="headerlink" title="37.说一下什么是“同源策略”？"></a>37.说一下什么是“同源策略”？</h4><p>​    http:&#x2F;&#x2F; www.  aaa.com:8080&#x2F;index&#x2F;vue.js<br>​    协议    子域名 主域名  端口号     资源<br>​    同源策略是浏览器的核心，如果没有这个策略就会遭受网络攻击<br>​    主要指的就是协议+域名+端口号三者一致，若其中一个不一样则不是同源，会产生跨域<br>​    三个允许跨域加载资源的标签：img  link  script<br>​    跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截了！<br>​    JSONP<br>​    CORS<br>​    websocket<br>​    反向代理</p>
<h4 id="38-防抖和节流是什么？"><a href="#38-防抖和节流是什么？" class="headerlink" title="38.防抖和节流是什么？"></a>38.防抖和节流是什么？</h4><p>​    都是应对页面中频繁触发事件的优化方案<br>​    防抖:避免事件重复触发<br>​    使用场景:1.频繁和服务端交互 2.输入框的自动保存事件<br>​    节流:把频繁触发的事件减少,每隔一段时间执行<br>​    使用场景:scroll事件</p>
<h4 id="39-解释一下什么是json？"><a href="#39-解释一下什么是json？" class="headerlink" title="39.解释一下什么是json？"></a>39.解释一下什么是json？</h4><p>​    JSON是一种纯字符串形式的数据，它本身不提供任何方法，适合在网络中进行传输<br>​    JSON数据存储在.json文件中，也可以把JSON数据以字符串的形式保存在数据库、Cookise中<br>​    JS提供了JSON.parse() JSON.stringify()<br>​    什么时候使用json：定义接口；序列化；生成token；配置文件package.json</p>
<h4 id="40-当数据没有请求过来的时候，该怎么做？"><a href="#40-当数据没有请求过来的时候，该怎么做？" class="headerlink" title="40.当数据没有请求过来的时候，该怎么做？"></a>40.当数据没有请求过来的时候，该怎么做？</h4><p>​    可以在渲染数据的地方给一些默认的值<br>​    if判断语句</p>
<h4 id="41-有没有做过无感登录？"><a href="#41-有没有做过无感登录？" class="headerlink" title="41.有没有做过无感登录？***"></a>41.有没有做过无感登录？***</h4><p>1.解决方案<br>        无感登录实际上就是无感刷新 token。</p>
<blockquote>
<p>1.在响应器中拦截，判断 token 返回过期后，调用刷新 token 的接口。</p>
<p>2.后端返回过期时间，前端判断 token 的过期时间，去调用刷新 token 的接口。</p>
<p>3.写一个定时器，定时刷新 token。</p>
<p>我们常用的第一种方法实现无感登录。</p>
</blockquote>
<p>2.实现流程<br>1.登录流程</p>
<pre><code>    用户输入用户名和密码进行登录。

    后端验证用户信息，如果验证通过，返回一个 token 和 refresh_token。
    前端将 token 和 refresh_token 保存在本地（例如 localStorage）。
</code></pre>
<p>2.拦截响应</p>
<pre><code>    在前端，我们可以在响应拦截器中处理返回的响应。
    如果返回的状态码为401（未授权），说明 token 已经过期。
</code></pre>
<p>3.刷新 token</p>
<pre><code>    使用本地保存的 refresh_token 来请求新的 token。
    请求时可以携带当前 token 的过期时间，以便后端可以更精确地控制新 token 的过期时间。
</code></pre>
<p>4.替换 token</p>
<pre><code>    一旦新的 token 返回，前端将其保存，并替换本地旧的 token。
</code></pre>
<p>5.处理请求</p>
<pre><code>    前端将新的 token 放入未完成的请求中，并重新发送请求。
</code></pre>
<p>6.错误处理</p>
<pre><code>    如果 refresh_token 也过期了，那么需要重新登录。清除所有过期的 token，然后重新执行登录流程。
</code></pre>
<p>​    <strong>三种方法：</strong></p>
<ol>
<li><p>在响应器中拦截到401，判断token返回过期后，调用刷新token的接口</p>
</li>
<li><p>后端返回过期时间，前端判断token的过期时间，去调用刷新token的接口</p>
</li>
<li><p>前端写定时器，定时刷新token接口</p>
<p>方法1流程：</p>
<ol>
<li>登录成功后保存token 和 refresh_token</li>
<li>在响应拦截器中对401状态码引入刷新token的api方法调用</li>
<li>替换保存本地新的token</li>
<li>把错误对象里的token替换</li>
<li>再次发送未完成的请求</li>
<li>如果refresh_token过期了，判断是否过期，过期了就清除所有token重新登录</li>
</ol>
</li>
</ol>
<h4 id="42-大文件上传是怎么做的？"><a href="#42-大文件上传是怎么做的？" class="headerlink" title="42.大文件上传是怎么做的？"></a>42.大文件上传是怎么做的？</h4><p>​    分片上传：<br>​        1.把需要上传的文件按照一定的规则，分割成相同大小的数据块<br>​        2.初始化一个分片上传任务，返回本次分片上传的唯一标识<br>​        3.按照一定的规则把各个数据块上传<br>​        4.发送完成后，服务端会判断数据上传的完整性，如果完整，那么就会把数据库合并成原始文件<br>​    断点续传：<br>​        服务端返回，从哪里开始  浏览器自己处理</p>
<h4 id="43-var-const-let区别"><a href="#43-var-const-let区别" class="headerlink" title="43.var const let区别"></a>43.var const let区别</h4><ol>
<li>const let 是块级作用域，var没有块级作用域，var只有函数和全局作用域</li>
<li>var存在变量提升，const和let不存在变量声明提升。变量声明提升：变量提升是将变量声明提升到它所在作用域的最开始的部分，先调用再声明定义。</li>
<li>const let是ES6提出的，var是ES5</li>
<li>const 声明的是常量，常量不能被修改，let和var声明的是变量，可以被修改</li>
<li>const在声明时必须赋值，而let和var不需要</li>
<li>let 和const不能重复声明同一个值:如 let a&#x3D;1 ; let a &#x3D;2 这样是不被允许的，但var可以，最后一个var声明的值会覆盖之前的 如：var b &#x3D;1 ;var b &#x3D;2 console.log(b)  结果为2</li>
</ol>
<h4 id="44-和-的区别"><a href="#44-和-的区别" class="headerlink" title="44.&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别"></a>44.&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</h4><ul>
<li><p>‘’&#x3D;&#x3D;’’：类型不同，会尝试进行类型转换，将它们转换为同一类型后再进行比较值。</p>
</li>
<li><p>‘’&#x3D;&#x3D;&#x3D;’’：比较类型和值是否完全相同</p>
</li>
</ul>
<h4 id="45-定时器"><a href="#45-定时器" class="headerlink" title="45.定时器"></a>45.定时器</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">setTimeOut</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line"></span><br><span class="line"> &#125;,i*<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：5 5 5 5</span></span><br></pre></td></tr></table></figure>

<h4 id="46-数组去重"><a href="#46-数组去重" class="headerlink" title="46.数组去重"></a>46.数组去重</h4><ol>
<li>用Set去重</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique (arr) &#123;</span><br><span class="line">  return Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">console.log(unique(arr))</span><br><span class="line">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>splice 去重</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr)&#123;            </span><br><span class="line">        for(var i=0; i&lt;arr.length; i++)&#123;</span><br><span class="line">            for(var j=i+1; j&lt;arr.length; j++)&#123;</span><br><span class="line">                if(arr[i]==arr[j])&#123;         //第一个等同于第二个，splice方法删除第二个</span><br><span class="line">                    arr.splice(j,1);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    console.log(unique(arr))</span><br><span class="line">    //[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //NaN和&#123;&#125;没有去重，两个null直接消失了</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>sort()</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#x27;type error!&#x27;)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    arr = arr.sort()</span><br><span class="line">    var arrry= [arr[0]];</span><br><span class="line">    for (var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] !== arr[i-1]) &#123;</span><br><span class="line">            arrry.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arrry;</span><br><span class="line">&#125;</span><br><span class="line">     var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">        console.log(unique(arr))</span><br><span class="line">// [0, 1, 15, &quot;NaN&quot;, NaN, NaN, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, false, null, true, &quot;true&quot;, undefined]      //NaN、&#123;&#125;没有去重</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>利用 filter</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">  return arr.filter(function(item, index, arr) &#123;</span><br><span class="line">    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素</span><br><span class="line">    return arr.indexOf(item, 0) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">console.log(unique(arr))</span><br><span class="line">//[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="三、HTML5CSS3"><a href="#三、HTML5CSS3" class="headerlink" title="三、HTML5CSS3"></a>三、HTML5CSS3</h3><h4 id="1-语义化的理解。"><a href="#1-语义化的理解。" class="headerlink" title="1.语义化的理解。"></a>1.语义化的理解。</h4><p>​        在写HTML页面结构时所用的标签有意义<br>​        头部用head  主体用main  底部用foot…<br>​        怎么判断页面是否语义化了？<br>​            把CSS去掉，如果能够清晰的看出来页面结构，显示内容较为正常<br>​        为什么要选择语义化？<br>​            1.让HTML结构更加清晰明了<br>​            2.方便团队协作，利于开发<br>​            3.有利于爬虫和SEO<br>​            4.能够让浏览器更好的去解析代码<br>​            5.给用户带来良好的体验</p>
<h4 id="2-H5C3有哪些新特性？"><a href="#2-H5C3有哪些新特性？" class="headerlink" title="2.H5C3有哪些新特性？"></a>2.H5C3有哪些新特性？</h4><p>​        H5的新特性：<br>​            1.语义化的标签<br>​            2.新增音频视频<br>​            3.画布canvas<br>​            4.数据存储localstorage sessionstorage<br>​            5.增加了表单控件 email url search…<br>​            6.拖拽释放API<br>​        CSS3的新特性：<br>​            1.新增选择器：属性选择器、伪类选择器、伪元素选择器<br>​            2.增加了媒体查询<br>​            3.文字阴影<br>​            4.边框<br>​            5.盒子模型box-sizing<br>​            6.渐变<br>​            7.过度<br>​            8.自定义动画<br>​            9.背景的属性<br>​            10.2D和3D</p>
<h4 id="3-rem是如何做适配的？"><a href="#3-rem是如何做适配的？" class="headerlink" title="3.rem是如何做适配的？"></a>3.rem是如何做适配的？</h4><p>​        rem是相对长度，相对于根元素（html）的font-size属性来计算大小，通常来做移动端的适配<br>​        rem是根据根元素font-size计算值的倍数<br>​        比如html上的font-size:16px，给div设置宽为1.5rem,1.2rem &#x3D; 16px*1.2 &#x3D; 19.2px.</p>
<h4 id="4-解决了哪些移动端的兼容问题？"><a href="#4-解决了哪些移动端的兼容问题？" class="headerlink" title="4.解决了哪些移动端的兼容问题？"></a>4.解决了哪些移动端的兼容问题？</h4><p>​        1.当设置样式overflow:scroll&#x2F;auto时，IOS上的滑动会卡顿<br>​            -webkit-overflow-scrolling:touch;<br>​        2.在安卓环境下placeholder文字设置行高时会偏上<br>​            input有placeholder属性的时候不要设置行高<br>​        3.移动端字体小于12px时异常显示<br>​            应该先把在整体放大一倍，然后再用transform进行缩小<br>​        4.ios下input按钮设置了disabled属性为true显示异常<br>​            input[typy&#x3D;button]{<br>​                opcity:1<br>​            }<br>​        5.安卓手机下取消语音输入按钮<br>​            input::-webkit-input-speech-button{<br>​                display:none<br>​            }<br>​        6.IOS下取消input输入框在输入引文首字母默认大写<br>​            <input autocapitalize='off' autocorrect='off'/><br>​        7.禁用IOS和安卓用户选中文字<br>​            添加全局CSS样式：-webkit-user-select:none<br>​        8.禁止IOS弹出各种窗口<br>​            -webkit-touch-callout:none<br>​        9.禁止IOS识别长串数字为电话<br>​            添加meta属性 <meta conten='telephone=no' name='format-detection'></p>
<h3 id="四、Vue"><a href="#四、Vue" class="headerlink" title="四、Vue"></a>四、Vue</h3><h4 id="1-v-if和v-show的区别？"><a href="#1-v-if和v-show的区别？" class="headerlink" title="1.v-if和v-show的区别？"></a>1.v-if和v-show的区别？</h4><p>​        都可以控制元素的显示和隐藏<br>​        1.控制手段：v-show时控制元素的display值来让元素显示和隐藏，DOM元素依旧还在；v-if显示隐藏时把DOM元素整个添加和删除；<br>​        2.编译过程：v-if有一个局部编译&#x2F;卸载的过程，切换这个过程中会适当的销毁和重建内部的事件监听和子组件；v-show只是简单的css切换；<br>​        3.编译条件：v-if才是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；v-show从false变成true的时候不会触发组件的生命周期，v-if会触发生命周期；<br>​        4.<code>v-if</code>有更高的切换消耗；<code>v-show</code>有更高的初始渲染消耗；</p>
<blockquote>
<p>如果需要在条件切换频繁的情况下，可以使用v-show来避免频繁的创建和销毁组件或元素，提高性能。</p>
<p>如果需要在条件切换较少的情况下，可以使用v-if来在条件为假时减少不必要的渲染，节省内存。</p>
</blockquote>
<h4 id="2-如何理解MVVM的？"><a href="#2-如何理解MVVM的？" class="headerlink" title="2.如何理解MVVM的？"></a>2.如何理解MVVM的？</h4><p>​        是Model-View-ViewModel的缩写。前端开发的架构模式<br>​        M：模型，对应的就是data的数据<br>​        V：视图，用户界面，DOM<br>​        VM：视图模型：Vue的实例对象，连接View和Model的桥梁<br>​        核心是提供对View和ViewModel的双向数据绑定，当数据改变的时候，ViewModel能监听到数据的变化，自动更新视图，当用户操作视图的时候，ViewModel也可以监听到视图的变化，然后通知数据进行改动，这就实现了双向数据绑定<br>​        ViewModel通过双向绑定把View和Model连接起来，他们之间的同步是自动的，不需要认为干涉，所以我们只需要关注业务逻辑即可，不需要操作DOM，同时也不需要关注数据的状态问题，因为她是由MVVM统一管理</p>
<h4 id="3-v-for中的key值的作用是什么？"><a href="#3-v-for中的key值的作用是什么？" class="headerlink" title="3.v-for中的key值的作用是什么？"></a>3.v-for中的key值的作用是什么？</h4><p>​        key属性是DOM元素的唯一标识<br>​        作用：<br>​            1.提高虚拟DOM的更新<br>​            2.若不设置key，可能会触发一些bug。key属性可以避免数据混乱的情况出现 （如果元素中包含了有临时数据的元素，如果不用key就会产生数据混乱）<br>​            3.为了触发过渡效果</p>
<h4 id="4-说一下你对vue生命周期的理解。"><a href="#4-说一下你对vue生命周期的理解。" class="headerlink" title="4.说一下你对vue生命周期的理解。"></a>4.说一下你对vue生命周期的理解。</h4><p>​        组件从创建到销毁的过程就是它的生命周期<br>​        <strong>创建</strong><br>​            beforeCreat<br>​                在这个阶段<strong>属性和方法</strong>都不能使用<br>​            created<br>​                这里时实例创建完成之后，在这里完成了数据监测，可以使用数据，修改数据，不会触发updated，也不会更新视图<br><strong>​        挂载</strong><br>​            beforeMount<br>​                完成了模板的编译，虚拟DOM也完成创建，即将渲染，修改数据，不会触发updated<br>​            Mounted<br>​                把编译好的模板挂载到页面，这里可以发送异步请求也可以访问DOM节点<br><strong>​        更新</strong><br>​            beforeUpdate<br>​                组件数据更新之前使用，数据是新的，页面上的数据时旧的，组件即将更新，准备渲染，可以改数据<br>​            updated<br>​                render重新做了渲染，这时数据和页面都是新的，避免在此更新数据<br>​        <strong>销毁</strong><br>​            beforeDestroy<br>​                实例销毁前，在这里实例还可以用，可以清楚定时器等等<br>​            destroyed<br>​                组件已经被销毁了，全部都销毁<br>​        使用了keep-alive时多出两个周期：<br>​            activited<br>​                组件激活时<br>​            deactivited<br>​                组件被销毁时</p>
<h4 id="5-在created和mounted去请求数据，有什么区别？"><a href="#5-在created和mounted去请求数据，有什么区别？" class="headerlink" title="5.在created和mounted去请求数据，有什么区别？"></a>5.在created和mounted去请求数据，有什么区别？</h4><p>​        created：在渲染前调用，通常先初始化属性，然后做渲染<br>​        mounted：在模板渲染完成后，一般都是初始化页面后，在对元素节点进行操作<br>​                在这里请求数据可能会出现闪屏的问题，created里不会<br>​        一般用created比较多<br>​        请求的数据对DOM有影响，那么使用created<br>​        如果请求的数据对DOM无关，可以放在mounted</p>
<h4 id="6-vue中的修饰符有哪些？"><a href="#6-vue中的修饰符有哪些？" class="headerlink" title="6.vue中的修饰符有哪些？"></a>6.vue中的修饰符有哪些？</h4><p>​        1.事件修饰符<br>​            .stop       组织冒泡<br>​            .prevent    组织默认行为<br>​            .capture    内部元素触发的事件先在次处理<br>​            .self       只有在event.target是当前元素时触发<br>​            .once       事件只会触发一次<br>​            .passive    立即触发默认行为<br>​            .native     把当前元素作为原生标签看待<br>​        2.按键修饰符<br>​            .keyup      键盘抬起<br>​            .keydown    键盘按下<br>​        3.系统修饰符<br>​            .ctrl<br>​            .alt<br>​            .meta<br>​        4.鼠标修饰符<br>​            .left       鼠标左键<br>​            .right      鼠标右键<br>​            .middle     鼠标中键<br>​        5.表单修饰符<br>​            .lazy       等输入完之后再显示<br>​            .trim       删除内容前后的空格<br>​            .number     输入是数字或转为数字</p>
<h4 id="7-elementui是怎么做表单验证的？"><a href="#7-elementui是怎么做表单验证的？" class="headerlink" title="7.elementui是怎么做表单验证的？"></a>7.elementui是怎么做表单验证的？</h4><p>​        1.在表单中加rules属性，然后再data里写校验规则<br>​        2.内部添加规则<br>​        3.自定义函数校验</p>
<h4 id="8-vue如何进行组件通信-组件传参？"><a href="#8-vue如何进行组件通信-组件传参？" class="headerlink" title="8.vue如何进行组件通信,组件传参？"></a>8.vue如何进行组件通信,组件传参？</h4><p>​        1.父传子<br>​            props<br>​                父组件使用自定义属性，然后子组件使用props<br>​            $ref<br>​                引用信息会注册在父组件的$refs对象上<br>​        2.子传父<br>​            $emit<br>​                子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数<br>​        3.兄弟传<br>​            new一个新的vue实例，用on和emit来对数据进行传输<br>​        4.vuex传值</p>
<h4 id="9-keep-alive是什么？怎么使用？"><a href="#9-keep-alive是什么？怎么使用？" class="headerlink" title="9.keep-alive是什么？怎么使用？"></a>9.keep-alive是什么？怎么使用？</h4><p>​        Vue的一个内置组件，包裹组件的时候，会缓存不活跃的组件实例，并不是销毁他们<br>​        作用：把组件切换的状态保存在内存里，防止重复渲染DOM节点，减少加载时间和性能消耗，提高用户体验</p>
<h4 id="10-axios是怎么做封装的？"><a href="#10-axios是怎么做封装的？" class="headerlink" title="10.axios是怎么做封装的？"></a>10.axios是怎么做封装的？</h4><p>​        下载 创建实例 接着封装请求响应拦截器  抛出 最后封装接口</p>
<h4 id="11-vue路由时怎么传参的？"><a href="#11-vue路由时怎么传参的？" class="headerlink" title="11.vue路由时怎么传参的？"></a>11.vue路由时怎么传参的？</h4><p>​        params传参<br>​            this.$router.push({name:’index’,params:{id:item.id}})<br>​            this.$route.params.id<br>​        路由属性传参<br>​            this.$router.push({name:’&#x2F;index&#x2F;${item.id}’})<br>​            路由配置 { path:’&#x2F;index:id’ }<br>​        query传参（可以解决页面刷新参数丢失的问题）<br>​            this.$router.push({<br>​                name:’index’,<br>​                query:{id:item.id}<br>​            })</p>
<h4 id="12-vue路由的hash模式和history模式有什么区别？"><a href="#12-vue路由的hash模式和history模式有什么区别？" class="headerlink" title="12.vue路由的hash模式和history模式有什么区别？***"></a>12.vue路由的hash模式和history模式有什么区别？***</h4><p>​        1.hash的路由地址上有#号，history模式没有<br>​        2.在做回车刷新的时候，hash模式会加载对应页面，history会报错404<br>​        3.hash模式支持低版本浏览器，history不支持，因为是H5新增的API<br>​        4.hash不会重新加载页面，单页面应用必备<br>​        5.history有历史记录，H5新增了pushState和replaceState()去修改历史记录，并不会立刻发送请求<br>​        6.history需要后台配置</p>
<h4 id="13-路由拦截是怎么实现的？"><a href="#13-路由拦截是怎么实现的？" class="headerlink" title="13.路由拦截是怎么实现的？"></a>13.路由拦截是怎么实现的？</h4><p>​        路由拦截 axios拦截<br>​        需要在路由配置中添加一个字段，它是用于判断路由是否需要拦截</p>
<pre><code>&#123;
            name:&#39;index&#39;,
            path:&#39;/index&#39;,
            component:Index,
            meta:&#123;
                requirtAuth:true
            &#125;
        &#125;
        router.beforeEach((to,from,next) =&gt; &#123;
            if(to.meta.requirtAuth)&#123;
                if( store.satte.token )&#123;
                    next()
                &#125;else&#123;
                    &#125;
    &#125;
&#125;)
</code></pre>
<h4 id="14-说一下vue的动态路由。"><a href="#14-说一下vue的动态路由。" class="headerlink" title="14.说一下vue的动态路由。"></a>14.说一下vue的动态路由。</h4><p>​    要在路由配置里设置meat属性，扩展权限相关的字段，在路由导航守卫里通过判断这个权限标识，实现路由的动态增加和跳转<br>​    根据用户登录的账号，返回用户角色<br>​    前端再根据角色，跟路由表的meta.role进行匹配<br>​    把匹配搭配的路由形成可访问的路由</p>
<h4 id="15-如何解决刷新后二次加载路由？"><a href="#15-如何解决刷新后二次加载路由？" class="headerlink" title="15.如何解决刷新后二次加载路由？"></a>15.如何解决刷新后二次加载路由？</h4><p>​    1.window.location.reload()<br>​    2.matcher<br>​        const router &#x3D; createRouter()<br>​        export function resetRouter(){<br>​            const newRouter &#x3D; creatRouter()<br>​            router.matcher &#x3D; newRouter.matcher<br>​        }</p>
<h4 id="16-vuex刷新数据会丢失吗？怎么解决？"><a href="#16-vuex刷新数据会丢失吗？怎么解决？" class="headerlink" title="16.vuex刷新数据会丢失吗？怎么解决？"></a>16.vuex刷新数据会丢失吗？怎么解决？</h4><p>​    vuex肯定会重新获取数据，页面也会丢失数据<br>​    1.把数据直接保存在浏览器缓存里（cookie  localstorage  sessionstorage）<br>​    2.页面刷新的时候，再次请求数据，达到可以动态更新的方法<br>​        监听浏览器的刷新书简，在刷新前把数据保存到sessionstorage里，刷新后请求数据，请求到了用vuex，如果没有那就用sessionstorage里的数据</p>
<h4 id="17-computed和watch的区别？"><a href="#17-computed和watch的区别？" class="headerlink" title="17.computed和watch的区别？"></a>17.computed和watch的区别？</h4><p>​    1.computed是计算属性，watch是监听，监听的是data中数据的变化<br>​    2.computed是支持缓存，依赖的属性值发生变化，计算属性才会重新计算，否则用缓存；watch不支持缓存<br>​    3.computed不支持异步，watch是可以异步操作<br>​    4.computed是第一次加载就监听，watch是不监听<br>​    5.computed函数中必须有return  watch不用</p>
<h4 id="18-vuex在什么场景会去使用？属性有哪些？"><a href="#18-vuex在什么场景会去使用？属性有哪些？" class="headerlink" title="18.vuex在什么场景会去使用？属性有哪些？"></a>18.vuex在什么场景会去使用？属性有哪些？</h4><p>​    state       存储变量<br>​    getters     state的计算属性<br>​    mutations   提交更新数据的方法<br>​    actions     和mutations差不多，他是提交mutations来修改数据，可以包括异步操作<br>​    modules     模块化vuex<br>​    使用场景：<br>​        用户的个人信息、购物车模块、订单模块</p>
<h4 id="19-vue的双向数据绑定原理是什么？"><a href="#19-vue的双向数据绑定原理是什么？" class="headerlink" title="19.vue的双向数据绑定原理是什么？"></a>19.vue的双向数据绑定原理是什么？</h4><p>​    通过数据劫持和发布订阅者模式来实现，同时利用Object.defineProperty()劫持各个属性的setter和getter，<br>​    在数据发生改变的时候发布消息给订阅者，触发对应的监听回调渲染视图，也就是说数据和视图时同步的，数据发生改变，视图跟着发生改变，视图改变，数据也会发生改变。<br>​    第一步：需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter<br>​    第二步：compile模板解析指令，把模板中的变量替换成数据，然后初始化渲染视图，同时把每个指令对应的节点绑定上更新函数，添加订阅者，如果数据变化，收到通知，更新视图<br>​    第三步：Watcher订阅者是Observer和Compile之间的通信桥梁，作用：<br>​            1.在自身实例化的时候忘订阅器内添加自己<br>​            2.自身要有一个update()方法<br>​            3.等待属性变动时，调用自身的update方法，触发compile这种的回调<br>​    第四步：MVVM作为数据绑定的入口，整合了observer、compile和watcher三者，通过observer来监听自己的数据变化，通过compile解析模板指令，最后利用watcher把observer和compile联系起来，最终达到数据更新视图更新，视图更新数据更新的效果</p>
<h4 id="20-了解diff算法和虚拟DOM吗？"><a href="#20-了解diff算法和虚拟DOM吗？" class="headerlink" title="20.了解diff算法和虚拟DOM吗？"></a>20.了解diff算法和虚拟DOM吗？</h4><p>​    虚拟DOM，描述元素和元素之间的关系，创建一个JS对象<br>​    如果组件内有响应的数据，数据发生改变的时候，render函数会生成一个新的虚拟DOM，这个新的虚拟DOM会和旧的虚拟DOM进行比对，找到需要修改的虚拟DOM内容，然后去对应的真实DOM中修改<br>​    diff算法就是虚拟DOM的比对时用的，返回一个patch对象，这个对象的作用就是存储两个节点不同的地方，最后用patch里记录的信息进行更新真实DOM<br>​    步骤：<br>​        1.JS对象表示真实的DOM结构，要生成一个虚拟DOM，再用虚拟DOM构建一个真实DOM树，渲染到页面<br>​        2.状态改变生成新的虚拟DOM，跟就得虚拟DOM进行比对，这个比对的过程就是DIFF算法，利用patch记录差异<br>​        3.把记录的差异用在第一个虚拟DOM生成的真实DOM上，视图就更新了。</p>
<h4 id="21-vue和jquery的区别是什么？"><a href="#21-vue和jquery的区别是什么？" class="headerlink" title="21.vue和jquery的区别是什么？"></a>21.vue和jquery的区别是什么？</h4><p>​    1.原理不同<br>​        vue就是数据绑定；jq是先获取dom再处理<br>​    2.着重点不同<br>​        vue是数据驱动，jq是着重于页面<br>​    3.操作不同<br>​    4.未来发展不同</p>
<h4 id="22-vuex的响应式处理。"><a href="#22-vuex的响应式处理。" class="headerlink" title="22.vuex的响应式处理。"></a>22.vuex的响应式处理。</h4><p>​    vuex是vue的状态管理工具<br>​    vue中可以直接触发methods中的方法，vuex是不可以的。未来处理异步，当触发事件的时候，会通过dispatch来访问actions中的方法，actions中的commit会触发mutations中的方法从而修改state里的值，通过getter把数据更新到视图<br>​    Vue.use(vuex)，调用install方法，通过applyMixin(vue)在任意组件内执行this.$store就可以访问到store对象。<br>​    vuex的state是响应式的，借助的就是vue的data，把state存到vue实例组件的data中</p>
<h4 id="23-vue中遍历全局的方法有哪些？"><a href="#23-vue中遍历全局的方法有哪些？" class="headerlink" title="23.vue中遍历全局的方法有哪些？"></a>23.vue中遍历全局的方法有哪些？</h4><p>​    1.普通遍历，对象.forEach()<br>​        arr.forEach(function(item,index,arr){<br>​            console.log(item,index)<br>​        })<br>​    2.对元素统一操作  对象.map()<br>​        var newarr &#x3D; arr.map(function(item){<br>​            return item+1<br>​        })<br>​    3.查找符合条件的元素 对象.filter()<br>​        arr.filter(function(item){<br>​            if(item &gt; 2){<br>​                return false<br>​            }else{<br>​                return true<br>​            }<br>​        })<br>​    4.查询符合条件的元素，返回索引 对象.findindex()<br>​        arr.finindex(function(item){<br>​            if(item&gt;1){<br>​                return true<br>​            }else{<br>​                return false<br>​            }<br>​        })<br>​    对象.evening()  遇到不符合的对象会停止<br>​    对象.some()  找到符合条件的元素就停止</p>
<h4 id="24-如何搭建脚手架？"><a href="#24-如何搭建脚手架？" class="headerlink" title="24.如何搭建脚手架？"></a>24.如何搭建脚手架？</h4><p>​    下载：node  cnpm  webpack vue-cli<br>​    创建项目：<br>​        1.找到对应的文件，然后利用node指令创建（cmd）<br>​        2.vue init webpack xxxx<br>​        3.回车项目描述<br>​        4.作者回车<br>​        5.选择vue build<br>​        6.回车<br>​        7.输入n<br>​        8.不按照yarn<br>​        9.输入npm run dev</p>
<h4 id="25-如何封装一个组件？"><a href="#25-如何封装一个组件？" class="headerlink" title="25.如何封装一个组件？"></a>25.如何封装一个组件？</h4><p>​    1.使用Vue.extend()创建一个组件<br>​    2.使用Vue.components()方法注册组件<br>​    3.如果子组件需要数据，可以在props中接收定义<br>​    4.子组件修改好数据，要把数据传递给父组件，可以用emit()方法<br>​    原则：<br>​        把功能拆开<br>​        尽量让组件原子化，一个组件做一件事情<br>​        容器组件管数据，展示组件管视图</p>
<h4 id="26-封装一个可复用的组件，需要满足什么条件？"><a href="#26-封装一个可复用的组件，需要满足什么条件？" class="headerlink" title="26.封装一个可复用的组件，需要满足什么条件？"></a>26.封装一个可复用的组件，需要满足什么条件？</h4><p>​    1.低耦合，组件之间的依赖越小越好<br>​    2.最好从父级传入信息，不要在公共组件中请求数据<br>​    3.传入的数据要进行校验<br>​    4.处理事件的方法写在父组件中</p>
<h4 id="27-vue的过滤器怎么使用？"><a href="#27-vue的过滤器怎么使用？" class="headerlink" title="27.vue的过滤器怎么使用？"></a>27.vue的过滤器怎么使用？</h4><p>​    vue的特性，用来对文本进行格式化处理<br>​    使用它的两个地方，一个是插值表达式，一个是v-bind<br>​    分类：<br>​        1.全局过滤器<br>​            Vue.filter(‘add’,function(v){<br>​                return v &lt; 10 ? ‘0’ + v : v<br>​            })</p>
<pre><code>        &lt;div&gt;&#123;&#123;33 | add&#125;&#125;&lt;/div&gt;
</code></pre>
<p>​        2.本地过滤器<br>​            和methods同级<br>​            filter:{<br>​                add:function(v){<br>​                    return v &lt; 10 ? ‘0’ + v : v<br>​                }<br>​            }</p>
<h4 id="28-vue中如何做强制刷新？"><a href="#28-vue中如何做强制刷新？" class="headerlink" title="28.vue中如何做强制刷新？"></a>28.vue中如何做强制刷新？</h4><p>​    1.localtion.reload()<br>​    2.this.$router.go(0)<br>​    3.provide和inject</p>
<h4 id="29-vue3和vue2有哪些区别？"><a href="#29-vue3和vue2有哪些区别？" class="headerlink" title="29.vue3和vue2有哪些区别？"></a>29.vue3和vue2有哪些区别？</h4><p>​    1.双向数据绑定的原理不同<br>​    2.是否支持碎片<br>​    3.API不同<br>​    4.定义数据变量方法不同<br>​    5.生命周期的不同<br>​    6.传值不同<br>​    7.指令和插槽不同<br>​    8.main.js不同</p>
<h4 id="30-vue的性能优化怎么做？"><a href="#30-vue的性能优化怎么做？" class="headerlink" title="30.vue的性能优化怎么做？"></a>30.vue的性能优化怎么做？</h4><p>​    1.编码优化</p>
<ul>
<li>不要把所有数据都放在data中</li>
<li>v-for时给每个元素绑定事件用事件代理</li>
<li>keep-alive缓存组件</li>
<li>尽可能拆分组件，提高复用性、维护性</li>
<li>key值要保证唯一</li>
<li>合理使用路由懒加载，异步组件</li>
<li>数据持久化存储的使用尽量用防抖、节流优化</li>
</ul>
<p>​    2.加载优化<br>​        按需加载<br>​        内容懒加载<br>​        图片懒加载<br>​    3.用户体验<br>​        骨架屏<br>​    4.SEO优化<br>​        预渲染<br>​        服务端渲染ssr<br>​    5.打包优化<br>​        CDN形式加载第三方模块<br>​        多线程打包<br>​        抽离公共文件<br>​    6.缓存和压缩<br>​        客户端缓存、服务端缓存<br>​        服务端Gzip压缩</p>
<h4 id="31-首屏优化该如何去做？"><a href="#31-首屏优化该如何去做？" class="headerlink" title="31.首屏优化该如何去做？"></a>31.首屏优化该如何去做？</h4><p>​    1.使用路由懒加载<br>​    2.非首屏组件使用异步组件<br>​    3.首屏不中要的组件延迟加载<br>​    4.静态资源放在CDN上<br>​    5.减少首屏上JS、CSS等资源文件的大小<br>​    6.使用服务端渲染<br>​    7.简历减少DOM的数量和层级<br>​    8.使用精灵图请求<br>​    9.做一些loading<br>​    10.开启Gzip压缩<br>​    11.图片懒加载</p>
<h4 id="32-vue3的性能为什么比vue2好？"><a href="#32-vue3的性能为什么比vue2好？" class="headerlink" title="32.vue3的性能为什么比vue2好？"></a>32.vue3的性能为什么比vue2好？</h4><p>​    1.diff算法的优化<br>​    2.静态提升<br>​    3.事件侦听缓存</p>
<h4 id="33-vue3为什么使用proxy？"><a href="#33-vue3为什么使用proxy？" class="headerlink" title="33.vue3为什么使用proxy？***"></a>33.vue3为什么使用proxy？***</h4><p>​    1.proxy可以代理整个对象，defineproperty(vue2)只代理对象上的某个属性，不需要遍历了，效率更高。<br>​    2.proxy对代理对象的监听更加丰富<br>​    3.proxy代理对象会生成新的对象，不会修改被代理对象本身<br>​    4.proxy补兼容ie浏览器</p>
<h4 id="34-说一下你对组件的理解。"><a href="#34-说一下你对组件的理解。" class="headerlink" title="34.说一下你对组件的理解。"></a>34.说一下你对组件的理解。</h4><p>​    可以重复使用的vue实例，独一无二的组件名称<br>​    可以抽离单独的公共模块<br>​    提高代码的复用率</p>
<h4 id="35-你是如何规划项目文件的？"><a href="#35-你是如何规划项目文件的？" class="headerlink" title="35.你是如何规划项目文件的？"></a>35.你是如何规划项目文件的？</h4><p>​    public<br>​        图标、index.html、img<br>​    src<br>​        api<br>​        assets<br>​        components<br>​            按分类再次划分子目录<br>​        plugins<br>​        router<br>​        static<br>​        styles<br>​        utils<br>​        views<br>​    App.vue<br>​    main.js<br>​    package.json<br>​    vue.config.js</p>
<h4 id="36-是否使用过nuxt-js？"><a href="#36-是否使用过nuxt-js？" class="headerlink" title="36.是否使用过nuxt.js？"></a>36.是否使用过nuxt.js？</h4><p>​    是基于vue的应用框架，关注的是渲染，可以开发服务端渲染应用的配置<br>​    SSR：服务端渲染<br>​        好处：<br>​            SSR生成的是有内容的HTML页面，有利于搜索引擎的搜索<br>​            优化了首屏加载时间<br>​    SEO：优化搜索引擎<br>​    SPA的应用不利于搜索引擎SEO的操作</p>
<h4 id="37-SEO如何优化？"><a href="#37-SEO如何优化？" class="headerlink" title="37.SEO如何优化？"></a>37.SEO如何优化？</h4><p>​    1.SSR<br>​    2.预渲染 prerender-spa-plugin</p>
<h4 id="38-什么是跨域？跨域的原因？解决方法"><a href="#38-什么是跨域？跨域的原因？解决方法" class="headerlink" title="38. 什么是跨域？跨域的原因？解决方法"></a>38. 什么是跨域？跨域的原因？解决方法</h4><ul>
<li><p><em>当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</em>。<em>指的是在网页端,发起一个跨越不同域名(协议、端口号)的HTTP请求的过程</em>。</p>
</li>
<li><p>跨域问题是指由于浏览器的<strong>同源策略</strong>(协议、域名、端口)导致的不同域之间的通信限制。主要是防止 csrf 攻击</p>
</li>
<li><p>前端解决方法（vue）配置代理</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//vite.config.js</span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">	plugins:[vue()],</span><br><span class="line">	server:&#123;</span><br><span class="line">		proxy:&#123;</span><br><span class="line">			&quot;/api&quot;:&#123;</span><br><span class="line">				target:&quot;http://localhost:80&quot;, //转到&quot;http://localhost:80&quot;</span><br><span class="line">				changeOrigin:true,</span><br><span class="line">				rewrite:(path) =&gt; path.replace(/^\/api/,&quot;&quot;) //删除替换&#x27;/api&#x27;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="39-nextTick"><a href="#39-nextTick" class="headerlink" title="39. nextTick()"></a>39. nextTick()</h4><p>作用：在下一次DOM节点更新完后执行其指定的回调</p>
<p>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$dnextTick(function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="40-vuex-pinia区别"><a href="#40-vuex-pinia区别" class="headerlink" title="40.vuex pinia区别"></a>40.vuex pinia区别</h4><ol>
<li><p>Vuex选项式api，pinia组合式api，更灵活</p>
</li>
<li><p><strong>状态管理方式</strong>：</p>
<p>Vuex采用全局单例模式，通过一个store对象来管理所有的状态，组件通过store对象来获取和修改状态。而Pinia采用了分离模式，即每个组件都拥有自己的store实例，通过在组件中创建store实例来管理状态。</p>
</li>
<li><p><strong>数据修改方式</strong>：</p>
<p>Vuex通过mutations来修改状态，而Pinia没有mutations，它只有state、getters和actions（同步、异步）来使用它来修改state数据。</p>
</li>
<li><p>Vuex支持模块化，通过modules配置来组织状态。而Pinia没有modules配置，每一个独立的仓库都是definStore生成出来的</p>
</li>
<li><p>Vuex对TypeScript的支持不完整，而Pinia做到了完整的TypeScript支持，这使其与TypeScript更加兼容和友好，提供了更清晰的类型定义。</p>
</li>
</ol>
<h4 id="五、Echarts"><a href="#五、Echarts" class="headerlink" title="五、Echarts"></a>五、Echarts</h4><h4 id="1-echarts有用过吗？常用的组件有哪些？"><a href="#1-echarts有用过吗？常用的组件有哪些？" class="headerlink" title="1.echarts有用过吗？常用的组件有哪些？"></a>1.echarts有用过吗？常用的组件有哪些？</h4><p>​        title标题组件 show  text  link<br>​        toolbox工具栏 导出图片 数据视图 切换 缩放 show orient feature<br>​        tooltip tigger 触发类型<br>​        markPoint标注点<br>​        markLine图标的标线</p>
<h3 id="六、Uni-APP"><a href="#六、Uni-APP" class="headerlink" title="六、Uni-APP"></a>六、Uni-APP</h3><h4 id="1-uni-app有没有做过分包？"><a href="#1-uni-app有没有做过分包？" class="headerlink" title="1.uni-app有没有做过分包？"></a>1.uni-app有没有做过分包？</h4><p>​        优化小程序的下载和启动速度<br>​        小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示</p>
<h3 id="七、Weabpack"><a href="#七、Weabpack" class="headerlink" title="七、Weabpack"></a>七、Weabpack</h3><h4 id="1-webpack打包和不打包的区别？"><a href="#1-webpack打包和不打包的区别？" class="headerlink" title="1.webpack打包和不打包的区别？"></a>1.webpack打包和不打包的区别？</h4><p>​        1.运行效率<br>​        2.对基础的支持不够</p>
<h4 id="2-webpack是怎么打包的，babel是做什么的？"><a href="#2-webpack是怎么打包的，babel是做什么的？" class="headerlink" title="2.webpack是怎么打包的，babel是做什么的？"></a>2.webpack是怎么打包的，babel是做什么的？</h4><p>​        webpack会把js css image看作一个模块，用import&#x2F;require引入<br>​        找到入口文件，通过入口文件找到关联的依赖文件，把他们打包到一起<br>​        把bundle文件，拆分成多个小的文件，异步按需加载所需要的文件<br>​        如果一个被多个文件引用，打包时只会生成一个文件<br>​        如果引用的文件没有调用，不会打包，如果引入的变量和方法没有调用也不会打包<br>​        对于多个入口文件，加入引入了相同的代码，可以用插件把他抽离到公共文件中</p>
<h3 id="八、Git"><a href="#八、Git" class="headerlink" title="八、Git"></a>八、Git</h3><h4 id="1-git如何合并、拉取代码？"><a href="#1-git如何合并、拉取代码？" class="headerlink" title="1.git如何合并、拉取代码？"></a>1.git如何合并、拉取代码？</h4><p>​        拉取代码 git pull ‘仓库地址’<br>​        查看状态 git sattus<br>​        提交到本地缓存区  git add .<br>​        提交本地仓库 git commit -m ‘修改描述’<br>​        提交到远程仓库 git push ‘仓库地址’ master<br>​        创建分支 git branch -b xxx<br>​        合并分支 git merge ‘合并分支的名字’</p>
<h4 id="2-git如何解决冲突问题？"><a href="#2-git如何解决冲突问题？" class="headerlink" title="2.git如何解决冲突问题？"></a>2.git如何解决冲突问题？</h4><p>​        1.两个分支中修改了同一个文件<br>​        2.两个分支中修改了同一个文件的名字<br>​        1.解决：当前分支上，直接修改代码  add  commit<br>​        2.解决：在本地当前分支上，修改冲突代码 add commit push</p>
<h4 id="3-git-stash"><a href="#3-git-stash" class="headerlink" title="3.git stash"></a>3.git stash</h4><p>场景一：当前分支A,BUG分支B</p>
<ol>
<li><code>git stash</code>,先存入栈</li>
<li><code>git checkout B</code>,切换到BUG分支B</li>
<li><code>git checkout A</code>,修完BUG切回分支A</li>
<li><code>git stash pop</code>,取回</li>
</ol>
<p>场景二：代码开发完准备提交</p>
<ol>
<li><p><code>git stash</code></p>
</li>
<li><p><code>git pull 仓库别名</code></p>
</li>
<li><p><code>git stash pop</code></p>
</li>
<li><p>本地处理可能出现的冲突</p>
</li>
<li><p><code>git commit -m &quot;xxx&quot;</code> + <code>git push 仓库别名</code></p>
</li>
<li><p>存（入栈）</p>
<p><code>git stash</code></p>
<p><code>git stash save &#39;注释&#39;</code></p>
</li>
<li><p>取（出栈）</p>
</li>
</ol>
<p>​	<code>git stash pop</code></p>
<p>​	<code>git stash apply</code> </p>
<ol start="3">
<li>清除</li>
</ol>
<p>​	<code>git stash drop + &lt;栈索引&gt;</code>清除某条记录</p>
<p>​	<code>git stash clear</code>清空整个栈</p>
<ol start="4">
<li>查看</li>
</ol>
<p>​	<code>git stash list</code>查看整个栈的所有记录</p>
<p>​	<code>git stash show</code>查看某条记录的具体信息</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-面试 -八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2024/06/27/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><blockquote>
<p>单位时间内，频繁触发事件，只执行最后一次。</p>
<p>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。应用场景：手机号、邮箱验证、搜索框输入。</p>
</blockquote>
<p><img src="/images/JavaScript/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/%E9%98%B2%E6%8A%96.PNG"></p>
<p>实现：</p>
<p>利用lodash的 debounced（防抖动）函数。</p>
<p><code>_.debounce(func, [wait=0], [options=])</code> 等待时间：[wait&#x3D;0]单位是多少毫秒，先等待再执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,_.<span class="title function_">debounce</span>(fn,<span class="number">500</span>))</span><br></pre></td></tr></table></figure>

<p>其底层是用定时器setTimeout实现的，每次执行前先判断有没有定时器，有则清除定时器。</p>
<ol>
<li>声明定时器变量</li>
<li>每次事件触发前判断有没有存在定时器，有则清除</li>
<li>开启定时器，存入到定时器变量</li>
<li>定时器里调用传入的函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn,t</span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer) <span class="built_in">clearTimeout</span>(timer) <span class="comment">//若存在定时器，则删除</span></span><br><span class="line">		timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="title function_">fn</span>()</span><br><span class="line">		&#125;,t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,<span class="title function_">debounce</span>(fn,<span class="number">500</span>))</span><br></pre></td></tr></table></figure>

<p>一直移动鼠标，停下来后，等500毫秒才执行。</p>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><blockquote>
<p>单位事件内（周期），频繁触发事件，只执行一次。</p>
<p>高频事件触发，但在n秒内只会执行一次。应用场景：window对象的页面尺寸缩放resize、滚动条滚动scroll事件，文字输入，mousemove，射击游戏的mousedown，keydown</p>
</blockquote>
<p>例子，射击游戏频繁点击鼠标，为了节流，规定单位事件内点击的n次鼠标只执行一次操作。</p>
<p><img src="/images/JavaScript/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/%E8%8A%82%E6%B5%81.PNG"></p>
<p>实现：</p>
<p>利用lodash的<code>_.throttle(func, [wait=0], [options=])</code>，wait&#x3D;n毫秒内，只会执行一次操作。</p>
<p>底层实现：</p>
<ol>
<li><p>声明一个定时器变量</p>
</li>
<li><p>每次事件触发前先判断是否存在定时器，如果有则不开启新定时器</p>
</li>
<li><p>如果没有定时器则开启定时器，存入定时器变量</p>
<pre><code>- 定时器里面调用执行的函数

- 定时器里面要把定时器清空
</code></pre>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn,t</span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="comment">//如果不存在定时器,则创建新定时器</span></span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">			timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">				<span class="title function_">fn</span>() </span><br><span class="line">                <span class="comment">//清空定时器</span></span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;,t)</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,<span class="title function_">debounce</span>(fn,<span class="number">500</span>))</span><br></pre></td></tr></table></figure>

<p>一直移动鼠标，单位时间500毫秒内无论执行多少次，只执行一次。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
