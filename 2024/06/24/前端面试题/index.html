<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="一个废物的博客" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>前端面试题 |  CoffeeLin</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/咖啡.svg" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="CoffeeLin" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-前端面试题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  前端面试题
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/06/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2024-06-24T15:48:55.000Z" itemprop="datePublished">2024-06-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">16.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">61 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="一、CSS"><a href="#一、CSS" class="headerlink" title="一、CSS"></a>一、CSS</h3><h4 id="1-说一下CSS的盒模型。"><a href="#1-说一下CSS的盒模型。" class="headerlink" title="1.说一下CSS的盒模型。"></a>1.说一下CSS的盒模型。</h4><p>盒模型的属性：</p>
<p><em>width、height、padding、border、margin</em></p>
<p>​        在HTML页面中的所有元素都可以看成是一个盒子<br>​        盒子的组成：内容content、内边距padding、边框border、外边距margin<br>​        盒模型的类型：<br>​            标准盒模型<br>​                margin + border + padding + content，宽高不包含内边距和边框<br>​            IE盒模型<br>​                margin + content(border + padding)，宽高包含内边距和边框<br>​        控制盒模型的模式：box-sizing:content-box（默认值，标准盒模型）、border-box（IE盒模型）;</p>
<h4 id="2-CSS选择器的优先级？"><a href="#2-CSS选择器的优先级？" class="headerlink" title="2.CSS选择器的优先级？"></a>2.CSS选择器的优先级？</h4><p>​        CSS的特性：继承性、层叠性、优先级<br>​        优先级：写CSS样式的时候，会给同一个元素添加多个样式，此时谁的权重高就显示谁的样式<br>​        标签、类&#x2F;伪类&#x2F;属性、全局选择器、行内样式、id、!important<br>​        !important &gt; 行内样式 &gt; id &gt; 类&#x2F;伪类&#x2F;属性 &gt; 标签 &gt; 全局选择器</p>
<h4 id="3-隐藏元素的方法有哪些，特点是？"><a href="#3-隐藏元素的方法有哪些，特点是？" class="headerlink" title="3.隐藏元素的方法有哪些，特点是？"></a>3.隐藏元素的方法有哪些，特点是？</h4><ol>
<li>display:none;元素在页面上消失，<strong>不占据空间</strong></li>
<li>opacity:0;​设置了元素的透明度为0，元素不可见，<strong>占据空间位置</strong></li>
<li>visibility:hidden;让元素消失，<strong>占据空间位置</strong>，一种不可见的状态</li>
<li>利用缩放：transform: scale(0);</li>
<li>利用定位：position:absolute;z-index;</li>
<li>clip-path</li>
</ol>
<h4 id="4-px和rem的区别是什么？"><a href="#4-px和rem的区别是什么？" class="headerlink" title="4.px和rem的区别是什么？"></a>4.px和rem的区别是什么？</h4><p>​        px是像素，显示器上给我们呈现画面的像素，每个像素的大小是一样，绝对单位长度<br>​        rem，相对单位，相对于html根节点的font-size的值，直接给html节点的font-size:62.5%;<br>​            1rem &#x3D; 10px; （16px*62.5%&#x3D;10px）</p>
<h4 id="5-重绘重排有什么区别？"><a href="#5-重绘重排有什么区别？" class="headerlink" title="5.重绘重排有什么区别？"></a>5.重绘重排有什么区别？</h4><p>​        重排（回流）：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小<br>​        重绘：计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制<br>​        <strong>浏览器的渲染机制</strong><br>​        对DOM的大小、位置进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排<br>​        对DOM的样式进行修改，比如color和background-color，浏览器不需要重新计算几何属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘</p>
<h4 id="6-让一个元素水平垂直居中的方式有哪些？"><a href="#6-让一个元素水平垂直居中的方式有哪些？" class="headerlink" title="6.让一个元素水平垂直居中的方式有哪些？"></a>6.让一个元素水平垂直居中的方式有哪些？</h4><p>​        1.定位+margin<br>​        2.定位+transform<br>​        3.flex布局<br>​        4.grid布局<br>​        5.table布局</p>
<h4 id="7-CSS的哪些属性哪些可以继承？哪些不可以继承？"><a href="#7-CSS的哪些属性哪些可以继承？哪些不可以继承？" class="headerlink" title="7.CSS的哪些属性哪些可以继承？哪些不可以继承？"></a>7.CSS的哪些属性哪些可以继承？哪些不可以继承？</h4><p>​        CSS的三大特性：继承、层叠、优先级<br>​        子元素可以继承父类元素的样式<br>​        1.字体的一些属性：font<br>​        2.文本的一些属性：line-height<br>​        3.元素的可见性：visibility:hidden<br>​        4.表格布局的属性：border-spacing<br>​        5.列表的属性：list-style<br>​        6.页面样式属性：page<br>​        7.声音的样式属性</p>
<h4 id="8-有没有用过预处理器？"><a href="#8-有没有用过预处理器？" class="headerlink" title="8.有没有用过预处理器？"></a>8.有没有用过预处理器？</h4><p>​        预处理语言增加了变量、函数、混入等强大的功能<br>​        SASS  LESS</p>
<h4 id="9-如何画一条0-5px线"><a href="#9-如何画一条0-5px线" class="headerlink" title="9. 如何画一条0.5px线"></a>9. 如何画一条0.5px线</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.line&#123;</span><br><span class="line">	border-top:1px solid black;</span><br><span class="line">	transform:scaleY(0.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-定位"><a href="#10-定位" class="headerlink" title="10.定位"></a>10.定位</h4><ol>
<li><p>相对定位，相对于元素原来的位置，不会脱离文档流。</p>
</li>
<li><p>绝对定位，参考它的包含块，脱离文档流。配合相对定位使用。</p>
</li>
<li><p>固定定位，参考它的视口，脱离文档流。</p>
</li>
<li><p>粘性定位，参考离它最近的一个拥有“滚动机制”的祖先元素，<strong>不会脱离文档流</strong>。</p>
</li>
</ol>
<h4 id="11-消除浮动"><a href="#11-消除浮动" class="headerlink" title="11.消除浮动"></a>11.消除浮动</h4><ol>
<li><p><code>clear:both</code> clear属性指定元素两侧不能出现浮动元素,添加一个空的块级元素，给其<code>clear:both</code>属性。<strong>在浮动元素下加<br clear="all"></strong></p>
</li>
<li><p>将父元素设置为flex布局。</p>
</li>
<li><p>父元素设置<code>overflow:hidden/auto/scoll</code>。</p>
</li>
<li><p>将父元素也设置为浮动。</p>
</li>
<li><p>添加伪元素 ，在父元素内的最后添加一个伪元素。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after&#123;</span><br><span class="line"> content:&#x27;&#x27;;</span><br><span class="line"> display:block;</span><br><span class="line"> clear:both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;clearfix&quot;&gt;</span><br><span class="line"> &lt;div class=&quot;box1&quot;&gt;</span><br><span class="line"> ...</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>display:inline&#x2F;block&#x2F;inline-block:设置为行内&#x2F;内联，块级，行内块级元素</p>
</blockquote>
<h4 id="12-自适应布局"><a href="#12-自适应布局" class="headerlink" title="12.自适应布局"></a>12.自适应布局</h4><p>界面布局的类型<br>界面的布局都是使用css写的，布局分为5种：固定布局，流式布局，弹性布局，自适应布局，响应式布局。</p>
<p>固定布局：就是静态布局，换句话说，就是界面是死的，一般是px单位。</p>
<p>流式布局：顾名思义，流动，像水一样，会根据界面的变化而变化，但是字体不会变化，一般是百分比的单位。</p>
<p>弹性布局：具有弹性，像橡皮筋一样，弹来弹去，可大可小，一般是rem，em单位</p>
<p><strong>自适应布局：自适应，就是根据不同的设备，进行布局，一种屏幕一个布局，主要是使用媒体查询，主要用到尺寸值有百分比、auto等</strong></p>
<p>响应式布局：最强大，一套代码，可以实现所有设备的大小的变化，包括手机端和电脑端，一般都是综合使用上面的。</p>
<h4 id="13-网格布局"><a href="#13-网格布局" class="headerlink" title="13.网格布局"></a>13.网格布局</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display:grid;</span><br><span class="line">grid-template-columns:repeat(auto-fill,minmax(200px,1fr)); //repeat(3,1fr);3列</span><br><span class="line">gap: 30px;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="二、JavaScript"><a href="#二、JavaScript" class="headerlink" title="二、JavaScript"></a>二、JavaScript</h3><h4 id="1-JS由哪三部分组成？"><a href="#1-JS由哪三部分组成？" class="headerlink" title="1.JS由哪三部分组成？"></a>1.JS由哪三部分组成？</h4><ol>
<li>ECMAScript：JS的核心内容，描述了语言的基础语法，比如var,for，数据类型（数组、字符串），</li>
<li>文档对象模型（DOM）：DOM把整个HTML页面规划为元素构成的文档</li>
<li>浏览器对象模型（BOM）：对浏览器窗口进行访问和操作</li>
</ol>
<h4 id="2-JS有哪些内置对象？"><a href="#2-JS有哪些内置对象？" class="headerlink" title="2.JS有哪些内置对象？"></a>2.JS有哪些内置对象？</h4><pre><code>String Boolean Number Array Object Function Math Date RegExp...
Math
    abs() sqrt() max() min()
Date
    new Date() getYear() 
Array
String
    concat() length  slice() split()
</code></pre>
<h4 id="3-操作数组的方法有哪些？"><a href="#3-操作数组的方法有哪些？" class="headerlink" title="3.操作数组的方法有哪些？"></a>3.操作数组的方法有哪些？</h4><pre><code>push() pop() sort() splice() unshift() shift() reverse() concat() join() 
map() filter() every() some() reduce() isArray() findIndex()
哪些方法会改变原数组？
    push() pop() unshift() shift() sort() reverse() splice()
</code></pre>
<h4 id="4-JS对数据类的检测方式有哪些？"><a href="#4-JS对数据类的检测方式有哪些？" class="headerlink" title="4.JS对数据类的检测方式有哪些？"></a>4.JS对数据类的检测方式有哪些？</h4><pre><code>typeof       --基本数据类型	typeof 5 -&gt; &quot;number&quot; , typeof null -&gt; &quot;object&quot;
instanceof   --引用数据类型	p instanceof Person -&gt; true
.constructor --均可	      (5).constructor === Number -&gt; true,&quot;text&quot;.constructor === String,p.constructor === Person-&gt;true
Object.prototype.toString.call() -&gt; &quot;[object Object/Array/Function/String/Number/Date...]&quot;
</code></pre>
<h4 id="5-说一下闭包，闭包有什么特点？"><a href="#5-说一下闭包，闭包有什么特点？" class="headerlink" title="5.说一下闭包，闭包有什么特点？"></a>5.说一下闭包，闭包有什么特点？</h4><pre><code>什么是闭包？函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包。
特点：可以重复利用变量，并且这个变量不会污染全局的一种机制；这个变量是一直保存再内存中，不会被垃圾回收机制回收
缺点：闭包较多的时候，会消耗内存，导致页面的性能下降，在IE浏览器中才会导致内存泄漏
使用场景：防抖，节流，函数嵌套函数避免全局污染的时候
</code></pre>
<h4 id="6-前端的内存泄漏怎么理解？"><a href="#6-前端的内存泄漏怎么理解？" class="headerlink" title="6.前端的内存泄漏怎么理解？"></a>6.前端的内存泄漏怎么理解？</h4><pre><code>JS里已经分配内存地址的对象，但是由于长时间没有释放或者没办法清除，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。
垃圾回收机制
因素：一些为生命直接赋值的变量；一些未清空的定时器；过度的闭包；一些引用元素没有被清除。
</code></pre>
<h4 id="7-事件委托是什么？"><a href="#7-事件委托是什么？" class="headerlink" title="7.事件委托是什么？"></a>7.事件委托是什么？</h4><pre><code>又叫事件代理，原理就是利用了事件冒泡的机制来实现，也就是说把子元素的事件绑定到了父元素的身上。
如果子元素阻止了事件冒泡，那么委托也就不成立。阻止事件冒泡：event.stopPropagation()。
addEventListener(&#39;click&#39;,函数名，true/false) 默认是false（事件冒泡），true（事件捕获）
好处：提高性能，减少事件的绑定，也就减少了内存的占用。
</code></pre>
<h4 id="8-基本数据类型和引用数据类型的区别？"><a href="#8-基本数据类型和引用数据类型的区别？" class="headerlink" title="8.基本数据类型和引用数据类型的区别？"></a>8.基本数据类型和引用数据类型的区别？</h4><pre><code>基本数据类型：String Number Boolean undefined null Symbol
    基本数据类型保存在栈内存当中，保存的就是一个具体的值
引用数据类型（复杂数据类型）：Object Function Array
    保存在堆内存当中，声明一个引用类型的变量，它保存的是引用类型数据的地址
    假如声明两个引用类型同时指向了一个地址的时候，修改其中一个那么另外一个也会改变
</code></pre>
<h4 id="9-说一下原型链。"><a href="#9-说一下原型链。" class="headerlink" title="9.说一下原型链。"></a>9.说一下原型链。</h4><pre><code>搜索机制。
原型就是一个普通对象，它是为构造函数的实例共享属性和方法；所有实例中引用的原型都是同一个对象。
使用prototype可以把方法挂在原型上，内存值保存一份。
__proto__可以理解为指针，实例对象中的属性，指向了构造函数的原型（prototype）。
</code></pre>
<h4 id="10-new操作符具体做了什么？"><a href="#10-new操作符具体做了什么？" class="headerlink" title="10.new操作符具体做了什么？"></a>10.new操作符具体做了什么？</h4><pre><code>1.先创建一个空对象
2.把空对象和构造函数通过原型链进行链接
3.把构造函数的this绑定到新的空对象身上
4.根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要返回这个引用类型

1. 创建一个空对象。
2. 将空对象的原型链接（__proto__）到构造函数的原型对象。这样新对象就可以访问构造函数原型对象中定义的属性和方法。
3. 将构造函数的作用域赋给空对象。这样新对象就可以通过this关键字来引用构造函数中的属性和方法。
4. 执行构造函数中的代码。构造函数中的代码将用于初始化新对象的属性。
5. 如果构造函数中没有返回其他对象，那么new操作符将返回新创建的对象实例。否则，返回构造函数中返回的对象。
</code></pre>
<h4 id="11-JS是如何实现继承的？"><a href="#11-JS是如何实现继承的？" class="headerlink" title="11.JS是如何实现继承的？"></a>11.JS是如何实现继承的？</h4><pre><code>1.原型链继承
2.借用构造函数继承
3.组合式继承
4.ES6的class类继承
</code></pre>
<h4 id="12-JS的设计原理是什么？"><a href="#12-JS的设计原理是什么？" class="headerlink" title="12.JS的设计原理是什么？"></a>12.JS的设计原理是什么？</h4><pre><code>JS引擎 运行上下文 调用栈 事件循环 回调
</code></pre>
<h4 id="13-JS中关于this指向的问题"><a href="#13-JS中关于this指向的问题" class="headerlink" title="13.JS中关于this指向的问题"></a>13.JS中关于this指向的问题</h4><pre><code>1. 全局对象中的this指向
指向的是window
2. 全局作用域或者普通函数中的this
指向全局window
3. this永远指向最后调用它的那个对象
在不是箭头函数的情况下
4. new 关键词改变了this的指向
5. apply,call,bind
可以改变this指向，不是箭头函数
6. 箭头函数中的this
它的指向在定义的时候就已经确定了
箭头函数它没有this,看外层是否有函数，有就是外层函数的this，没有就是window
7. 匿名函数中的this
永远指向了window,匿名函数的执行环境具有全局性，因此this指向window
</code></pre>
<h4 id="14-script标签里的async和defer有什么区别？"><a href="#14-script标签里的async和defer有什么区别？" class="headerlink" title="14.script标签里的async和defer有什么区别？"></a>14.script标签里的async和defer有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当没有async和defer这两个属性的时候，浏览器会立刻加载并执行指定的脚本</span><br><span class="line">有async</span><br><span class="line">加载和渲染后面元素的过程将和script的加载和执行并行进行（异步）</span><br><span class="line">有defer</span><br><span class="line">加载和渲染后面元素的过程将和script的加载并行进行（异步），但是它的执行事件要等所有元素解析完成之后才会执行</span><br></pre></td></tr></table></figure>

<h4 id="15-setTimeout最小执行时间是多少？"><a href="#15-setTimeout最小执行时间是多少？" class="headerlink" title="15.setTimeout最小执行时间是多少？"></a>15.setTimeout最小执行时间是多少？</h4><p>HTML5规定的内容：</p>
<ul>
<li>setTimeout最小执行时间是4ms</li>
<li>setInterval最小执行时间是10ms</li>
</ul>
<h4 id="16-ES6和ES5有什么区别？"><a href="#16-ES6和ES5有什么区别？" class="headerlink" title="16.ES6和ES5有什么区别？"></a>16.ES6和ES5有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JS的组成：ECMAScript BOM  DOM</span><br><span class="line">ES5:ECMAScript5,2009年ECMAScript的第五次修订，ECMAScript2009</span><br><span class="line">ES6:ECMAScript6,2015年ECMAScript的第六次修订，ECMAScript2015，是JS的下一个版本标准</span><br></pre></td></tr></table></figure>

<h4 id="17-ES6的新特性有哪些？"><a href="#17-ES6的新特性有哪些？" class="headerlink" title="17.ES6的新特性有哪些？"></a>17.ES6的新特性有哪些？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1.  新增块级作用域（let,const）</span><br><span class="line">   不存在变量提升</span><br><span class="line">   存在暂时性死区的问题</span><br><span class="line">   块级作用域的内容</span><br><span class="line">   不能在同一个作用域内重复声明</span><br><span class="line">2.  新增了定义类的语法糖（class）</span><br><span class="line">3.  新增了一种基本数据类型（symbol）</span><br><span class="line">4.  新增了解构赋值</span><br><span class="line">   从数组或者对象中取值，然后给变量赋值</span><br><span class="line">5.  新增了函数参数的默认值</span><br><span class="line">6.  给数组新增了API</span><br><span class="line">7.  对象和数组新增了扩展运算符</span><br><span class="line">8.  Promise</span><br><span class="line">   解决回调地狱的问题。</span><br><span class="line">   自身有all,reject,resolve,race方法</span><br><span class="line">   原型上有then,catch</span><br><span class="line">   把异步操作队列化</span><br><span class="line">   三种状态：pending初始状态,fulfilled操作成功,rejected操作失败</span><br><span class="line">   状态：pending -&gt; fulfilled;pending -&gt; rejected 一旦发生，状态就会凝固，不会再变</span><br><span class="line">   async  await</span><br><span class="line">   同步代码做异步的操作，两者必须搭配使用</span><br><span class="line">   async表明函数内有异步操作，调用函数会返回promise</span><br><span class="line">   await是组成async的表达式，结果是取决于它等待的内容，如果是promise那就是promise的结果，如果是普通函数就进行链式调用</span><br><span class="line">   await后的promise如果是reject状态，那么整个async函数都会中断，后面的代码不执行</span><br><span class="line"></span><br><span class="line">9.  新增了模块化（import,export）</span><br><span class="line">10.  新增了set和map数据结构</span><br><span class="line">    set就是不重复</span><br><span class="line">    map的key的类型不受限制</span><br><span class="line">11.  新增了generator</span><br><span class="line">12.  新增了箭头函数</span><br><span class="line">    不能作为构造函数使用，不能用new</span><br><span class="line">    箭头函数就没有原型</span><br><span class="line">    箭头函数没有arguments</span><br><span class="line">    箭头函数不能用call,apply,bind去改变this的执行</span><br><span class="line">    this指向外层第一个函数的this</span><br></pre></td></tr></table></figure>

<h4 id="18-call-aply-bind三者有什么区别？"><a href="#18-call-aply-bind三者有什么区别？" class="headerlink" title="18.call,aply,bind三者有什么区别？"></a>18.call,aply,bind三者有什么区别？</h4><p>都是改变this指向和函数的调用，call和apply的功能类似，只是传参的方法不同<br>call方法传的是一个参数列表<br>apply传递的是一个数组<br>bind传参后不会立刻执行，会返回一个改变了this指向的函数，这个函数还是可以传参的，bind()()<br>call方法的性能要比apply好一些，所以call用的更多一点</p>
<h4 id="19-用递归的时候有没有遇到什么问题？"><a href="#19-用递归的时候有没有遇到什么问题？" class="headerlink" title="19.用递归的时候有没有遇到什么问题？"></a>19.用递归的时候有没有遇到什么问题？</h4><p>如果一个函数内可以调用函数本身，那么这个就是递归函数<br>函数内部调用自己<br>特别注意：写递归必须要有<strong>退出条件</strong>return</p>
<h4 id="20-如何实现一个深拷贝？"><a href="#20-如何实现一个深拷贝？" class="headerlink" title="20.如何实现一个深拷贝？"></a>20.如何实现一个深拷贝？</h4><p>深拷贝就是完全拷贝一份新的对象，会在堆内存中开辟新的空间，拷贝的对象被修改后，原对象不受影响<br>主要针对的是引用数据类型</p>
<ol>
<li>lodash的_.deepClone实现</li>
<li>JSON.parse(JSON.stringify())</li>
<li>Object.assign(obj1,obj2)，将obj2拷贝到obj1</li>
<li>利用递归函数实现</li>
</ol>
<h4 id="21-说一下事件循环。"><a href="#21-说一下事件循环。" class="headerlink" title="21.说一下事件循环。"></a>21.说一下事件循环。</h4><p>JS是一个单线程的脚本语言<br>主线程 执行栈 任务队列  宏任务 微任务<br>主线程先执行同步任务，然后才去执行任务队列里的任务，如果在执行宏任务之前有微任务，那么要先执行微任务<br>全部执行完之后等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环！</p>
<p>主线程同步任务&gt;任务队列(异步)&gt;微任务&gt;宏任务</p>
<h4 id="22-ajax是什么？怎么实现的？"><a href="#22-ajax是什么？怎么实现的？" class="headerlink" title="22.ajax是什么？怎么实现的？"></a>22.ajax是什么？怎么实现的？</h4><p>创建<strong>交互式网页应用的网页开发技术</strong><br>    在不重新加载整个网页的前提下，与服务器交换数据并更新部分内容<br>通过XmlHttpRequest对象向服务器发送异步请求，然后从服务器拿到数据，最后通过JS操作DOM更新页面<br>1.创建XmlHttpRequest对象 xhr<br>2.通过xhr对象里的open()方法和服务器建立连接<br>3.构建请求所需的数据，并通过xhr对象的send()发送给服务器<br>4.通过xhr对象的onreadystatechanges事件监听服务器和你的通信状态<br>5.接收并处理服务器响应的数据结果<br>6.把处理的数据更新到HTML页面上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function loadData() &#123;</span><br><span class="line">  // 创建 XMLHttpRequest 对象</span><br><span class="line">  var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">  // 配置请求，指定请求方法和URL</span><br><span class="line">  xhr.open(&quot;GET&quot;, &quot;https://jsonplaceholder.typicode.com/posts/1&quot;, true);</span><br><span class="line"></span><br><span class="line">  // 定义请求完成后的回调函数</span><br><span class="line">  xhr.onreadystatechange = function() &#123;</span><br><span class="line">    // 请求完成且响应状态为 200 表示成功</span><br><span class="line">    if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;</span><br><span class="line">      // 解析服务器响应的 JSON 数据</span><br><span class="line">      var data = JSON.parse(xhr.responseText);</span><br><span class="line"></span><br><span class="line">      // 更新页面上的内容</span><br><span class="line">      document.getElementById(&quot;result&quot;).innerHTML = &quot;Title: &quot; + data.title;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 发送请求</span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>readyState:</strong></p>
<p>0：请求未初始化<br>1：服务器连接已建立<br>2：请求已接收<br>3：请求处理中<br>4:请求已完成，且响应已就绪</p>
<p><strong>status:</strong></p>
<p>200:”OK”<br>404:未找到页面</p>
<h4 id="23-get和post有什么区别？"><a href="#23-get和post有什么区别？" class="headerlink" title="23.get和post有什么区别？"></a>23.get和post有什么区别？</h4><p>1.get一般是获取数据，post一般是提交数据<br>2.get参数会放在url&#x2F;query上，post是放在body中<br>3.get请求刷新服务器或退回是没有影响的，post请求退回时会重新提交数据<br>4.<strong>get请求时会被缓存,post请求不会被缓存</strong><br>5.get请求会被保存在浏览器历史记录中,post不会<br>6.get请求只能进行url编码，post请求支持多种编码方式（json，xml，form-data表单数据）</p>
<p>post请求为什么有2次？</p>
<blockquote>
<p>第一次发送请求头响应100，再次响应返回200，成功</p>
<p>先发起一个OPTIONS请求，然后再发送实际的 POST 请求。</p>
</blockquote>
<h4 id="24-promise的内部原理是什么？它的优缺点是什么？"><a href="#24-promise的内部原理是什么？它的优缺点是什么？" class="headerlink" title="24. promise的内部原理是什么？它的优缺点是什么？"></a>24. promise的内部原理是什么？它的优缺点是什么？</h4><p><strong>Promise对象，封装了一个异步操作并且还可以获取成功或失败的结果</strong><br>Promise主要就是解决<strong>回调地狱</strong>的问题，之前如果异步任务比较多，同时他们之间有相互依赖的关系，就只能使用回调函数处理，这样就容易形成回调地狱，代码的可读性差，可维护性也很差<br>有三种状态：pending初始状态  fulfilled成功状态  rejected失败状态<br>状态改变只会有两种情况，<br>    pending -&gt; fulfilled; pending -&gt; rejected 一旦发生，状态就会凝固，不会再变<br>首先就是我们无法取消promise，一旦创建它就会立即执行，不能中途取消<br>如果不设置回调，promise内部抛出的测u哦呜就无法反馈到外面<br>若当前处于pending状态时，无法得知目前在哪个阶段。<br>原理：<br>    构造一个Promise实例，实例需要传递函数的参数，这个函数有两个形参，分别都是函数类型，一个是<strong>resolve</strong>一个是<strong>reject</strong><br>    promise上还有then方法，这个方法就是来指定状态改变时的确定操作，resolve是执行第一个函数，reject是执行第二个函数</p>
<h4 id="25-promise和async-await的区别是什么？"><a href="#25-promise和async-await的区别是什么？" class="headerlink" title="25.promise和async await的区别是什么？"></a>25.promise和async await的区别是什么？</h4><p>1.都是处理异步请求的方式<br>2.promise是ES6，async await 是ES7的语法<br>3.async await是基于promise实现的，他和promise都是<strong>非阻塞性</strong>的<br>优缺点：<br>1.promise是返回对象我们要用then，catch方法去处理和捕获异常，并且书写方式是链式，容易造成代码重叠，不好维护，async await 是通过try catch进行捕获异常<br>2.async await最大的优点就是能让代码看起来像同步一样，只要遇到await就会立刻返回结果，然后再执行后面的操作<br>promise.then()的方式返回，会出现请求还没返回，就执行了后面的操作</p>
<h4 id="26-浏览器的存储方式有哪些？"><a href="#26-浏览器的存储方式有哪些？" class="headerlink" title="26.浏览器的存储方式有哪些？"></a>26.浏览器的存储方式有哪些？</h4><p>1.cookies<br>    H5标准前的本地存储方式<br>    兼容性好，请求头自带cookie<br>    存储量小，资源浪费，使用麻烦（封装）<br>2.localstorage<br>    H5加入的以键值对为标准的方式<br>    操作方便，永久存储，兼容性较好<br>    保存值的类型被限定，浏览器在隐私模式下不可读取，不能被爬虫<br>3.sessionstorage<br>    当前页面关闭后就会立刻清理，会话级别的存储方式<br>4.indexedDB<br>    H5标准的存储方式，他是以键值对进行存储，可以快速读取，适合WEB场景</p>
<h4 id="27-token存在sessionstorage还是loaclstorage？"><a href="#27-token存在sessionstorage还是loaclstorage？" class="headerlink" title="27.token存在sessionstorage还是loaclstorage？"></a>27.token存在sessionstorage还是loaclstorage？</h4><p>token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串<br>1.存loaclstorage里，后期每次请求接口都需要把它当作一个字段传给后台<br>2.存cookie中，会自动发送，缺点就是不能跨域<br>如果存在localstorage中，容易被XSS攻击，但是如果做好了对应的措施，那么是利大于弊<br>如果存在cookie中会有CSRF攻击</p>
<h4 id="28-token的登录流程。"><a href="#28-token的登录流程。" class="headerlink" title="28.token的登录流程。"></a>28.token的登录流程。</h4><p>1.客户端用账号密码请求登录<br>2.服务端收到请求后，需要去验证账号密码<br>3.验证成功之后，服务端会签发一个token，把这个token发送给客户端<br>4.客户端收到token后保存起来，可以放在cookie也可以是localstorage<br>5.客户端每次向服务端发送请求资源的时候，都需要携带这个token<br>6.服务端收到请求，接着去验证客户端里的token，验证成功才会返回客户端请求的数据</p>
<h4 id="29-页面渲染的过程是怎样的？"><a href="#29-页面渲染的过程是怎样的？" class="headerlink" title="29.页面渲染的过程是怎样的？"></a>29.页面渲染的过程是怎样的？</h4><ol>
<li><p>DNS解析</p>
</li>
<li><p>建立TCP连接</p>
</li>
<li><p>发送HTTP请求</p>
</li>
<li><p>服务器处理请求</p>
</li>
<li><p>渲染页面</p>
<ul>
<li><p>浏览器会获取HTML和CSS的资源</p>
</li>
<li><p>然后把HTML解析成DOM树</p>
</li>
<li><p>再把CSS解析成CSSOM</p>
</li>
<li><p>把DOM和CSSOM合并为渲染树</p>
</li>
<li><p>布局</p>
</li>
<li><p>把渲染树的每个节点渲染到屏幕上（绘制）</p>
</li>
<li><p>页面发生变化时：重排和回流(重排)</p>
<ul>
<li>重绘：重新绘制已经显示的元素，（计算好盒模型的位置、大小之后）</li>
<li>回流(重排)：重新计算元素的位置和大小。盒模型在页面上的位置和大小<ul>
<li>回流比重绘的代价更高，因为回流会涉及到整个渲染树的<strong>重新计算</strong>和<strong>布局</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>断开TCP连接</p>
</li>
</ol>
<h4 id="30-DOM树和渲染树有什么区别？"><a href="#30-DOM树和渲染树有什么区别？" class="headerlink" title="30.DOM树和渲染树有什么区别？"></a>30.DOM树和渲染树有什么区别？</h4><p>DOM树是和HTML标签一一对应的，包括head和隐藏元素<br>渲染树是不包含head和隐藏元素的，是实际在页面上显示的</p>
<h4 id="31-精灵图和base64的区别是什么？"><a href="#31-精灵图和base64的区别是什么？" class="headerlink" title="31.精灵图和base64的区别是什么？"></a>31.精灵图和base64的区别是什么？</h4><p>精灵图：把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，当访问页面可以减少请求，提高加载速度<br>base64：传输8Bit字节代码的编码方式，把原本二进制形式转为64个字符的单位，最后组成字符串<br>base64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，但是一些低版本不支持，若base64体积比原图片大，不利于css的加载。</p>
<h4 id="32-svg格式了解多少？"><a href="#32-svg格式了解多少？" class="headerlink" title="32.svg格式了解多少？"></a>32.svg格式了解多少？</h4><p>可缩放矢量图，基于<strong>XML语法格式</strong>的图像格式，其他图像是基于像素的，SVG是属于对图像形状的描述，本质是文本文件，体积小，并且不管放大多少倍都不会失真<br>1.SVG可直接插入页面中，成为DOM一部分，然后用JS或CSS进行操作</p>
<pre><code>    &lt;svg&gt;&lt;/svg&gt;
</code></pre>
<p>​    2.SVG可作为文件被引入<br>​        <img src="F:/BaiduNetdiskDownload/pic.svg" /><br>​    3.SVG可以转为base64引入页面</p>
<h4 id="33-了解过JWT吗？"><a href="#33-了解过JWT吗？" class="headerlink" title="33.了解过JWT吗？"></a>33.了解过JWT吗？</h4><p>​    JSON Web Token 通过JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输<br>​    信息传输、授权<br>​    JWT的认证流程<br>​    1.前端把账号密码发送给后端的接口<br>​    2.后端核对账号密码成功后，把用户id等其他信息作为JWT 负载，把它和头部分别进行base64编码拼接后签名，形成一个JWT（token）。<br>​    3.前端每日请求时都会把JWT放在HTTP请求头的Authorization字段内<br>​    4.后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期）<br>​    5.验证通过后后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果<br>​    简洁、包含性、因为Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何web形式都支持。</p>
<h4 id="34-npm的底层环境是什么？"><a href="#34-npm的底层环境是什么？" class="headerlink" title="34.npm的底层环境是什么？"></a>34.npm的底层环境是什么？</h4><p>​    node package manager,node的包管理和分发工具，已经成为分发node模块的标准，是JS的运行环境<br>​    npm的组成：网站、注册表、命令行工具</p>
<h4 id="35-HTTP协议规定的协议头和请求头有什么？"><a href="#35-HTTP协议规定的协议头和请求头有什么？" class="headerlink" title="35.HTTP协议规定的协议头和请求头有什么？"></a>35.HTTP协议规定的协议头和请求头有什么？</h4><p>​    1.请求头信息：<br>​        Accept:浏览器告诉服务器所支持的数据类型<br>​        Host:浏览器告诉服务器我想访问服务器的哪台主机<br>​        Referer:浏览器告诉服务器我是从哪里来的（防盗链）<br>​        User-Agent:浏览器类型、版本信息<br>​        Date:浏览器告诉服务器我是什么时候访问的<br>​        Connection:连接方式<br>​        Cookie<br>​        X-Request-With:请求方式<br>​    2.响应头信息：<br>​        Location:这个就是告诉浏览器你要去找谁<br>​        Server:告诉浏览器服务器的类型<br>​        Content-Type:告诉浏览器返回的数据类型<br>​        Refresh:控制了的定时刷新</p>
<h4 id="36-说一下浏览器的缓存策略。"><a href="#36-说一下浏览器的缓存策略。" class="headerlink" title="36.说一下浏览器的缓存策略。"></a>36.说一下浏览器的缓存策略。</h4><p>​    强缓存（本地缓存）、协商缓存（弱缓存）<br>​    强缓：不发起请求，直接使用缓存里的内容，浏览器把JS，CSS，image等存到内存中，下次用户访问直接从内存中取，提高性能<br>​    协缓：需要向后台发请求，通过判断来决定是否使用协商缓存，如果<strong>请求内容没有变化</strong>，则返回304，浏览器就用缓存里的内容<br>​    强缓存的触发：<br>​        HTTP1.0:时间戳响应标头<br>​        HTTP1.1:Cache-Control响应标头<br>​    协商缓存触发：<br>​        HTTP1.0:请求头：if-modified-since 响应头：last-modified<br>​        HTTP1.1:请求头：if-none-match 响应头：Etag</p>
<h4 id="37-说一下什么是“同源策略”？"><a href="#37-说一下什么是“同源策略”？" class="headerlink" title="37.说一下什么是“同源策略”？"></a>37.说一下什么是“同源策略”？</h4><p>​    http:&#x2F;&#x2F; www.  aaa.com:8080&#x2F;index&#x2F;vue.js<br>​    协议    子域名 主域名  端口号     资源<br>​    同源策略是浏览器的核心，如果没有这个策略就会遭受网络攻击<br>​    主要指的就是协议+域名+端口号三者一致，若其中一个不一样则不是同源，会产生跨域<br>​    三个允许跨域加载资源的标签：img  link  script<br>​    跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截了！<br>​    JSONP<br>​    CORS<br>​    websocket<br>​    反向代理</p>
<h4 id="38-防抖和节流是什么？"><a href="#38-防抖和节流是什么？" class="headerlink" title="38.防抖和节流是什么？"></a>38.防抖和节流是什么？</h4><p>​    都是应对页面中频繁触发事件的优化方案</p>
<ul>
<li>防抖:触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。应用场景：手机号、邮箱验证、搜索框输入。</li>
<li>节流:单位事件内（周期），频繁触发事件，只执行一次。应用场景:scroll事件</li>
</ul>
<h4 id="39-解释一下什么是json？"><a href="#39-解释一下什么是json？" class="headerlink" title="39.解释一下什么是json？"></a>39.解释一下什么是json？</h4><p>​    JSON是一种纯字符串形式的数据，它本身不提供任何方法，适合在网络中进行传输<br>​    JSON数据存储在.json文件中，也可以把JSON数据以字符串的形式保存在数据库、Cookise中<br>​    JS提供了JSON.parse() JSON.stringify()<br>​    什么时候使用json：定义接口；序列化；生成token；配置文件package.json</p>
<h4 id="40-当数据没有请求过来的时候，该怎么做？"><a href="#40-当数据没有请求过来的时候，该怎么做？" class="headerlink" title="40.当数据没有请求过来的时候，该怎么做？"></a>40.当数据没有请求过来的时候，该怎么做？</h4><p>​    可以在渲染数据的地方给一些默认的值<br>​    if判断语句</p>
<h4 id="41-有没有做过无感登录？"><a href="#41-有没有做过无感登录？" class="headerlink" title="41.有没有做过无感登录？***"></a>41.有没有做过无感登录？***</h4><p>1.解决方案<br>        无感登录实际上就是无感刷新 token。</p>
<blockquote>
<p>1.在响应器中拦截，判断 token 返回过期后，调用刷新 token 的接口。</p>
<p>2.后端返回过期时间，前端判断 token 的过期时间，去调用刷新 token 的接口。</p>
<p>3.写一个定时器，定时刷新 token。</p>
<p>我们常用的第一种方法实现无感登录。</p>
</blockquote>
<p>2.实现流程<br>1.登录流程</p>
<pre><code>    用户输入用户名和密码进行登录。

    后端验证用户信息，如果验证通过，返回一个 token 和 refresh_token。
    前端将 token 和 refresh_token 保存在本地（例如 localStorage）。
</code></pre>
<p>2.拦截响应</p>
<pre><code>    在前端，我们可以在响应拦截器中处理返回的响应。
    如果返回的状态码为401（未授权），说明 token 已经过期。
</code></pre>
<p>3.刷新 token</p>
<pre><code>    使用本地保存的 refresh_token 来请求新的 token。
    请求时可以携带当前 token 的过期时间，以便后端可以更精确地控制新 token 的过期时间。
</code></pre>
<p>4.替换 token</p>
<pre><code>    一旦新的 token 返回，前端将其保存，并替换本地旧的 token。
</code></pre>
<p>5.处理请求</p>
<pre><code>    前端将新的 token 放入未完成的请求中，并重新发送请求。
</code></pre>
<p>6.错误处理</p>
<pre><code>    如果 refresh_token 也过期了，那么需要重新登录。清除所有过期的 token，然后重新执行登录流程。
</code></pre>
<p>​    <strong>三种方法：</strong></p>
<ol>
<li><p>在响应器中拦截到401，判断token返回过期后，调用刷新token的接口</p>
</li>
<li><p>后端返回过期时间，前端判断token的过期时间，去调用刷新token的接口</p>
</li>
<li><p>前端写定时器，定时刷新token接口</p>
<p>方法1流程：</p>
<ol>
<li>登录成功后保存token 和 refresh_token</li>
<li>在响应拦截器中对401状态码引入刷新token的api方法调用</li>
<li>替换保存本地新的token</li>
<li>把错误对象里的token替换</li>
<li>再次发送未完成的请求</li>
<li>如果refresh_token过期了，判断是否过期，过期了就清除所有token重新登录</li>
</ol>
</li>
</ol>
<h4 id="42-大文件上传是怎么做的？"><a href="#42-大文件上传是怎么做的？" class="headerlink" title="42.大文件上传是怎么做的？"></a>42.大文件上传是怎么做的？</h4><p>​    分片上传：<br>​        1.把需要上传的文件按照一定的规则，分割成相同大小的数据块<br>​        2.初始化一个分片上传任务，返回本次分片上传的唯一标识<br>​        3.按照一定的规则把各个数据块上传<br>​        4.发送完成后，服务端会判断数据上传的完整性，如果完整，那么就会把数据库合并成原始文件<br>​    断点续传：<br>​        服务端返回，从哪里开始  浏览器自己处理</p>
<h4 id="43-var-const-let区别"><a href="#43-var-const-let区别" class="headerlink" title="43.var const let区别"></a>43.var const let区别</h4><ol>
<li>const let 是块级作用域，var没有块级作用域，var只有函数和全局作用域</li>
<li>var存在变量提升，const和let不存在变量声明提升。变量声明提升：变量提升是将变量声明提升到它所在作用域的最开始的部分，先调用再声明定义。</li>
<li>const let是ES6提出的，var是ES5</li>
<li>const 声明的是常量，常量不能被修改，let和var声明的是变量，可以被修改</li>
<li>const在声明时必须赋值，而let和var不需要</li>
<li>let 和const不能重复声明同一个值:如 let a&#x3D;1 ; let a &#x3D;2 这样是不被允许的，但var可以，最后一个var声明的值会覆盖之前的 如：var b &#x3D;1 ;var b &#x3D;2 console.log(b)  结果为2</li>
</ol>
<h4 id="44-和-的区别"><a href="#44-和-的区别" class="headerlink" title="44.&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别"></a>44.&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</h4><ul>
<li><p>‘’&#x3D;&#x3D;’’：类型不同，会尝试进行类型转换，将它们转换为同一类型后再进行比较值。</p>
</li>
<li><p>‘’&#x3D;&#x3D;&#x3D;’’：比较类型和值是否完全相同</p>
</li>
</ul>
<h4 id="45-定时器"><a href="#45-定时器" class="headerlink" title="45.定时器"></a>45.定时器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">setTimeOut</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line"></span><br><span class="line"> &#125;,i*<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：5 5 5 5</span></span><br></pre></td></tr></table></figure>

<h4 id="46-数组去重"><a href="#46-数组去重" class="headerlink" title="46.数组去重"></a>46.数组去重</h4><ol>
<li>用Set去重</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function unique (arr) &#123;</span><br><span class="line">  return Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">console.log(unique(arr))</span><br><span class="line">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>splice 去重</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;            </span><br><span class="line">        for(var i=0; i&lt;arr.length; i++)&#123;</span><br><span class="line">            for(var j=i+1; j&lt;arr.length; j++)&#123;</span><br><span class="line">                if(arr[i]===arr[j])&#123;         //第一个等同于第二个，splice方法删除第二个</span><br><span class="line">                    arr.splice(j,1);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    console.log(unique(arr))</span><br><span class="line">    //[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //NaN和&#123;&#125;没有去重，两个null直接消失了</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>sort()</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#x27;type error!&#x27;)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    arr = arr.sort()</span><br><span class="line">    var arrry= [arr[0]];</span><br><span class="line">    for (var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] !== arr[i-1]) &#123;</span><br><span class="line">            arrry.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arrry;</span><br><span class="line">&#125;</span><br><span class="line">     var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">        console.log(unique(arr))</span><br><span class="line">// [0, 1, 15, &quot;NaN&quot;, NaN, NaN, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, false, null, true, &quot;true&quot;, undefined]      //NaN、&#123;&#125;没有去重</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>利用 filter</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">  return arr.filter(function(item, index, arr) &#123;</span><br><span class="line">    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素</span><br><span class="line">    return arr.indexOf(item, 0) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">console.log(unique(arr))</span><br><span class="line">//[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span><br></pre></td></tr></table></figure>

<h4 id="47-怎么判断对象是否为空"><a href="#47-怎么判断对象是否为空" class="headerlink" title="47.怎么判断对象是否为空"></a>47.怎么判断对象是否为空</h4><ol>
<li><strong>使用<code>Object.keys()</code>方法</strong>：这个方法返回一个数组，包含对象自身的所有可枚举属性。通过判断返回的数组长度是否为0，可以确定对象是否为空。例如，<code>Object.keys(obj).length === 0</code> 如果为真，则对象为空。</li>
<li><strong>使用<code>JSON.stringify()</code>方法</strong>：将对象转换为JSON字符串，然后比较转换后的字符串是否等于<code>&#39;&#123;&#125;&#39;</code>。这种方法简单易行，但需要注意的是，<code>JSON.stringify()</code>只能序列化对象的可枚举自有属性，如果有不可枚举或继承属性，结果可能不准确。</li>
<li><strong>使用<code>Object.hasOwnPrototype()</code>方法</strong>：该方法用来判断指定对象自身是否含有某个属性（非继承）。通过检查对象是否具有特定的属性来判断其是否为空。</li>
<li><strong>使用<code>Object.getOwnPropertyNames()</code>方法</strong>：获取对象中的属性名并存到一个数组中，通过判断数组的长度来判断对象是否为空。这个方法可以检测到不可枚举的属性。</li>
<li><strong>使用<code>for..in</code>循环</strong>：通过遍历对象的属性，如果在循环体内没有找到任何属性，则可以认为对象为空。这种方法可以通过定义一个函数来实现，如果在循环中找到属性则返回<code>false</code>，否则返回<code>true</code>表示对象为空。</li>
</ol>
<h3 id="三、HTML5CSS3"><a href="#三、HTML5CSS3" class="headerlink" title="三、HTML5CSS3"></a>三、HTML5CSS3</h3><h4 id="1-语义化的理解。"><a href="#1-语义化的理解。" class="headerlink" title="1.语义化的理解。"></a>1.语义化的理解。</h4><p>​        在写HTML页面结构时所用的标签有意义<br>​        头部用head  主体用main  底部用foot…<br>​        怎么判断页面是否语义化了？<br>​            把CSS去掉，如果能够清晰的看出来页面结构，显示内容较为正常<br>​        为什么要选择语义化？<br>​            1.让HTML结构更加清晰明了<br>​            2.方便团队协作，利于开发<br>​            3.有利于爬虫和SEO<br>​            4.能够让浏览器更好的去解析代码<br>​            5.给用户带来良好的体验</p>
<h4 id="2-H5C3有哪些新特性？"><a href="#2-H5C3有哪些新特性？" class="headerlink" title="2.H5C3有哪些新特性？"></a>2.H5C3有哪些新特性？</h4><p>​        H5的新特性：<br>​            1.语义化的标签<br>​            2.新增音频视频<br>​            3.画布canvas<br>​            4.数据存储localstorage sessionstorage<br>​            5.增加了表单控件 email url search…<br>​            6.拖拽释放API<br>​        CSS3的新特性：<br>​            1.新增选择器：属性选择器、伪类选择器、伪元素选择器<br>​            2.增加了媒体查询<br>​            3.文字阴影<br>​            4.边框<br>​            5.盒子模型box-sizing<br>​            6.渐变<br>​            7.过度<br>​            8.自定义动画<br>​            9.背景的属性<br>​            10.2D和3D</p>
<h4 id="3-rem是如何做适配的？"><a href="#3-rem是如何做适配的？" class="headerlink" title="3.rem是如何做适配的？"></a>3.rem是如何做适配的？</h4><p>​        rem是相对长度，相对于根元素（html）的font-size属性来计算大小，通常来做移动端的适配<br>​        rem是根据根元素font-size计算值的倍数<br>​        比如html上的font-size:16px，给div设置宽为1.5rem,1.2rem &#x3D; 16px*1.2 &#x3D; 19.2px.</p>
<h4 id="4-解决了哪些移动端的兼容问题？"><a href="#4-解决了哪些移动端的兼容问题？" class="headerlink" title="4.解决了哪些移动端的兼容问题？"></a>4.解决了哪些移动端的兼容问题？</h4><p>​        1.当设置样式overflow:scroll&#x2F;auto时，IOS上的滑动会卡顿<br>​            -webkit-overflow-scrolling:touch;<br>​        2.在安卓环境下placeholder文字设置行高时会偏上<br>​            input有placeholder属性的时候不要设置行高<br>​        3.移动端字体小于12px时异常显示<br>​            应该先把在整体放大一倍，然后再用transform进行缩小<br>​        4.ios下input按钮设置了disabled属性为true显示异常<br>​            input[typy&#x3D;button]{<br>​                opcity:1<br>​            }<br>​        5.安卓手机下取消语音输入按钮<br>​            input::-webkit-input-speech-button{<br>​                display:none<br>​            }<br>​        6.IOS下取消input输入框在输入引文首字母默认大写<br>​            <input autocapitalize='off' autocorrect='off'/><br>​        7.禁用IOS和安卓用户选中文字<br>​            添加全局CSS样式：-webkit-user-select:none<br>​        8.禁止IOS弹出各种窗口<br>​            -webkit-touch-callout:none<br>​        9.禁止IOS识别长串数字为电话<br>​            添加meta属性 <meta conten='telephone=no' name='format-detection'></p>
<h3 id="四、Vue"><a href="#四、Vue" class="headerlink" title="四、Vue"></a>四、Vue</h3><h4 id="1-v-if和v-show的区别？"><a href="#1-v-if和v-show的区别？" class="headerlink" title="1.v-if和v-show的区别？"></a>1.v-if和v-show的区别？</h4><p>​        都可以控制元素的显示和隐藏<br>​        1.控制手段：v-show时控制元素的display值来让元素显示和隐藏，DOM元素依旧还在；v-if显示隐藏时把DOM元素整个添加和删除；<br>​        2.编译过程：v-if有一个局部编译&#x2F;卸载的过程，切换这个过程中会适当的销毁和重建内部的<strong>事件监听和子组件</strong>；v-show只是简单的css切换；<br>​        3.编译条件：v-if才是真正的条件渲染，它会确保在切换过程中条件块内的<strong>事件监听器和子组件</strong>适当地被销毁和重建；v-show从false变成true的时候不会触发组件的生命周期，v-if会触发生命周期；<br>​        4.<code>v-if</code>有更高的切换消耗；<code>v-show</code>有更高的初始渲染消耗；</p>
<blockquote>
<p>如果需要在条件切换频繁的情况下，可以使用v-show来避免频繁的创建和销毁组件或元素，提高性能。</p>
<p>如果需要在条件切换较少的情况下，可以使用v-if来在条件为假时减少不必要的渲染，节省内存。</p>
</blockquote>
<h4 id="2-如何理解MVVM的？"><a href="#2-如何理解MVVM的？" class="headerlink" title="2.如何理解MVVM的？"></a>2.如何理解MVVM的？</h4><p>​        是Model-View-ViewModel的缩写。前端开发的架构模式<br>​        M：模型，对应的就是data的数据<br>​        V：视图，用户界面，DOM<br>​        VM：视图模型：Vue的实例对象，连接View和Model的桥梁<br>​        核心是提供对View和ViewModel的双向数据绑定，当数据改变的时候，ViewModel能监听到数据的变化，自动更新视图，当用户操作视图的时候，ViewModel也可以监听到视图的变化，然后通知数据进行改动，这就实现了双向数据绑定<br>​        ViewModel通过双向绑定把View和Model连接起来，他们之间的同步是自动的，不需要认为干涉，所以我们只需要关注业务逻辑即可，不需要操作DOM，同时也不需要关注数据的状态问题，因为她是由MVVM统一管理</p>
<h4 id="3-v-for中的key值的作用是什么？"><a href="#3-v-for中的key值的作用是什么？" class="headerlink" title="3.v-for中的key值的作用是什么？"></a>3.v-for中的key值的作用是什么？</h4><p>​        key属性是DOM元素的唯一标识<br>​        作用：<br>​            1.提高虚拟DOM的更新<br>​            2.若不设置key，可能会触发一些bug。key属性可以避免数据混乱的情况出现 （如果元素中包含了有临时数据的元素，如果不用key就会产生数据混乱）<br>​            3.为了触发过渡效果</p>
<h4 id="4-说一下你对vue生命周期的理解。"><a href="#4-说一下你对vue生命周期的理解。" class="headerlink" title="4.说一下你对vue生命周期的理解。"></a>4.说一下你对vue生命周期的理解。</h4><p>​        组件从创建到销毁的过程就是它的生命周期<br>​        <strong>创建</strong><br>​            beforeCreat<br>​                在这个阶段<strong>属性和方法</strong>都不能使用<br>​            created<br>​                这里时实例创建完成之后，在这里完成了数据监测，可以使用数据，修改数据，不会触发updated，也不会更新视图<br><strong>​        挂载</strong><br>​            beforeMount<br>​                完成了模板的编译，虚拟DOM也完成创建，即将渲染，修改数据，不会触发updated<br>​            Mounted<br>​                把编译好的模板挂载到页面，这里可以发送异步请求也可以访问DOM节点<br><strong>​        更新</strong><br>​            beforeUpdate<br>​                组件数据更新之前使用，数据是新的，页面上的数据时旧的，组件即将更新，准备渲染，可以改数据<br>​            updated<br>​                render重新做了渲染，这时数据和页面都是新的，避免在此更新数据<br>​        <strong>销毁</strong><br>​            beforeDestroy<br>​                实例销毁前，在这里实例还可以用，可以清楚定时器等等<br>​            destroyed<br>​                组件已经被销毁了，全部都销毁<br>​        使用了keep-alive时多出两个周期：<br>​            activited<br>​                组件激活时<br>​            deactivited<br>​                组件被销毁时</p>
<p>​	errorCaptured</p>
<h4 id="5-在created和mounted去请求数据，有什么区别？"><a href="#5-在created和mounted去请求数据，有什么区别？" class="headerlink" title="5.在created和mounted去请求数据，有什么区别？"></a>5.在created和mounted去请求数据，有什么区别？</h4><p>​        created：<strong>在渲染前调用</strong>，通常先初始化属性，然后做渲染<br>​        mounted：<strong>在模板渲染完成后</strong>，一般都是初始化页面后，在对元素节点进行操作<br>​                <strong>在这里请求数据可能会出现闪屏的问题，created里不会</strong><br>​        一般用created比较多<br>​        1.请求的数据对DOM有影响，那么使用created<br>​        2.如果请求的数据对DOM无关，可以放在mounted</p>
<h4 id="6-vue中的修饰符有哪些？"><a href="#6-vue中的修饰符有哪些？" class="headerlink" title="6.vue中的修饰符有哪些？"></a>6.vue中的修饰符有哪些？</h4><p>​        1.事件修饰符<br>​            .stop       阻止冒泡<br>​            .prevent    阻止默认行为<br>​            .capture    内部元素触发的事件先在次处理<br>​            .self       只有在event.target是当前元素时触发<br>​            .once       事件只会触发一次<br>​            .passive    立即触发默认行为<br>​            .native     把当前元素作为原生标签看待<br>​        2.按键修饰符<br>​            .keyup      键盘抬起<br>​            .keydown    键盘按下<br>​        3.系统修饰符<br>​            .ctrl<br>​            .alt<br>​            .meta<br>​        4.鼠标修饰符<br>​            .left       鼠标左键<br>​            .right      鼠标右键<br>​            .middle     鼠标中键<br>​        5.表单修饰符<br>​            .lazy       等输入完之后再显示<br>​            .trim       删除内容前后的空格<br>​            .number     输入是数字或转为数字</p>
<h4 id="7-elementui是怎么做表单验证的？"><a href="#7-elementui是怎么做表单验证的？" class="headerlink" title="7.elementui是怎么做表单验证的？"></a>7.elementui是怎么做表单验证的？</h4><p>​        1.在表单中加rules属性，然后再data里写校验规则<br>​        2.内部添加规则<br>​        3.自定义函数校验</p>
<h4 id="8-vue如何进行组件通信-组件传参？"><a href="#8-vue如何进行组件通信-组件传参？" class="headerlink" title="8.vue如何进行组件通信,组件传参？"></a>8.vue如何进行组件通信,组件传参？</h4><p>​        1.父传子<br>​            props<br>​                父组件使用自定义属性，然后子组件使用props<br>​            $ref<br>​                引用信息会注册在父组件的$refs对象上<br>​        2.子传父<br>​            $emit<br>​                子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数<br>​        3.兄弟传<br>​            new一个新的vue实例，用on和emit来对数据进行传输<br>​        4.vuex传值</p>
<p>​	5.任意组件间：provide&#x2F;inject</p>
<h4 id="9-keep-alive是什么？怎么使用？"><a href="#9-keep-alive是什么？怎么使用？" class="headerlink" title="9.keep-alive是什么？怎么使用？"></a>9.keep-alive是什么？怎么使用？</h4><p>​        Vue的一个内置组件，包裹组件的时候，会缓存不活跃的组件实例，并不是销毁他们<br>​        作用：把组件切换的状态保存在内存里，防止重复渲染DOM节点，减少<strong>加载时间和性能消耗</strong>，提高用户体验</p>
<blockquote>
<p>使用了keep-alive时多出两个周期：<br>activited：组件激活时<br>deactivited：组件被销毁时</p>
</blockquote>
<h4 id="10-axios是怎么做封装的？"><a href="#10-axios是怎么做封装的？" class="headerlink" title="10.axios是怎么做封装的？"></a>10.axios是怎么做封装的？</h4><p>​        下载 创建实例 接着封装请求，响应拦截器  抛出 最后封装接口</p>
<h4 id="11-vue路由时怎么传参的？"><a href="#11-vue路由时怎么传参的？" class="headerlink" title="11.vue路由时怎么传参的？"></a>11.vue路由时怎么传参的？</h4><p>​	1.params传参<br>​            this.$router.push({name:’index’,params:{id:item.id}})<br>​            this.$route.params.id<br>​        2.路由属性传参<br>​            this.$router.push({name:’&#x2F;index&#x2F;${item.id}’})<br>​            路由配置 { path:’&#x2F;index:id’ }<br>​        3.query传参（可以解决页面刷新参数丢失的问题）<br>​            this.$router.push({<br>​                name:’index’,<br>​                query:{id:item.id}<br>​            })</p>
<h4 id="12-vue路由的hash模式和history模式有什么区别？"><a href="#12-vue路由的hash模式和history模式有什么区别？" class="headerlink" title="12.vue路由的hash模式和history模式有什么区别？***"></a>12.vue路由的hash模式和history模式有什么区别？***</h4><p><strong>1. URL 结构</strong></p>
<ul>
<li><strong>history：</strong> 使用实际的 URL 路径，例如 “&#x2F;about”。</li>
<li><strong>hash：</strong> 在 URL 的末尾使用哈希 (#) 符号，例如 “&#x2F;#about”。</li>
</ul>
<p><strong>2. 浏览器历史</strong></p>
<ul>
<li><strong>history：</strong> 会修改浏览器历史记录，允许用户使用后退和前进按钮在页面之间导航。</li>
<li><strong>hash：</strong> 不会修改浏览器历史记录，用户使用后退和前进按钮时会停留在同一页面。</li>
</ul>
<p><strong>3. 刷新行为</strong></p>
<ul>
<li><strong>history：</strong> 刷新页面会导致一个新的请求，服务器将渲染整个页面。</li>
<li><strong>hash：</strong> 刷新页面不会触发服务器请求，浏览器只重新加载当前页面。</li>
</ul>
<p><strong>4. 搜索引擎友好性</strong></p>
<ul>
<li><strong>history：</strong> 对搜索引擎友好，因为 URL 中包含有意义的信息。</li>
<li><strong>hash：</strong> 对搜索引擎不友好，因为哈希部分不会被搜索引擎识别。</li>
</ul>
<p><strong>5. 兼容性</strong></p>
<ul>
<li><strong>history：</strong> 需要 HTML5 History API 支持，在大多数现代浏览器中都有。</li>
<li><strong>hash：</strong> 兼容性好，可以在所有支持 JavaScript 的浏览器中使用。</li>
</ul>
<p>​	1.hash的路由地址上有#号，history模式没有<br>​        2.在做回车刷新的时候，hash模式会加载对应页面，history会报错404<br>​        3.hash模式支持低版本浏览器，history不支持，因为是H5新增的API<br>​        4.hash不会重新加载页面，单页面应用必备<br>​        5.history有历史记录，H5新增了pushState和replaceState()去修改历史记录，并不会立刻发送请求<br>​        6.history需要后台配置</p>
<h4 id="13-路由拦截是怎么实现的？"><a href="#13-路由拦截是怎么实现的？" class="headerlink" title="13.路由拦截是怎么实现的？"></a>13.路由拦截是怎么实现的？</h4><p>​        路由拦截 axios拦截<br>​        需要在路由配置中添加一个字段，它是用于判断路由是否需要拦截</p>
<pre><code>&#123;
            name:&#39;index&#39;,
            path:&#39;/index&#39;,
            component:Index,
            meta:&#123;
                requirtAuth:true
            &#125;
        &#125;
        router.beforeEach((to,from,next) =&gt; &#123;
            if(to.meta.requirtAuth)&#123;
                if( store.satte.token )&#123;
                    next()
                &#125;else&#123;
                    &#125;
    &#125;
&#125;)
</code></pre>
<h4 id="14-说一下vue的动态路由。"><a href="#14-说一下vue的动态路由。" class="headerlink" title="14.说一下vue的动态路由。"></a>14.说一下vue的动态路由。</h4><p>​    要在路由配置里设置<code>meat</code>属性，扩展权限相关的字段，在路由导航守卫<code>router.beforeEach</code>里通过判断这个权限标识，实现路由的动态增加和跳转。<br>​    根据用户登录的账号，返回用户角色<br>​    前端再根据角色，跟路由表的meta.role进行匹配<br>​    把匹配搭配的路由形成可访问的路由</p>
<h4 id="15-如何解决刷新后二次加载路由？"><a href="#15-如何解决刷新后二次加载路由？" class="headerlink" title="15.如何解决刷新后二次加载路由？"></a>15.如何解决刷新后二次加载路由？</h4><p>​    1.window.location.reload()<br>​    2.matcher<br>​        const router &#x3D; createRouter()<br>​        export function resetRouter(){<br>​            const newRouter &#x3D; creatRouter()<br>​            router.matcher &#x3D; newRouter.matcher<br>​        }</p>
<h4 id="16-vuex刷新数据会丢失吗？怎么解决？"><a href="#16-vuex刷新数据会丢失吗？怎么解决？" class="headerlink" title="16.vuex刷新数据会丢失吗？怎么解决？"></a>16.vuex刷新数据会丢失吗？怎么解决？</h4><p>​    vuex肯定会重新获取数据，页面也会丢失数据<br>​    1.把数据直接保存在浏览器缓存里（cookie  localstorage  sessionstorage）<br>​    2.页面刷新的时候，再次请求数据，达到可以动态更新的方法<br>​        监听浏览器的刷新书简，在刷新前把数据保存到sessionstorage里，刷新后请求数据，请求到了用vuex，如果没有那就用sessionstorage里的数据</p>
<h4 id="17-computed和watch的区别？"><a href="#17-computed和watch的区别？" class="headerlink" title="17.computed和watch的区别？"></a>17.computed和watch的区别？</h4><ol>
<li><p>computed是计算属性，其依赖data的数据；watch是监听，监听data中的数据变化。</p>
</li>
<li><p>原理不同</p>
<p>computed第一次加载时就监听；watch默认第一次加载时不监听。immediate设置成true时，第一次加载才会监听</p>
</li>
<li><p>是否支持缓存<br>computed支持缓存，当其依赖的属性的值发生变化时，计算属性会重新计算，反之，则使用缓存中的属性值；</p>
<p>watch不支持缓存，当对应属性发生变化的时候，响应执行。</p>
</li>
<li><p>是否支持异步<br>computed不支持异步，当computed内有异步操作时是无法监听数据变化的；<br>watch支持异步操作</p>
</li>
<li><p>使用场景不同<br>computed擅长处理的场景是：多个数据影响一个数据 —-购物车商品结算。<br>watch擅长处理的场景是：一个数据变化影响多个数据。—-搜索框。</p>
</li>
</ol>
<h4 id="18-vuex在什么场景会去使用？属性有哪些？"><a href="#18-vuex在什么场景会去使用？属性有哪些？" class="headerlink" title="18.vuex在什么场景会去使用？属性有哪些？"></a>18.vuex在什么场景会去使用？属性有哪些？</h4><p>​    state       存储变量<br>​    getters     state的计算属性<br>​    mutations   提交更新数据的方法<br>​    actions     和mutations差不多，他是提交mutations来修改数据，可以包括异步操作<br>​    modules     模块化vuex<br>​    使用场景：<br>​        用户的个人信息、购物车模块、订单模块</p>
<p><strong>mutaion和action的区别：</strong></p>
<p>action的功能和mutation是类似的，都是去变更store里的state，不过action和mutation有两点不同：</p>
<ol>
<li><p>action主要处理的是异步的操作，mutation必须同步执行，而action就不受这样的限制，也就是说action中我们既可以处理同步，也可以处理异步的操作</p>
</li>
<li><p>action改变状态，最后是通过提交mutation</p>
</li>
</ol>
<h4 id="19-vue的双向数据绑定原理是什么？"><a href="#19-vue的双向数据绑定原理是什么？" class="headerlink" title="19.vue的双向数据绑定原理是什么？***"></a>19.vue的双向数据绑定原理是什么？***</h4><blockquote>
<p>Vue2的双向数据绑定原理：‌通过<code>Object.defineProperty()</code>方法实现数据劫持，‌为每个属性定义<code>getter</code>和<code>setter</code>方法，‌从而监听数据的变化。‌当数据变化时，‌<code>setter</code>方法会被触发，‌进而通知视图更新。‌同时，‌Vue2使用发布-订阅模式来管理组件之间的通信，‌确保所有组件都能接收到更新的通知并及时响应变化。‌</p>
</blockquote>
<blockquote>
<p>Vue3则采用<strong>Proxy</strong>对象来实现响应式系统，‌Proxy允许拦截并定义JavaScript对象的默认行为，‌从而对数据的读取和更新进行拦截，‌并在数据变化时自动触发依赖关系的更新操作，‌实现双向数据绑定。‌这种方式比Vue2的数据劫持更加灵活和强大。‌</p>
</blockquote>
<p>​    通过<strong>数据劫持和发布订阅者模式</strong>来实现，同时利用Object.defineProperty()劫持各个属性的setter和getter，<br>​    在数据发生改变的时候发布消息给订阅者，触发对应的监听回调渲染视图，也就是说数据和视图时同步的，数据发生改变，视图跟着发生改变，视图改变，数据也会发生改变。<br>​    第一步：需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter<br>​    第二步：compile模板解析指令，把模板中的变量替换成数据，然后初始化渲染视图，同时把每个指令对应的节点绑定上更新函数，添加订阅者，如果数据变化，收到通知，更新视图<br>​    第三步：Watcher订阅者是Observer和Compile之间的通信桥梁，作用：<br>​            1.在自身实例化的时候忘订阅器内添加自己<br>​            2.自身要有一个update()方法<br>​            3.等待属性变动时，调用自身的update方法，触发compile这种的回调<br>​    第四步：MVVM作为数据绑定的入口，整合了observer、compile和watcher三者，通过observer来监听自己的数据变化，通过compile解析模板指令，最后利用watcher把observer和compile联系起来，最终达到数据更新视图更新，视图更新数据更新的效果</p>
<p>v-model:</p>
<p><code>&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;</code>等价于<code>&lt;input :value=&quot;message&quot; @input=&quot;message = $event.target.value&quot;&gt;</code></p>
<p><code>&lt;check v-model=&quot;message&quot;&gt;</code>:value @change</p>
<h4 id="20-了解diff算法和虚拟DOM吗？"><a href="#20-了解diff算法和虚拟DOM吗？" class="headerlink" title="20.了解diff算法和虚拟DOM吗？"></a>20.了解diff算法和虚拟DOM吗？</h4><p>​    虚拟DOM，描述元素和元素之间的关系，创建一个JS对象<br>​    如果组件内有响应的数据，数据发生改变的时候，render函数会生成一个新的虚拟DOM，这个新的虚拟DOM会和旧的虚拟DOM进行比对，找到需要修改的虚拟DOM内容，然后去对应的真实DOM中修改<br>​    diff算法就是虚拟DOM的比对时用的，返回一个patch对象，这个对象的作用就是存储两个节点不同的地方，最后用patch里记录的信息进行更新真实DOM<br>​    步骤：<br>​        1.JS对象表示真实的DOM结构，要生成一个虚拟DOM，再用虚拟DOM构建一个真实DOM树，渲染到页面<br>​        2.状态改变生成新的虚拟DOM，跟就得虚拟DOM进行比对，这个比对的过程就是DIFF算法，利用patch记录差异<br>​        3.把记录的差异用在第一个虚拟DOM生成的真实DOM上，视图就更新了。</p>
<h4 id="21-vue和jquery的区别是什么？"><a href="#21-vue和jquery的区别是什么？" class="headerlink" title="21.vue和jquery的区别是什么？"></a>21.vue和jquery的区别是什么？</h4><p>​    1.原理不同<br>​        vue就是数据绑定；jq是先获取dom再处理<br>​    2.着重点不同<br>​        vue是数据驱动，jq是着重于页面<br>​    3.操作不同<br>​    4.未来发展不同</p>
<h4 id="22-vuex的响应式处理。"><a href="#22-vuex的响应式处理。" class="headerlink" title="22.vuex的响应式处理。"></a>22.vuex的响应式处理。</h4><p>​    vuex是vue的状态管理工具<br>​    vue中可以直接触发methods中的方法，vuex是不可以的。未来处理异步，当触发事件的时候，会通过dispatch来访问actions中的方法，actions中的commit会触发mutations中的方法从而修改state里的值，通过getter把数据更新到视图<br>​    Vue.use(vuex)，调用install方法，通过applyMixin(vue)在任意组件内执行this.$store就可以访问到store对象。<br>​    vuex的state是响应式的，借助的就是vue的data，把state存到vue实例组件的data中</p>
<h4 id="23-vue中遍历全局的方法有哪些？"><a href="#23-vue中遍历全局的方法有哪些？" class="headerlink" title="23.vue中遍历全局的方法有哪些？"></a>23.vue中遍历全局的方法有哪些？</h4><p>​    1.普通遍历，对象.forEach()<br>​        arr.forEach(function(item,index,arr){<br>​            console.log(item,index)<br>​        })<br>​    2.对元素统一操作  对象.map()<br>​        var newarr &#x3D; arr.map(function(item){<br>​            return item+1<br>​        })<br>​    3.查找符合条件的元素 对象.filter()<br>​        arr.filter(function(item){<br>​            if(item &gt; 2){<br>​                return false<br>​            }else{<br>​                return true<br>​            }<br>​        })<br>​    4.查询符合条件的元素，返回索引 对象.findindex()<br>​        arr.finindex(function(item){<br>​            if(item&gt;1){<br>​                return true<br>​            }else{<br>​                return false<br>​            }<br>​        })<br>​    对象.evening()  遇到不符合的对象会停止<br>​    对象.some()  找到符合条件的元素就停止</p>
<h4 id="24-如何搭建脚手架？"><a href="#24-如何搭建脚手架？" class="headerlink" title="24.如何搭建脚手架？"></a>24.如何搭建脚手架？</h4><p>​    下载：node  cnpm  webpack vue-cli<br>​    创建项目：<br>​        1.找到对应的文件，然后利用node指令创建（cmd）<br>​        2.vue init webpack xxxx<br>​        3.回车项目描述<br>​        4.作者回车<br>​        5.选择vue build<br>​        6.回车<br>​        7.输入n<br>​        8.不按照yarn<br>​        9.输入npm run dev</p>
<h4 id="25-如何封装一个组件？"><a href="#25-如何封装一个组件？" class="headerlink" title="25.如何封装一个组件？"></a>25.如何封装一个组件？</h4><p>​    1.使用Vue.extend()创建一个组件<br>​    2.使用Vue.components()方法注册组件<br>​    3.如果子组件需要数据，可以在props中接收定义<br>​    4.子组件修改好数据，要把数据传递给父组件，可以用emit()方法<br>​    原则：<br>​        把功能拆开<br>​        尽量让组件原子化，一个组件做一件事情<br>​        容器组件管数据，展示组件管视图</p>
<h4 id="26-封装一个可复用的组件，需要满足什么条件？"><a href="#26-封装一个可复用的组件，需要满足什么条件？" class="headerlink" title="26.封装一个可复用的组件，需要满足什么条件？"></a>26.封装一个可复用的组件，需要满足什么条件？</h4><p>​    1.低耦合，组件之间的依赖越小越好<br>​    2.最好从父级传入信息，不要在公共组件中请求数据<br>​    3.传入的数据要进行校验<br>​    4.处理事件的方法写在父组件中</p>
<h4 id="27-vue的过滤器怎么使用？"><a href="#27-vue的过滤器怎么使用？" class="headerlink" title="27.vue的过滤器怎么使用？"></a>27.vue的过滤器怎么使用？</h4><p>​    vue的特性，用来对文本进行格式化处理<br>​    使用它的两个地方，一个是插值表达式，一个是v-bind<br>​    分类：<br>​        1.全局过滤器<br>​            Vue.filter(‘add’,function(v){<br>​                return v &lt; 10 ? ‘0’ + v : v<br>​            })</p>
<pre><code>        &lt;div&gt;&#123;&#123;33 | add&#125;&#125;&lt;/div&gt;
</code></pre>
<p>​        2.本地过滤器<br>​            和methods同级<br>​            filter:{<br>​                add:function(v){<br>​                    return v &lt; 10 ? ‘0’ + v : v<br>​                }<br>​            }</p>
<h4 id="28-vue中如何做强制刷新？"><a href="#28-vue中如何做强制刷新？" class="headerlink" title="28.vue中如何做强制刷新？"></a>28.vue中如何做强制刷新？</h4><p>​    1.localtion.reload()<br>​    2.this.$router.go(0)<br>​    3.provide和inject</p>
<h4 id="29-vue3和vue2有哪些区别？"><a href="#29-vue3和vue2有哪些区别？" class="headerlink" title="29.vue3和vue2有哪些区别？"></a>29.vue3和vue2有哪些区别？</h4><p>​    <strong>1.双向数据绑定的原理不同</strong>,vue2:defineProperty,vue3:proxy<br>​    2.是否支持碎片<br>​    3.API不同<br>​    <strong>4.定义数据变量方法不同</strong><br>​    <strong>5.生命周期的不同</strong><br>​    6.传值不同<br>​    7.指令和插槽不同<br>​    <strong>8.main.js不同</strong></p>
<h4 id="30-vue的性能优化怎么做？"><a href="#30-vue的性能优化怎么做？" class="headerlink" title="30.vue的性能优化怎么做？"></a>30.vue的性能优化怎么做？</h4><p>​    1.编码优化</p>
<ul>
<li>不要把所有数据都放在data中</li>
<li>v-for时给每个元素绑定事件用事件代理</li>
<li>keep-alive缓存组件</li>
<li>尽可能拆分组件，提高复用性、维护性</li>
<li>key值要保证唯一</li>
<li>合理使用路由懒加载，异步组件</li>
<li>数据持久化存储的使用尽量用防抖、节流优化</li>
</ul>
<p>​    2.加载优化<br>​        按需加载<br>​        内容懒加载<br>​        图片懒加载<br>​    3.用户体验<br>​        骨架屏<br>​    4.SEO优化<br>​        预渲染<br>​        服务端渲染ssr<br>​    5.打包优化<br>​        CDN形式加载第三方模块<br>​        多线程打包<br>​        抽离公共文件<br>​    6.缓存和压缩<br>​        客户端缓存、服务端缓存<br>​        服务端Gzip压缩</p>
<h4 id="31-首屏优化该如何去做？"><a href="#31-首屏优化该如何去做？" class="headerlink" title="31.首屏优化该如何去做？"></a>31.首屏优化该如何去做？</h4><p>​    1.使用路由懒加载<br>​    2.非首屏组件使用异步组件<br>​    3.首屏不中要的组件延迟加载<br>​    4.静态资源放在CDN上<br>​    5.减少首屏上JS、CSS等资源文件的大小<br>​    6.使用服务端渲染<br>​    7.简历减少DOM的数量和层级<br>​    8.使用精灵图请求<br>​    9.做一些loading<br>​    10.开启Gzip压缩<br>​    11.图片懒加载</p>
<h4 id="32-vue3的性能为什么比vue2好？"><a href="#32-vue3的性能为什么比vue2好？" class="headerlink" title="32.vue3的性能为什么比vue2好？"></a>32.vue3的性能为什么比vue2好？</h4><p>​    1.diff算法的优化<br>​    2.静态提升<br>​    3.事件侦听缓存</p>
<h4 id="33-vue3为什么使用proxy？"><a href="#33-vue3为什么使用proxy？" class="headerlink" title="33.vue3为什么使用proxy？***"></a>33.vue3为什么使用proxy？***</h4><p>​    1.proxy可以代理整个对象，defineproperty(vue2)只代理对象上的某个属性，不需要遍历了，效率更高。<br>​    2.proxy对代理对象的监听更加丰富<br>​    3.proxy代理对象会生成新的对象，不会修改被代理对象本身<br>​    4.proxy不兼容ie浏览器</p>
<h4 id="34-说一下你对组件的理解。"><a href="#34-说一下你对组件的理解。" class="headerlink" title="34.说一下你对组件的理解。"></a>34.说一下你对组件的理解。</h4><p>​    可以重复使用的vue实例，独一无二的组件名称<br>​    可以抽离单独的公共模块<br>​    提高代码的复用率</p>
<h4 id="35-你是如何规划项目文件的？"><a href="#35-你是如何规划项目文件的？" class="headerlink" title="35.你是如何规划项目文件的？"></a>35.你是如何规划项目文件的？</h4><p>​    public<br>​        图标、index.html、img<br>​    src<br>​        api<br>​        assets<br>​        components<br>​            按分类再次划分子目录<br>​        plugins<br>​        router<br>​        static<br>​        styles<br>​        utils<br>​        views<br>​    App.vue<br>​    main.js<br>​    package.json<br>​    vue.config.js</p>
<h4 id="36-是否使用过nuxt-js？"><a href="#36-是否使用过nuxt-js？" class="headerlink" title="36.是否使用过nuxt.js？"></a>36.是否使用过nuxt.js？</h4><p>​    是基于vue的应用框架，关注的是渲染，可以开发服务端渲染应用的配置<br>​    SSR：服务端渲染<br>​        好处：<br>​            SSR生成的是有内容的HTML页面，有利于搜索引擎的搜索<br>​            优化了首屏加载时间<br>​    SEO：优化搜索引擎<br>​    SPA的应用不利于搜索引擎SEO的操作</p>
<h4 id="37-SEO如何优化？"><a href="#37-SEO如何优化？" class="headerlink" title="37.SEO如何优化？"></a>37.SEO如何优化？</h4><p>​    1.SSR<br>​    2.预渲染 prerender-spa-plugin</p>
<h4 id="38-什么是跨域？跨域的原因？解决方法"><a href="#38-什么是跨域？跨域的原因？解决方法" class="headerlink" title="38. 什么是跨域？跨域的原因？解决方法"></a>38. 什么是跨域？跨域的原因？解决方法</h4><ul>
<li><p><em>当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</em>。<em>指的是在网页端,发起一个跨越不同域名(协议、端口号)的HTTP请求的过程</em>。</p>
</li>
<li><p>跨域问题是指由于浏览器的<strong>同源策略</strong>(协议、域名、端口)导致的不同域之间的通信限制。主要是防止 csrf 攻击</p>
</li>
<li><p>前端解决方法（vue）配置代理</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//vite.config.js</span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">	plugins:[vue()],</span><br><span class="line">	server:&#123;</span><br><span class="line">		proxy:&#123;</span><br><span class="line">			&quot;/api&quot;:&#123;</span><br><span class="line">				target:&quot;http://localhost:80&quot;, //转到&quot;http://localhost:80&quot;</span><br><span class="line">				changeOrigin:true,</span><br><span class="line">				rewrite:(path) =&gt; path.replace(/^\/api/,&quot;&quot;) //删除替换&#x27;/api&#x27;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="39-nextTick"><a href="#39-nextTick" class="headerlink" title="39. nextTick()"></a>39. nextTick()</h4><p>作用：在下一次DOM节点更新完后执行其指定的回调</p>
<p>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$nextTick(function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="40-vuex-pinia区别"><a href="#40-vuex-pinia区别" class="headerlink" title="40.vuex pinia区别"></a>40.vuex pinia区别</h4><ol>
<li><p>Vuex选项式api，pinia组合式api，更灵活</p>
</li>
<li><p><strong>状态管理方式</strong>：</p>
<p>Vuex采用全局单例模式，通过一个store对象来管理所有的状态，组件通过store对象来获取和修改状态。而Pinia采用了分离模式，即每个组件都拥有自己的store实例，通过在组件中创建store实例来管理状态。</p>
</li>
<li><p><strong>数据修改方式</strong>：</p>
<p>Vuex通过mutations来修改状态，而Pinia没有mutations，它只有state、getters和actions（同步、异步）来使用它来修改state数据。</p>
</li>
<li><p>Vuex支持模块化，通过modules配置来组织状态。而Pinia没有modules配置，每一个独立的仓库都是definStore生成出来的</p>
</li>
<li><p>Vuex对TypeScript的支持不完整，而Pinia做到了完整的TypeScript支持，这使其与TypeScript更加兼容和友好，提供了更清晰的类型定义。</p>
</li>
</ol>
<h4 id="41-数据（事件）改变之后发起请求，请求放在哪个监听属性比较合适，watch、computed，为什么"><a href="#41-数据（事件）改变之后发起请求，请求放在哪个监听属性比较合适，watch、computed，为什么" class="headerlink" title="41.数据（事件）改变之后发起请求，请求放在哪个监听属性比较合适，watch、computed，为什么"></a>41.数据（事件）改变之后发起请求，请求放在哪个监听属性比较合适，watch、computed，为什么</h4><p>为什么选择<code>watch</code>而不是<code>computed</code>：</p>
<ol>
<li><strong><code>watch</code>的用途</strong>：<br><code>watch</code>用于观察和响应Vue实例上数据的变动。当指定的数据变化时，你可以执行异步操作或开销较大的操作，比如发送网络请求。<code>watch</code>非常适合执行副作用或异步操作，这些操作不应该在<code>computed</code>属性中执行，因为<code>computed</code>属性应该是同步的，并且基于它们的依赖进行缓存。</li>
<li><strong><code>computed</code>的用途</strong>：<br><code>computed</code>计算属性主要被用作声明式的描述一些依赖其它响应式属性的值。它们是基于它们的依赖进行缓存的，只有当依赖项发生改变时，<code>computed</code>属性才会重新计算。由于它们是基于响应式依赖进行缓存的，所以它们适合执行同步操作，并且不需要进行副作用（如网络请求）或执行开销较大的操作。</li>
<li><strong>异步操作和副作用</strong>：<br>如前所述，当数据变化需要执行异步操作（如API请求）时，使用<code>watch</code>是更合适的选择。这是因为<code>watch</code>允许你定义当被观察的数据变化时应该执行的回调函数，这个回调函数可以是异步的，比如发送HTTP请求。而<code>computed</code>属性则不适合执行异步操作，因为它们的设计初衷是同步的，并且基于依赖的缓存机制。</li>
</ol>
<h4 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h4><h4 id="1-TCP三次握手，为什么要握手三次，两次不行"><a href="#1-TCP三次握手，为什么要握手三次，两次不行" class="headerlink" title="1.TCP三次握手，为什么要握手三次，两次不行"></a>1.TCP三次握手，为什么要握手三次，两次不行</h4><ol>
<li><p>第一次握手：客户端向服务器发出连接请求报文</p>
</li>
<li><p>第二次握手：TCP服务器收到请求报文后，如果同意连接，则发出确认报文。</p>
</li>
<li><p>第三次握手：TCP客户进程收到确认后，还要向服务器给出确认。</p>
</li>
</ol>
<p><strong>已失效的连接请求报文段。</strong></p>
<ul>
<li>client发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server。</li>
<li>本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接。</li>
<li>假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求</li>
<li>但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了</li>
</ul>
<p>采用三次握手就是为了防止这种情况的发生，server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。</p>
<blockquote>
<p>客户端发生请求报文，但是这个请求报文由于某些原因失效了。</p>
<p>服务端接收到失效的请求报文，还会向客户端发生确认的报文。</p>
<p>如果没有第三次握手，服务端端发送的确认报文不会被客户端理睬。</p>
<p>这时服务端认为连接已经建立了，一直等待客户端发生请求数据，这样服务端的资源就会白白浪费了。</p>
</blockquote>
<h4 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2.冒泡排序"></a>2.冒泡排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">45</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">78</span>, <span class="number">32</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;<span class="comment">//外层循环是从0开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j&lt; arr.<span class="property">length</span>-i-<span class="number">1</span>; j++) &#123;<span class="comment">//内层循环是从arr.length-1开始</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;<span class="comment">//如果逆序，则交换</span></span><br><span class="line">            [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];<span class="comment">//交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">//排序后的数组</span></span><br></pre></td></tr></table></figure>



<h3 id="六、Uni-APP"><a href="#六、Uni-APP" class="headerlink" title="六、Uni-APP"></a>六、Uni-APP</h3><h4 id="1-uni-app有没有做过分包？"><a href="#1-uni-app有没有做过分包？" class="headerlink" title="1.uni-app有没有做过分包？"></a>1.uni-app有没有做过分包？</h4><p>​        优化小程序的下载和启动速度<br>​        小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示</p>
<h3 id="七、Weabpack"><a href="#七、Weabpack" class="headerlink" title="七、Weabpack"></a>七、Weabpack</h3><h4 id="1-webpack打包和不打包的区别？"><a href="#1-webpack打包和不打包的区别？" class="headerlink" title="1.webpack打包和不打包的区别？"></a>1.webpack打包和不打包的区别？</h4><p>​        1.运行效率<br>​        2.对基础的支持不够</p>
<h4 id="2-webpack是怎么打包的，babel是做什么的？"><a href="#2-webpack是怎么打包的，babel是做什么的？" class="headerlink" title="2.webpack是怎么打包的，babel是做什么的？"></a>2.webpack是怎么打包的，babel是做什么的？</h4><p>​        webpack会把js css image看作一个模块，用import&#x2F;require引入<br>​        找到入口文件，通过入口文件找到关联的依赖文件，把他们打包到一起<br>​        把bundle文件，拆分成多个小的文件，异步按需加载所需要的文件<br>​        如果一个被多个文件引用，打包时只会生成一个文件<br>​        如果引用的文件没有调用，不会打包，如果引入的变量和方法没有调用也不会打包<br>​        对于多个入口文件，加入引入了相同的代码，可以用插件把他抽离到公共文件中</p>
<h3 id="八、Git"><a href="#八、Git" class="headerlink" title="八、Git"></a>八、Git</h3><h4 id="1-git如何合并、拉取代码？"><a href="#1-git如何合并、拉取代码？" class="headerlink" title="1.git如何合并、拉取代码？"></a>1.git如何合并、拉取代码？</h4><p>​        拉取代码 git pull ‘仓库地址’<br>​        查看状态 git status<br>​        提交到本地缓存区  git add .<br>​        提交本地仓库 git commit -m ‘修改描述’<br>​        提交到远程仓库 git push ‘仓库地址’ master<br>​        创建分支 git branch -b xxx<br>​        合并分支 git merge ‘合并分支的名字’</p>
<h4 id="2-git如何解决冲突问题？"><a href="#2-git如何解决冲突问题？" class="headerlink" title="2.git如何解决冲突问题？"></a>2.git如何解决冲突问题？</h4><p>​        1.两个分支中修改了同一个文件<br>​        2.两个分支中修改了同一个文件的名字<br>​        1.解决：当前分支上，直接修改代码  add  commit<br>​        2.解决：在本地当前分支上，修改冲突代码 add commit push</p>
<h4 id="3-git-stash"><a href="#3-git-stash" class="headerlink" title="3.git stash"></a>3.git stash</h4><p>场景一：当前分支A,BUG分支B</p>
<ol>
<li><code>git stash</code>,先存入栈</li>
<li><code>git checkout B</code>,切换到BUG分支B</li>
<li><code>git checkout A</code>,修完BUG切回分支A</li>
<li><code>git stash pop</code>,取回</li>
</ol>
<p>场景二：代码开发完准备提交</p>
<ol>
<li><p><code>git stash</code></p>
</li>
<li><p><code>git pull 仓库别名</code></p>
</li>
<li><p><code>git stash pop</code></p>
</li>
<li><p>本地处理可能出现的冲突</p>
</li>
<li><p><code>git commit -m &quot;xxx&quot;</code> + <code>git push 仓库别名</code></p>
</li>
<li><p>存（入栈）</p>
<p><code>git stash</code></p>
<p><code>git stash save &#39;注释&#39;</code></p>
</li>
<li><p>取（出栈）</p>
</li>
</ol>
<p>​	<code>git stash pop</code></p>
<p>​	<code>git stash apply</code> </p>
<ol start="3">
<li>清除</li>
</ol>
<p>​	<code>git stash drop + &lt;栈索引&gt;</code>清除某条记录</p>
<p>​	<code>git stash clear</code>清空整个栈</p>
<ol start="4">
<li>查看</li>
</ol>
<p>​	<code>git stash list</code>查看整个栈的所有记录</p>
<p>​	<code>git stash show</code>查看某条记录的具体信息</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://coffeerin.github.io/2024/06/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95-%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">-面试 -八股文</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/06/27/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            防抖和节流及其底层实现
          
        </div>
      </a>
    
    
      <a href="/2024/05/30/MyBatis%E7%AC%94%E8%AE%B0/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">MyBatis笔记</div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> CoffeeLin
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/coffee.svg" alt="CoffeeLin"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/clock">时钟</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>