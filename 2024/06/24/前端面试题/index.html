<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="一个废物的博客" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>前端面试题 |  CoffeeLin</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/咖啡.svg" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="CoffeeLin" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-前端面试题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  前端面试题
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/06/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2024-06-24T15:48:55.000Z" itemprop="datePublished">2024-06-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">11.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">41 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="一、CSS"><a href="#一、CSS" class="headerlink" title="一、CSS"></a>一、CSS</h3><h4 id="1-说一下CSS的盒模型。"><a href="#1-说一下CSS的盒模型。" class="headerlink" title="1.说一下CSS的盒模型。"></a>1.说一下CSS的盒模型。</h4><p>​        在HTML页面中的所有元素都可以看成是一个盒子<br>​        盒子的组成：内容content、内边距padding、边框border、外边距margin<br>​        盒模型的类型：<br>​            标准盒模型<br>​                margin + border + padding + content<br>​            IE盒模型<br>​                margin + content(border + padding)<br>​        控制盒模型的模式：box-sizing:content-box（默认值，标准盒模型）、border-box（IE盒模型）;</p>
<h4 id="2-CSS选择器的优先级？"><a href="#2-CSS选择器的优先级？" class="headerlink" title="2.CSS选择器的优先级？"></a>2.CSS选择器的优先级？</h4><p>​        CSS的特性：继承性、层叠性、优先级<br>​        优先级：写CSS样式的时候，会给同一个元素添加多个样式，此时谁的权重高就显示谁的样式<br>​        标签、类&#x2F;伪类&#x2F;属性、全局选择器、行内样式、id、!important<br>​        !important &gt; 行内样式 &gt; id &gt; 类&#x2F;伪类&#x2F;属性 &gt; 标签 &gt; 全局选择器</p>
<h4 id="3-隐藏元素的方法有哪些？"><a href="#3-隐藏元素的方法有哪些？" class="headerlink" title="3.隐藏元素的方法有哪些？"></a>3.隐藏元素的方法有哪些？</h4><p>​        display:none;<br>​            元素在页面上消失，不占据空间<br>​        opacity:0;<br>​            设置了元素的透明度为0，元素不可见，占据空间位置<br>​        visibility:hidden;<br>​            让元素消失，占据空间位置，一种不可见的状态<br>​        position:absolute;<br>​        clip-path</p>
<h4 id="4-px和rem的区别是什么？"><a href="#4-px和rem的区别是什么？" class="headerlink" title="4.px和rem的区别是什么？"></a>4.px和rem的区别是什么？</h4><p>​        px是像素，显示器上给我们呈现画面的像素，每个像素的大小是一样，绝对单位长度<br>​        rem，相对单位，相对于html根节点的font-size的值，直接给html节点的font-size:62.5%;<br>​            1rem &#x3D; 10px; （16px*62.5%&#x3D;10px）</p>
<h4 id="5-重绘重排有什么区别？"><a href="#5-重绘重排有什么区别？" class="headerlink" title="5.重绘重排有什么区别？"></a>5.重绘重排有什么区别？</h4><p>​        重排（回流）：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小<br>​        重绘：计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制<br>​        浏览器的渲染机制<br>​        对DOM的大小、位置进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排<br>​        对DOM的样式进行修改，比如color和background-color，浏览器不需要重新计算几何属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘</p>
<h4 id="6-让一个元素水平垂直居中的方式有哪些？"><a href="#6-让一个元素水平垂直居中的方式有哪些？" class="headerlink" title="6.让一个元素水平垂直居中的方式有哪些？"></a>6.让一个元素水平垂直居中的方式有哪些？</h4><p>​        1.定位+margin<br>​        2.定位+transform<br>​        3.flex布局<br>​        4.grid布局<br>​        5.table布局</p>
<h4 id="7-CSS的哪些属性哪些可以继承？哪些不可以继承？"><a href="#7-CSS的哪些属性哪些可以继承？哪些不可以继承？" class="headerlink" title="7.CSS的哪些属性哪些可以继承？哪些不可以继承？"></a>7.CSS的哪些属性哪些可以继承？哪些不可以继承？</h4><p>​        CSS的三大特性：继承、层叠、优先级<br>​        子元素可以继承父类元素的样式<br>​        1.字体的一些属性：font<br>​        2.文本的一些属性：line-height<br>​        3.元素的可见性：visibility:hidden<br>​        4.表格布局的属性：border-spacing<br>​        5.列表的属性：list-style<br>​        6.页面样式属性：page<br>​        7.声音的样式属性</p>
<h4 id="8-有没有用过预处理器？"><a href="#8-有没有用过预处理器？" class="headerlink" title="8.有没有用过预处理器？"></a>8.有没有用过预处理器？</h4><p>​        预处理语言增加了变量、函数、混入等强大的功能<br>​        SASS  LESS<br>​        </p>
<h3 id="二、JavaSscipt"><a href="#二、JavaSscipt" class="headerlink" title="二、JavaSscipt"></a>二、JavaSscipt</h3><h4 id="1-JS由哪三部分组成？"><a href="#1-JS由哪三部分组成？" class="headerlink" title="1.JS由哪三部分组成？"></a>1.JS由哪三部分组成？</h4><ol>
<li>ECMAScript：JS的核心内容，描述了语言的基础语法，比如var,for，数据类型（数组、字符串），</li>
<li>文档对象模型（DOM）：DOM把整个HTML页面规划为元素构成的文档</li>
<li>浏览器对象模型（BOM）：对浏览器窗口进行访问和操作</li>
</ol>
<h4 id="2-JS有哪些内置对象？"><a href="#2-JS有哪些内置对象？" class="headerlink" title="2.JS有哪些内置对象？"></a>2.JS有哪些内置对象？</h4><pre><code>String Boolean Number Array Object Function Math Date RegExp...
Math
    abs() sqrt() max() min()
Data
    new Data() getYear() 
Array
String
    concat() length  slice() split()
</code></pre>
<h4 id="3-操作数组的方法有哪些？"><a href="#3-操作数组的方法有哪些？" class="headerlink" title="3.操作数组的方法有哪些？"></a>3.操作数组的方法有哪些？</h4><pre><code>push() pop() sort() splice() unshift() shift() reverse() concat() join() map() filter()
ervery() some() reduce() isArray() findIndex()
哪些方法会改变原数组？
    push() pop() unshift() shift() sort() reverse() splice()
</code></pre>
<h4 id="4-JS对数据类的检测方式有哪些？"><a href="#4-JS对数据类的检测方式有哪些？" class="headerlink" title="4.JS对数据类的检测方式有哪些？"></a>4.JS对数据类的检测方式有哪些？</h4><pre><code>typeof()
instanceof()
constructor
Object.prototype.toString.call()
</code></pre>
<h4 id="5-说一下闭包，闭包有什么特点？"><a href="#5-说一下闭包，闭包有什么特点？" class="headerlink" title="5.说一下闭包，闭包有什么特点？"></a>5.说一下闭包，闭包有什么特点？</h4><pre><code>什么是闭包？函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包
特点：可以重复利用变量，并且这个变量不会污染全局的一种机制；这个变量是一直保存再内存中，不会被垃圾回收机制回收
缺点：闭包较多的时候，会消耗内存，导致页面的性能下降，在IE浏览器中才会导致内存泄漏
使用场景：防抖，节流，函数嵌套函数避免全局污染的时候
</code></pre>
<h4 id="6-前端的内存泄漏怎么理解？"><a href="#6-前端的内存泄漏怎么理解？" class="headerlink" title="6.前端的内存泄漏怎么理解？"></a>6.前端的内存泄漏怎么理解？</h4><pre><code>JS里已经分配内存地址的对象，但是由于长时间没有释放或者没办法清除，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。
垃圾回收机制
因素：一些为生命直接赋值的变量；一些未清空的定时器；过度的闭包；一些引用元素没有被清除。
</code></pre>
<h4 id="7-事件委托是什么？"><a href="#7-事件委托是什么？" class="headerlink" title="7.事件委托是什么？"></a>7.事件委托是什么？</h4><pre><code>又叫事件代理，原理就是利用了事件冒泡的机制来实现，也就是说把子元素的事件绑定到了父元素的身上
如果子元素组织了事件冒泡，那么委托也就不成立
组织事件冒泡：event.stopPropagation()
addEventListener(&#39;click&#39;,函数名，true/false) 默认是false（事件冒泡），true（事件捕获）
好处：提高性能，减少事件的绑定，也就减少了内存的占用。
</code></pre>
<h4 id="8-基本数据类型和引用数据类型的区别？"><a href="#8-基本数据类型和引用数据类型的区别？" class="headerlink" title="8.基本数据类型和引用数据类型的区别？"></a>8.基本数据类型和引用数据类型的区别？</h4><pre><code>基本数据类型：String Number Boolean undefined null
    基本数据类型保存在栈内存当中，保存的就是一个具体的值
引用数据类型（复杂数据类型）：Object Function Array
    保存在堆内存当中，声明一个引用类型的变量，它保存的是引用类型数据的地址
    假如声明两个引用类型同时指向了一个地址的时候，修改其中一个那么另外一个也会改变
</code></pre>
<h4 id="9-说一下原型链。"><a href="#9-说一下原型链。" class="headerlink" title="9.说一下原型链。"></a>9.说一下原型链。</h4><pre><code>原型就是一个普通对象，它是为构造函数的实例共享属性和方法；所有实例中引用的原型都是同一个对象
使用prototype可以把方法挂在原型上，内存值保存一份
__proto__可以理解为指针，实例对象中的属性，指向了构造函数的原型（prototype）
</code></pre>
<h4 id="10-new操作符具体做了什么？"><a href="#10-new操作符具体做了什么？" class="headerlink" title="10.new操作符具体做了什么？"></a>10.new操作符具体做了什么？</h4><pre><code>1.先创建一个空对象
2.把空对象和构造函数通过原型链进行链接
3.把构造函数的this绑定到新的空对象身上
4.根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要返回这个引用类型
</code></pre>
<h4 id="11-JS是如何实现继承的？"><a href="#11-JS是如何实现继承的？" class="headerlink" title="11.JS是如何实现继承的？"></a>11.JS是如何实现继承的？</h4><pre><code>1.原型链继承
2.借用构造函数继承
3.组合式继承
4.ES6的class类继承
</code></pre>
<h4 id="12-JS的设计原理是什么？"><a href="#12-JS的设计原理是什么？" class="headerlink" title="12.JS的设计原理是什么？"></a>12.JS的设计原理是什么？</h4><pre><code>JS引擎 运行上下文 调用栈 事件循环 回调
</code></pre>
<h4 id="13-JS中关于this指向的问题"><a href="#13-JS中关于this指向的问题" class="headerlink" title="13.JS中关于this指向的问题"></a>13.JS中关于this指向的问题</h4><pre><code>1. 全局对象中的this指向
指向的是window
2. 全局作用域或者普通函数中的this
指向全局window
3. this永远指向最后调用它的那个对象
在不是箭头函数的情况下
4. new 关键词改变了this的指向
5. apply,call,bind
可以改变this指向，不是箭头函数
6. 箭头函数中的this
它的指向在定义的时候就已经确定了
箭头函数它没有this,看外层是否有函数，有就是外层函数的this，没有就是window
7. 匿名函数中的this
永远指向了window,匿名函数的执行环境具有全局性，因此this指向window
</code></pre>
<h4 id="14-script标签里的async和defer有什么区别？"><a href="#14-script标签里的async和defer有什么区别？" class="headerlink" title="14.script标签里的async和defer有什么区别？"></a>14.script标签里的async和defer有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当没有async和defer这两个属性的时候，浏览器会立刻加载并执行指定的脚本</span><br><span class="line">有async</span><br><span class="line">加载和渲染后面元素的过程将和script的加载和执行并行进行（异步）</span><br><span class="line">有defer</span><br><span class="line">加载和渲染后面元素的过程将和script的加载并行进行（异步），但是它的执行事件要等所有元素解析完成之后才会执行</span><br></pre></td></tr></table></figure>

<h4 id="15-setTimeout最小执行时间是多少？"><a href="#15-setTimeout最小执行时间是多少？" class="headerlink" title="15.setTimeout最小执行时间是多少？"></a>15.setTimeout最小执行时间是多少？</h4><p>HTML5规定的内容：</p>
<ul>
<li>setTimeout最小执行时间是4ms</li>
<li>setInterval最小执行时间是10ms</li>
</ul>
<h4 id="16-ES6和ES5有什么区别？"><a href="#16-ES6和ES5有什么区别？" class="headerlink" title="16.ES6和ES5有什么区别？"></a>16.ES6和ES5有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JS的组成：ECMAScript BOM  DOM</span><br><span class="line">ES5:ECMAScript5,2009年ECMAScript的第五次修订，ECMAScript2009</span><br><span class="line">ES6:ECMAScript6,2015年ECMAScript的第六次修订，ECMAScript2015，是JS的下一个版本标准</span><br></pre></td></tr></table></figure>

<h4 id="17-ES6的新特性有哪些？"><a href="#17-ES6的新特性有哪些？" class="headerlink" title="17.ES6的新特性有哪些？"></a>17.ES6的新特性有哪些？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1.  新增块级作用域（let,const）</span><br><span class="line">   不存在变量提升</span><br><span class="line">   存在暂时性死区的问题</span><br><span class="line">   块级作用域的内容</span><br><span class="line">   不能在同一个作用域内重复声明</span><br><span class="line">2.  新增了定义类的语法糖（class）</span><br><span class="line">3.  新增了一种基本数据类型（symbol）</span><br><span class="line">4.  新增了解构赋值</span><br><span class="line">   从数组或者对象中取值，然后给变量赋值</span><br><span class="line">5.  新增了函数参数的默认值</span><br><span class="line">6.  给数组新增了API</span><br><span class="line">7.  对象和数组新增了扩展运算符</span><br><span class="line">8.  Promise</span><br><span class="line">   解决回调地狱的问题。</span><br><span class="line">   自身有all,reject,resolve,race方法</span><br><span class="line">   原型上有then,catch</span><br><span class="line">   把异步操作队列化</span><br><span class="line">   三种状态：pending初始状态,fulfilled操作成功,rejected操作失败</span><br><span class="line">   状态：pending -&gt; fulfilled;pending -&gt; rejected 一旦发生，状态就会凝固，不会再变</span><br><span class="line">   async  await</span><br><span class="line">   同步代码做异步的操作，两者必须搭配使用</span><br><span class="line">   async表明函数内有异步操作，调用函数会返回promise</span><br><span class="line">   await是组成async的表达式，结果是取决于它等待的内容，如果是promise那就是promise的结果，如果是普通函数就进行链式调用</span><br><span class="line">   await后的promise如果是reject状态，那么整个async函数都会中断，后面的代码不执行</span><br><span class="line"></span><br><span class="line">9.  新增了模块化（import,export）</span><br><span class="line">10.  新增了set和map数据结构</span><br><span class="line">    set就是不重复</span><br><span class="line">    map的key的类型不受限制</span><br><span class="line">11.  新增了generator</span><br><span class="line">12.  新增了箭头函数</span><br><span class="line">    不能作为构造函数使用，不能用new</span><br><span class="line">    箭头函数就没有原型</span><br><span class="line">    箭头函数没有arguments</span><br><span class="line">    箭头函数不能用call,apply,bind去改变this的执行</span><br><span class="line">    this指向外层第一个函数的this</span><br></pre></td></tr></table></figure>

<h4 id="18-call-aply-bind三者有什么区别？"><a href="#18-call-aply-bind三者有什么区别？" class="headerlink" title="18.call,aply,bind三者有什么区别？"></a>18.call,aply,bind三者有什么区别？</h4><p>都是改变this指向和函数的调用，call和apply的功能类似，只是传参的方法不同<br>call方法传的是一个参数列表<br>apply传递的是一个数组<br>bind传参后不会立刻执行，会返回一个改变了this指向的函数，这个函数还是可以传参的，bind()()<br>call方法的性能要比apply好一些，所以call用的更多一点</p>
<h4 id="19-用递归的时候有没有遇到什么问题？"><a href="#19-用递归的时候有没有遇到什么问题？" class="headerlink" title="19.用递归的时候有没有遇到什么问题？"></a>19.用递归的时候有没有遇到什么问题？</h4><p>如果一个函数内可以调用函数本身，那么这个就是递归函数<br>函数内部调用自己<br>特别注意：写递归必须要有退出条件return</p>
<h4 id="20-如何实现一个深拷贝？"><a href="#20-如何实现一个深拷贝？" class="headerlink" title="20.如何实现一个深拷贝？"></a>20.如何实现一个深拷贝？</h4><p>深拷贝就是完全拷贝一份新的对象，会在堆内存中开辟新的空间，拷贝的对象被修改后，原对象不受影响<br>主要针对的是引用数据类型<br>1.扩展运算符<br>2.JSON.parse(JSON.stringify())<br>3.利用递归函数实现</p>
<h4 id="21-说一下事件循环。"><a href="#21-说一下事件循环。" class="headerlink" title="21.说一下事件循环。"></a>21.说一下事件循环。</h4><p>JS是一个单线程的脚本语言<br>主线程 执行栈 任务队列  宏任务 微任务<br>主线程先执行同步任务，然后才去执行任务队列里的任务，如果在执行宏任务之前有微任务，那么要先执行微任务<br>全部执行完之后等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环！</p>
<h4 id="22-ajax是什么？怎么实现的？"><a href="#22-ajax是什么？怎么实现的？" class="headerlink" title="22.ajax是什么？怎么实现的？"></a>22.ajax是什么？怎么实现的？</h4><p>创建交互式网页应用的网页开发技术<br>    在不重新加载整个网页的前提下，与服务器交换数据并更新部分内容<br>通过XmlHttpRequest对象向服务器发送异步请求，然后从服务器拿到数据，最后通过JS操作DOM更新页面<br>1.创建XmlHttpRequest对象 xmh<br>2.通过xmh对象里的open()方法和服务器建立连接<br>3.构建请求所需的数据，并通过xmh对象的send()发送给服务器<br>4.通过xmh对象的onreadystate chansge事件监听服务器和你的通信状态<br>5.接收并处理服务器响应的数据结果<br>6.把处理的数据更新到HTML页面上</p>
<h4 id="23-get和post有什么区别？"><a href="#23-get和post有什么区别？" class="headerlink" title="23.get和post有什么区别？"></a>23.get和post有什么区别？</h4><p>1.get一般是获取数据，post一般是提交数据<br>2.get参数会放在url上，所以安全性比较差，post是放在body中<br>3.get请求刷新服务器或退回是没有影响的，post请求退回时会重新提交数据<br>4.get请求时会被缓存,post请求不会被缓存<br>5.get请求会被保存在浏览器历史记录中,post不会<br>6.get请求只能进行url编码，post请求支持很多种</p>
<h4 id="24-promise的内部原理是什么？它的优缺点是什么？"><a href="#24-promise的内部原理是什么？它的优缺点是什么？" class="headerlink" title="24. promise的内部原理是什么？它的优缺点是什么？"></a>24. promise的内部原理是什么？它的优缺点是什么？</h4><p>Promise对象，封装了一个异步操作并且还可以获取成功或失败的结果<br>Promise主要就是解决回调地狱的问题，之前如果异步任务比较多，同时他们之间有相互依赖的关系，<br>就只能使用回调函数处理，这样就容易形成回调地狱，代码的可读性差，可维护性也很差<br>有三种状态：pending初始状态  fulfilled成功状态  rejected失败状态<br>状态改变只会有两种情况，<br>    pending -&gt; fulfilled; pending -&gt; rejected 一旦发生，状态就会凝固，不会再变<br>首先就是我们无法取消promise，一旦创建它就会立即执行，不能中途取消<br>如果不设置回调，promise内部抛出的测u哦呜就无法反馈到外面<br>若当前处于pending状态时，无法得知目前在哪个阶段。<br>原理：<br>    构造一个Promise实例，实例需要传递函数的参数，这个函数有两个形参，分别都是函数类型，一个是resolve一个是reject<br>    promise上还有then方法，这个方法就是来指定状态改变时的确定操作，resolve是执行第一个函数，reject是执行第二个函数</p>
<h4 id="25-promise和async-await的区别是什么？"><a href="#25-promise和async-await的区别是什么？" class="headerlink" title="25.promise和async await的区别是什么？"></a>25.promise和async await的区别是什么？</h4><p>1.都是处理异步请求的方式<br>2.promise是ES6，async await 是ES7的语法<br>3.async await是基于promise实现的，他和promise都是非阻塞性的<br>优缺点：<br>1.promise是返回对象我们要用then，catch方法去处理和捕获异常，并且书写方式是链式，容易造成代码重叠，不好维护，async await 是通过tra catch进行捕获异常<br>2.async await最大的优点就是能让代码看起来像同步一样，只要遇到await就会立刻返回结果，然后再执行后面的操作<br>promise.then()的方式返回，会出现请求还没返回，就执行了后面的操作</p>
<h4 id="26-浏览器的存储方式有哪些？"><a href="#26-浏览器的存储方式有哪些？" class="headerlink" title="26.浏览器的存储方式有哪些？"></a>26.浏览器的存储方式有哪些？</h4><p>1.cookies<br>    H5标准前的本地存储方式<br>    兼容性好，请求头自带cookie<br>    存储量小，资源浪费，使用麻烦（封装）<br>2.localstorage<br>    H5加入的以键值对为标准的方式<br>    操作方便，永久存储，兼容性较好<br>    保存值的类型被限定，浏览器在隐私模式下不可读取，不能被爬虫<br>3.sessionstorage<br>    当前页面关闭后就会立刻清理，会话级别的存储方式<br>4.indexedDB<br>    H5标准的存储方式，，他是以键值对进行存储，可以快速读取，适合WEB场景</p>
<h4 id="27-token存在sessionstorage还是loaclstorage？"><a href="#27-token存在sessionstorage还是loaclstorage？" class="headerlink" title="27.token存在sessionstorage还是loaclstorage？"></a>27.token存在sessionstorage还是loaclstorage？</h4><p>token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串<br>1.存loaclstorage里，后期每次请求接口都需要把它当作一个字段传给后台<br>2.存cookie中，会自动发送，缺点就是不能跨域<br>如果存在localstorage中，容易被XSS攻击，但是如果做好了对应的措施，那么是利大于弊<br>如果存在cookie中会有CSRF攻击</p>
<h4 id="28-token的登录流程。"><a href="#28-token的登录流程。" class="headerlink" title="28.token的登录流程。"></a>28.token的登录流程。</h4><p>1.客户端用账号密码请求登录<br>2.服务端收到请求后，需要去验证账号密码<br>3.验证成功之后，服务端会签发一个token，把这个token发送给客户端<br>4.客户端收到token后保存起来，可以放在cookie也可以是localstorage<br>5.客户端每次向服务端发送请求资源的时候，都需要携带这个token<br>6.服务端收到请求，接着去验证客户端里的token，验证成功才会返回客户端请求的数据</p>
<h4 id="29-页面渲染的过程是怎样的？"><a href="#29-页面渲染的过程是怎样的？" class="headerlink" title="29.页面渲染的过程是怎样的？"></a>29.页面渲染的过程是怎样的？</h4><p>DNS解析<br>建立TCP连接<br>发送HTTP请求<br>服务器处理请求<br>渲染页面<br>    浏览器会获取HTML和CSS的资源，然后把HTML解析成DOM树<br>    再把CSS解析成CSSOM<br>    把DOM和CSSOM合并为渲染树<br>    布局<br>    把渲染树的每个节点渲染到屏幕上（绘制）<br>断开TCP连接</p>
<h4 id="30-DOM树和渲染树有什么区别？"><a href="#30-DOM树和渲染树有什么区别？" class="headerlink" title="30.DOM树和渲染树有什么区别？"></a>30.DOM树和渲染树有什么区别？</h4><p>DOM树是和HTML标签一一对应的，包括head和隐藏元素<br>渲染树是不包含head和隐藏元素</p>
<h4 id="31-精灵图和base64的区别是什么？"><a href="#31-精灵图和base64的区别是什么？" class="headerlink" title="31.精灵图和base64的区别是什么？"></a>31.精灵图和base64的区别是什么？</h4><p>精灵图：把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，当访问页面可以减少请求，提高加载速度<br>base64：传输8Bit字节代码的编码方式，把原本二进制形式转为64个字符的单位，最后组成字符串<br>base64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，但是一些低版本不支持，若base64体积比原图片大，不利于css的加载。</p>
<h4 id="32-svg格式了解多少？"><a href="#32-svg格式了解多少？" class="headerlink" title="32.svg格式了解多少？"></a>32.svg格式了解多少？</h4><p>基于XML语法格式的图像格式，可缩放矢量图，其他图像是基于像素的，SVG是属于对图像形状的描述，本质是文本文件，体积小，并且不管放大多少倍都不会失真<br>1.SVG可直接插入页面中，成为DOM一部分，然后用JS或CSS进行操作</p>
<pre><code>    &lt;svg&gt;&lt;/svg&gt;
</code></pre>
<p>​    2.SVG可作为文件被引入<br>​        <img src="F:/BaiduNetdiskDownload/pic.svg" /><br>​    3.SVG可以转为base64引入页面</p>
<h4 id="33-了解过JWT吗？"><a href="#33-了解过JWT吗？" class="headerlink" title="33.了解过JWT吗？"></a>33.了解过JWT吗？</h4><p>​    JSON Web Token 通过JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输<br>​    信息传输、授权<br>​    JWT的认证流程<br>​    1.前端把账号密码发送给后端的接口<br>​    2.后端核对账号密码成功后，把用户id等其他信息作为JWT 负载，把它和头部分别进行base64编码拼接后签名，形成一个JWT（token）。<br>​    3.前端每日请求时都会把JWT放在HTTP请求头的Authorization字段内<br>​    4.后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期）<br>​    5.验证通过后后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果<br>​    简洁、包含性、因为Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何web形式都支持。</p>
<h4 id="34-npm的底层环境是什么？"><a href="#34-npm的底层环境是什么？" class="headerlink" title="34.npm的底层环境是什么？"></a>34.npm的底层环境是什么？</h4><p>​    node package manager,node的包管理和分发工具，已经成为分发node模块的标准，是JS的运行环境<br>​    npm的组成：网站、注册表、命令行工具</p>
<h4 id="35-HTTP协议规定的协议头和请求头有什么？"><a href="#35-HTTP协议规定的协议头和请求头有什么？" class="headerlink" title="35.HTTP协议规定的协议头和请求头有什么？"></a>35.HTTP协议规定的协议头和请求头有什么？</h4><p>​    1.请求头信息：<br>​        Accept:浏览器告诉服务器所支持的数据类型<br>​        Host:浏览器告诉服务器我想访问服务器的哪台主机<br>​        Referer:浏览器告诉服务器我是从哪里来的（防盗链）<br>​        User-Agent:浏览器类型、版本信息<br>​        Date:浏览器告诉服务器我是什么时候访问的<br>​        Connection:连接方式<br>​        Cookie<br>​        X-Request-With:请求方式<br>​    2.响应头信息：<br>​        Location:这个就是告诉浏览器你要去找谁<br>​        Server:告诉浏览器服务器的类型<br>​        Content-Type:告诉浏览器返回的数据类型<br>​        Refresh:控制了的定时刷新</p>
<h4 id="36-说一下浏览器的缓存策略。"><a href="#36-说一下浏览器的缓存策略。" class="headerlink" title="36.说一下浏览器的缓存策略。"></a>36.说一下浏览器的缓存策略。</h4><p>​    强缓存（本地缓存）、协商缓存（弱缓存）<br>​    强缓：不发起请求，直接使用缓存里的内容，浏览器把JS，CSS，image等存到内存中，下次用户访问直接从内存中取，提高性能<br>​    协缓：需要像后台发请求，通过判断来决定是否使用协商缓存，如果请求内容没有变化，则返回304，浏览器就用缓存里的内容<br>​    强缓存的触发：<br>​        HTTP1.0:时间戳响应标头<br>​        HTTP1.1:Cache-Control响应标头<br>​    协商缓存触发：<br>​        HTTP1.0:请求头：if-modified-since 响应头：last-modified<br>​        HTTP1.1:请求头：if-none-match 响应头：Etag</p>
<h4 id="37-说一下什么是“同源策略”？"><a href="#37-说一下什么是“同源策略”？" class="headerlink" title="37.说一下什么是“同源策略”？"></a>37.说一下什么是“同源策略”？</h4><p>​    http:&#x2F;&#x2F; www.  aaa.com:8080&#x2F;index&#x2F;vue.js<br>​    协议    子域名 主域名  端口号     资源<br>​    同源策略是浏览器的核心，如果没有这个策略就会遭受网络攻击<br>​    主要指的就是协议+域名+端口号三者一致，若其中一个不一样则不是同源，会产生跨域<br>​    三个允许跨域加载资源的标签：img  link  script<br>​    跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截了！<br>​    JSONP<br>​    CORS<br>​    websocket<br>​    反向代理</p>
<h4 id="38-防抖和节流是什么？"><a href="#38-防抖和节流是什么？" class="headerlink" title="38.防抖和节流是什么？"></a>38.防抖和节流是什么？</h4><p>​    都是应对页面中频繁触发事件的优化方案<br>​    防抖:避免事件重复触发<br>​    使用场景:1.频繁和服务端交互 2.输入框的自动保存事件<br>​    节流:把频繁触发的事件减少,每隔一段时间执行<br>​    使用场景:scroll事件</p>
<h4 id="39-解释一下什么是json？"><a href="#39-解释一下什么是json？" class="headerlink" title="39.解释一下什么是json？"></a>39.解释一下什么是json？</h4><p>​    JSON是一种纯字符串形式的数据，它本身不提供任何方法，适合在网络中进行传输<br>​    JSON数据存储在.json文件中，也可以把JSON数据以字符串的形式保存在数据库、Cookise中<br>​    JS提供了JSON.parse() JSON.stringify()<br>​    什么时候使用json：定义接口；序列化；生成token；配置文件package.json</p>
<h4 id="40-当数据没有请求过来的时候，该怎么做？"><a href="#40-当数据没有请求过来的时候，该怎么做？" class="headerlink" title="40.当数据没有请求过来的时候，该怎么做？"></a>40.当数据没有请求过来的时候，该怎么做？</h4><p>​    可以在渲染数据的地方给一些默认的值<br>​    if判断语句</p>
<h4 id="41-有没有做过无感登录？"><a href="#41-有没有做过无感登录？" class="headerlink" title="41.有没有做过无感登录？"></a>41.有没有做过无感登录？</h4><p>​    1.在相应其中拦截，判断token返回过期后，调用刷新token的接口<br>​    2.后端返回过期时间，前端判断token的过期时间，去调用刷新token的接口<br>​    3.写定时器，定时刷新token接口<br>​    流程：<br>​        1.登录成功后保存token 和 refresh_token<br>​        2.在响应拦截器中对401状态码引入刷新token的api方法调用<br>​        3.替换保存本地新的token<br>​        4.把错误对象里的token替换<br>​        5.再次发送未完成的请求<br>​        6.如果refresh_token过期了，判断是否过期，过期了就清楚所有token重新登录</p>
<h4 id="42-大文件上传是怎么做的？"><a href="#42-大文件上传是怎么做的？" class="headerlink" title="42.大文件上传是怎么做的？"></a>42.大文件上传是怎么做的？</h4><p>​    分片上传：<br>​        1.把需要上传的文件按照一定的规则，分割成相同大小的数据块<br>​        2.初始化一个分片上传任务，返回本次分片上传的唯一标识<br>​        3.按照一定的规则把各个数据块上传<br>​        4.发送完成后，服务端会判断数据上传的完整性，如果完整，那么就会把数据库合并成原始文件<br>​    断点续传：<br>​        服务端返回，从哪里开始  浏览器自己处理</p>
<h3 id="三、HTML5CSS3"><a href="#三、HTML5CSS3" class="headerlink" title="三、HTML5CSS3"></a>三、HTML5CSS3</h3><h4 id="1-语义化的理解。"><a href="#1-语义化的理解。" class="headerlink" title="1.语义化的理解。"></a>1.语义化的理解。</h4><p>​        在写HTML页面结构时所用的标签有意义<br>​        头部用head  主体用main  底部用foot…<br>​        怎么判断页面是否语义化了？<br>​            把CSS去掉，如果能够清晰的看出来页面结构，显示内容较为正常<br>​        为什么要选择语义化？<br>​            1.让HTML结构更加清晰明了<br>​            2.方便团队协作，利于开发<br>​            3.有利于爬虫和SEO<br>​            4.能够让浏览器更好的去解析代码<br>​            5.给用户带来良好的体验</p>
<h4 id="2-H5C3有哪些新特性？"><a href="#2-H5C3有哪些新特性？" class="headerlink" title="2.H5C3有哪些新特性？"></a>2.H5C3有哪些新特性？</h4><p>​        H5的新特性：<br>​            1.语义化的标签<br>​            2.新增音频视频<br>​            3.画布canvas<br>​            4.数据存储localstorage sessionstorage<br>​            5.增加了表单控件 email url search…<br>​            6.拖拽释放API<br>​        CSS3的新特性：<br>​            1.新增选择器：属性选择器、伪类选择器、伪元素选择器<br>​            2.增加了媒体查询<br>​            3.文字阴影<br>​            4.边框<br>​            5.盒子模型box-sizing<br>​            6.渐变<br>​            7.过度<br>​            8.自定义动画<br>​            9.背景的属性<br>​            10.2D和3D</p>
<h4 id="3-rem是如何做适配的？"><a href="#3-rem是如何做适配的？" class="headerlink" title="3.rem是如何做适配的？"></a>3.rem是如何做适配的？</h4><p>​        rem是相对长度，相对于根元素（html）的font-size属性来计算大小，通常来做移动端的适配<br>​        rem是根据根元素font-size计算值的倍数<br>​        比如html上的font-size:16px，给div设置宽为1.5rem,1.2rem &#x3D; 16px*1.2 &#x3D; 19.2px.</p>
<h4 id="4-解决了哪些移动端的兼容问题？"><a href="#4-解决了哪些移动端的兼容问题？" class="headerlink" title="4.解决了哪些移动端的兼容问题？"></a>4.解决了哪些移动端的兼容问题？</h4><p>​        1.当设置样式overflow:scroll&#x2F;auto时，IOS上的华东会卡顿<br>​            -webkit-overflow-scrolling:touch;<br>​        2.在安卓环境下placeholder文字设置行高时会偏上<br>​            input有placeholder属性的时候不要设置行高<br>​        3.移动端字体小于12px时异常显示<br>​            应该先把在整体放大一倍，然后再用transform进行缩小<br>​        4.ios下input按钮设置了disabled属性为true显示异常<br>​            input[typy&#x3D;button]{<br>​                opcity:1<br>​            }<br>​        5.安卓手机下取消语音输入按钮<br>​            input::-webkit-input-speech-button{<br>​                display:none<br>​            }<br>​        6.IOS下取消input输入框在输入引文首字母默认大写<br>​            <input autocapitalize='off' autocorrect='off'/><br>​        7.禁用IOS和安卓用户选中文字<br>​            添加全局CSS样式：-webkit-user-select:none<br>​        8.禁止IOS弹出各种窗口<br>​            -webkit-touch-callout:none<br>​        9.禁止IOS识别长串数字为电话<br>​            添加meta属性 <meta conten='telephone=no' name='format-detection'></p>
<h3 id="四、Vue"><a href="#四、Vue" class="headerlink" title="四、Vue"></a>四、Vue</h3><h4 id="1-v-if和v-show的区别？"><a href="#1-v-if和v-show的区别？" class="headerlink" title="1.v-if和v-show的区别？"></a>1.v-if和v-show的区别？</h4><p>​        都可以控制元素的显示和隐藏<br>​        1.v-show时控制元素的display值来让元素显示和隐藏；v-if显示隐藏时把DOM元素整个添加和删除<br>​        2.v-if有一个局部编译&#x2F;卸载的过程，切换这个过程中会适当的销毁和重建内部的事件监听和子组件；v-show只是简单的css切换<br>​        3.v-if才是真正的条件渲染；v-show从false变成true的时候不会触发组件的声明周期，v-if会触发声明周期<br>​        4.v-if的切换效率比较低  v-show的效率比较高</p>
<h4 id="2-如何理解MVVM的？"><a href="#2-如何理解MVVM的？" class="headerlink" title="2.如何理解MVVM的？"></a>2.如何理解MVVM的？</h4><p>​        是Model-View-ViewModel的缩写。前端开发的架构模式<br>​        M：模型，对应的就是data的数据<br>​        V：视图，用户界面，DOM<br>​        VM：视图模型：Vue的实例对象，连接View和Model的桥梁<br>​        核心是提供对View和ViewModel的双向数据绑定，当数据改变的时候，ViewModel能监听到数据的变化，自动更新视图，当用户操作视图的时候，ViewModel也可以监听到视图的变化，然后通知数据进行改动，这就实现了双向数据绑定<br>​        ViewModel通过双向绑定把View和Model连接起来，他们之间的同步是自动的，不需要认为干涉，所以我们只需要关注业务逻辑即可，不需要操作DOM，同时也不需要关注数据的状态问题，因为她是由MVVM统一管理</p>
<h4 id="3-v-for中的key值的作用是什么？"><a href="#3-v-for中的key值的作用是什么？" class="headerlink" title="3.v-for中的key值的作用是什么？"></a>3.v-for中的key值的作用是什么？</h4><p>​        key属性是DOM元素的唯一标识<br>​        作用：<br>​            1.提高虚拟DOM的更新<br>​            2.若不设置key，可能会触发一些bug<br>​            3.为了触发过度效果</p>
<h4 id="4-说一下你对vue生命周期的理解。"><a href="#4-说一下你对vue生命周期的理解。" class="headerlink" title="4.说一下你对vue生命周期的理解。"></a>4.说一下你对vue生命周期的理解。</h4><p>​        组件从创建到销毁的过程就是它的生命周期<br>​        创建<br>​            beforeCreat<br>​                在这个阶段属性和方法都不能使用<br>​            created<br>​                这里时实例创建完成之后，在这里完成了数据监测，可以使用数据，修改数据，不会触发updated，也不会更新视图<br>​        挂载<br>​            beforeMount<br>​                完成了模板的编译，虚拟DOM也完成创建，即将渲染，修改数据，不会触发updated<br>​            Mounted<br>​                把编译好的模板挂载到页面，这里可以发送异步请求也可以访问DOM节点<br>​        更新<br>​            beforeUpdate<br>​                组件数据更新之前使用，数据是新的，页面上的数据时旧的，组件即将更新，准备渲染，可以改数据<br>​            updated<br>​                render重新做了渲染，这时数据和页面都是新的，避免在此更新数据<br>​        销毁<br>​            beforeDestroy<br>​                实例销毁前，在这里实例还可以用，可以清楚定时器等等<br>​            destroyed<br>​                组件已经被销毁了，全部都销毁<br>​        使用了keep-alive时多出两个周期：<br>​            activited<br>​                组件激活时<br>​            deactivited<br>​                组件被销毁时</p>
<h4 id="5-在created和mounted去请求数据，有什么区别？"><a href="#5-在created和mounted去请求数据，有什么区别？" class="headerlink" title="5.在created和mounted去请求数据，有什么区别？"></a>5.在created和mounted去请求数据，有什么区别？</h4><p>​        created：在渲染前调用，通常先初始化属性，然后做渲染<br>​        mounted：在模板渲染完成后，一般都是初始化页面后，在对元素节点进行操作<br>​                在这里请求数据可能会出现闪屏的问题，created里不会<br>​        一般用created比较多<br>​        请求的数据对DOM有影响，那么使用created<br>​        如果请求的数据对DOM无关，可以放在mounted</p>
<h4 id="6-vue中的修饰符有哪些？"><a href="#6-vue中的修饰符有哪些？" class="headerlink" title="6.vue中的修饰符有哪些？"></a>6.vue中的修饰符有哪些？</h4><p>​        1.事件修饰符<br>​            .stop       组织冒泡<br>​            .prevent    组织默认行为<br>​            .capture    内部元素触发的事件先在次处理<br>​            .self       只有在event.target是当前元素时触发<br>​            .once       事件只会触发一次<br>​            .passive    立即触发默认行为<br>​            .native     把当前元素作为原生标签看待<br>​        2.按键修饰符<br>​            .keyup      键盘抬起<br>​            .keydown    键盘按下<br>​        3.系统修饰符<br>​            .ctrl<br>​            .alt<br>​            .meta<br>​        4.鼠标修饰符<br>​            .left       鼠标左键<br>​            .right      鼠标右键<br>​            .middle     鼠标中键<br>​        5.表单修饰符<br>​            .lazy       等输入完之后再显示<br>​            .trim       删除内容前后的空格<br>​            .number     输入是数字或转为数字</p>
<h4 id="7-elementui是怎么做表单验证的？"><a href="#7-elementui是怎么做表单验证的？" class="headerlink" title="7.elementui是怎么做表单验证的？"></a>7.elementui是怎么做表单验证的？</h4><p>​        1.在表单中加rules属性，然后再data里写校验规则<br>​        2.内部添加规则<br>​        3.自定义函数校验</p>
<h4 id="8-vue如何进行组件通信？"><a href="#8-vue如何进行组件通信？" class="headerlink" title="8.vue如何进行组件通信？"></a>8.vue如何进行组件通信？</h4><p>​        1.父传子<br>​            props<br>​                父组件使用自定义属性，然后子组件使用props<br>​            $ref<br>​                引用信息会注册在父组件的$refs对象上<br>​        2.子传父<br>​            $emit<br>​                子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数<br>​        3.兄弟传<br>​            new一个新的vue实例，用on和emit来对数据进行传输<br>​        4.vuex传值</p>
<h4 id="9-keep-alive是什么？怎么使用？"><a href="#9-keep-alive是什么？怎么使用？" class="headerlink" title="9.keep-alive是什么？怎么使用？"></a>9.keep-alive是什么？怎么使用？</h4><p>​        Vue的一个内置组件，包裹组件的时候，会缓存不活跃的组件实例，并不是销毁他们<br>​        作用：把组件切换的状态保存在内存里，防止重复渲染DOM节点，减少加载时间和性能消耗，提高用户体验</p>
<h4 id="10-axios是怎么做封装的？"><a href="#10-axios是怎么做封装的？" class="headerlink" title="10.axios是怎么做封装的？"></a>10.axios是怎么做封装的？</h4><p>​        下载 创建实例 接着封装请求响应拦截器  抛出 最后封装接口</p>
<h4 id="11-vue路由时怎么传参的？"><a href="#11-vue路由时怎么传参的？" class="headerlink" title="11.vue路由时怎么传参的？"></a>11.vue路由时怎么传参的？</h4><p>​        params传参<br>​            this.$router.push({name:’index’,params:{id:item.id}})<br>​            this.$route.params.id<br>​        路由属性传参<br>​            this.$router.push({name:’&#x2F;index&#x2F;${item.id}’})<br>​            路由配置 { path:’&#x2F;index:id’ }<br>​        query传参（可以解决页面刷新参数丢失的问题）<br>​            this.$router.push({<br>​                name:’index’,<br>​                query:{id:item.id}<br>​            })</p>
<h4 id="12-vue路由的hash模式和history模式有什么区别？"><a href="#12-vue路由的hash模式和history模式有什么区别？" class="headerlink" title="12.vue路由的hash模式和history模式有什么区别？"></a>12.vue路由的hash模式和history模式有什么区别？</h4><p>​        1.hash的路由地址上有#号，history模式没有<br>​        2.在做回车刷新的时候，hash模式会加载对应页面，history会报错404<br>​        3.hash模式支持低版本浏览器，history不支持，因为是H5新增的API<br>​        4.hash不会重新加载页面，单页面应用必备<br>​        5.history有历史记录，H5新增了pushState和replaceState()去修改历史记录，并不会立刻发送请求<br>​        6.history需要后台配置</p>
<h4 id="13-路由拦截是怎么实现的？"><a href="#13-路由拦截是怎么实现的？" class="headerlink" title="13.路由拦截是怎么实现的？"></a>13.路由拦截是怎么实现的？</h4><p>​        路由拦截 axios拦截<br>​        需要在路由配置中添加一个字段，它是用于判断路由是否需要拦截</p>
<pre><code>&#123;
            name:&#39;index&#39;,
            path:&#39;/index&#39;,
            component:Index,
            meta:&#123;
                requirtAuth:true
            &#125;
        &#125;
        router.beforeEach((to,from,next) =&gt; &#123;
            if(to.meta.requirtAuth)&#123;
                if( store.satte.token )&#123;
                    next()
                &#125;else&#123;
                    &#125;
    &#125;
&#125;)
</code></pre>
<h4 id="14-说一下vue的动态路由。"><a href="#14-说一下vue的动态路由。" class="headerlink" title="14.说一下vue的动态路由。"></a>14.说一下vue的动态路由。</h4><p>​    要在路由配置里设置meat属性，扩展权限相关的字段，在路由导航守卫里通过判断这个权限标识，实现路由的动态增加和跳转<br>​    根据用户登录的账号，返回用户角色<br>​    前端再根据角色，跟路由表的meta.role进行匹配<br>​    把匹配搭配的路由形成可访问的路由</p>
<h4 id="15-如何解决刷新后二次加载路由？"><a href="#15-如何解决刷新后二次加载路由？" class="headerlink" title="15.如何解决刷新后二次加载路由？"></a>15.如何解决刷新后二次加载路由？</h4><p>​    1.window.location.reload()<br>​    2.matcher<br>​        const router &#x3D; createRouter()<br>​        export function resetRouter(){<br>​            const newRouter &#x3D; creatRouter()<br>​            router.matcher &#x3D; newRouter.matcher<br>​        }</p>
<h4 id="16-vuex刷新数据会丢失吗？怎么解决？"><a href="#16-vuex刷新数据会丢失吗？怎么解决？" class="headerlink" title="16.vuex刷新数据会丢失吗？怎么解决？"></a>16.vuex刷新数据会丢失吗？怎么解决？</h4><p>​    vuex肯定会重新获取数据，页面也会丢失数据<br>​    1.把数据直接保存在浏览器缓存里（cookie  localstorage  sessionstorage）<br>​    2.页面刷新的时候，再次请求数据，达到可以动态更新的方法<br>​        监听浏览器的刷新书简，在刷新前把数据保存到sessionstorage里，刷新后请求数据，请求到了用vuex，如果没有那就用sessionstorage里的数据</p>
<h4 id="17-computed和watch的区别？"><a href="#17-computed和watch的区别？" class="headerlink" title="17.computed和watch的区别？"></a>17.computed和watch的区别？</h4><p>​    1.computed是计算属性，watch是监听，监听的是data中数据的变化<br>​    2.computed是支持缓存，依赖的属性值发生变化，计算属性才会重新计算，否则用缓存；watch不支持缓存<br>​    3.computed不支持异步，watch是可以异步操作<br>​    4.computed是第一次加载就监听，watch是不监听<br>​    5.computed函数中必须有return  watch不用</p>
<h4 id="18-vuex在什么场景会去使用？属性有哪些？"><a href="#18-vuex在什么场景会去使用？属性有哪些？" class="headerlink" title="18.vuex在什么场景会去使用？属性有哪些？"></a>18.vuex在什么场景会去使用？属性有哪些？</h4><p>​    state       存储变量<br>​    getters     state的计算属性<br>​    mutations   提交更新数据的方法<br>​    actions     和mutations差不多，他是提交mutations来修改数据，可以包括异步操作<br>​    modules     模块化vuex<br>​    使用场景：<br>​        用户的个人信息、购物车模块、订单模块</p>
<h4 id="19-vue的双向数据绑定原理是什么？"><a href="#19-vue的双向数据绑定原理是什么？" class="headerlink" title="19.vue的双向数据绑定原理是什么？"></a>19.vue的双向数据绑定原理是什么？</h4><p>​    通过数据劫持和发布订阅者模式来实现，同时利用Object.defineProperty()劫持各个属性的setter和getter，<br>​    在数据发生改变的时候发布消息给订阅者，触发对应的监听回调渲染视图，也就是说数据和视图时同步的，数据发生改变，视图跟着发生改变，视图改变，数据也会发生改变。<br>​    第一步：需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter<br>​    第二步：compile模板解析指令，把模板中的变量替换成数据，然后初始化渲染视图，同时把每个指令对应的节点绑定上更新函数，添加订阅者，如果数据变化，收到通知，更新视图<br>​    第三步：Watcher订阅者是Observer和Compile之间的通信桥梁，作用：<br>​            1.在自身实例化的时候忘订阅器内添加自己<br>​            2.自身要有一个update()方法<br>​            3.等待属性变动时，调用自身的update方法，触发compile这种的回调<br>​    第四步：MVVM作为数据绑定的入口，整合了observer、compile和watcher三者，通过observer来监听自己的数据变化，通过compile解析模板指令，最后利用watcher把observer和compile联系起来，最终达到数据更新视图更新，视图更新数据更新的效果</p>
<h4 id="20-了解diff算法和虚拟DOM吗？"><a href="#20-了解diff算法和虚拟DOM吗？" class="headerlink" title="20.了解diff算法和虚拟DOM吗？"></a>20.了解diff算法和虚拟DOM吗？</h4><p>​    虚拟DOM，描述元素和元素之间的关系，创建一个JS对象<br>​    如果组件内有响应的数据，数据发生改变的时候，render函数会生成一个新的虚拟DOM，这个新的虚拟DOM会和旧的虚拟DOM进行比对，找到需要修改的虚拟DOM内容，然后去对应的真实DOM中修改<br>​    diff算法就是虚拟DOM的比对时用的，返回一个patch对象，这个对象的作用就是存储两个节点不同的地方，最后用patch里记录的信息进行更新真实DOM<br>​    步骤：<br>​        1.JS对象表示真实的DOM结构，要生成一个虚拟DOM，再用虚拟DOM构建一个真实DOM树，渲染到页面<br>​        2.状态改变生成新的虚拟DOM，跟就得虚拟DOM进行比对，这个比对的过程就是DIFF算法，利用patch记录差异<br>​        3.把记录的差异用在第一个虚拟DOM生成的真实DOM上，视图就更新了。</p>
<h4 id="21-vue和jquery的区别是什么？"><a href="#21-vue和jquery的区别是什么？" class="headerlink" title="21.vue和jquery的区别是什么？"></a>21.vue和jquery的区别是什么？</h4><p>​    1.原理不同<br>​        vue就是数据绑定；jq是先获取dom再处理<br>​    2.着重点不同<br>​        vue是数据驱动，jq是着重于页面<br>​    3.操作不同<br>​    4.未来发展不同</p>
<h4 id="22-vuex的响应式处理。"><a href="#22-vuex的响应式处理。" class="headerlink" title="22.vuex的响应式处理。"></a>22.vuex的响应式处理。</h4><p>​    vuex是vue的状态管理工具<br>​    vue中可以直接触发methods中的方法，vuex是不可以的。未来处理异步，当触发事件的时候，会通过dispatch来访问actions中的方法，actions中的commit会触发mutations中的方法从而修改state里的值，通过getter把数据更新到视图<br>​    Vue.use(vuex)，调用install方法，通过applyMixin(vue)在任意组件内执行this.$store就可以访问到store对象。<br>​    vuex的state是响应式的，借助的就是vue的data，把state存到vue实例组件的data中</p>
<h4 id="23-vue中遍历全局的方法有哪些？"><a href="#23-vue中遍历全局的方法有哪些？" class="headerlink" title="23.vue中遍历全局的方法有哪些？"></a>23.vue中遍历全局的方法有哪些？</h4><p>​    1.普通遍历，对象.forEach()<br>​        arr.forEach(function(item,index,arr){<br>​            console.log(item,index)<br>​        })<br>​    2.对元素统一操作  对象.map()<br>​        var newarr &#x3D; arr.map(function(item){<br>​            return item+1<br>​        })<br>​    3.查找符合条件的元素 对象.filter()<br>​        arr.filter(function(item){<br>​            if(item &gt; 2){<br>​                return false<br>​            }else{<br>​                return true<br>​            }<br>​        })<br>​    4.查询符合条件的元素，返回索引 对象.findindex()<br>​        arr.finindex(function(item){<br>​            if(item&gt;1){<br>​                return true<br>​            }else{<br>​                return false<br>​            }<br>​        })<br>​    对象.evening()  遇到不符合的对象会停止<br>​    对象.some()  找到符合条件的元素就停止</p>
<h4 id="24-如何搭建脚手架？"><a href="#24-如何搭建脚手架？" class="headerlink" title="24.如何搭建脚手架？"></a>24.如何搭建脚手架？</h4><p>​    下载：node  cnpm  webpack vue-cli<br>​    创建项目：<br>​        1.找到对应的文件，然后利用node指令创建（cmd）<br>​        2.vue init webpack xxxx<br>​        3.回车项目描述<br>​        4.作者回车<br>​        5.选择vue build<br>​        6.回车<br>​        7.输入n<br>​        8.不按照yarn<br>​        9.输入npm run dev</p>
<h4 id="25-如何封装一个组件？"><a href="#25-如何封装一个组件？" class="headerlink" title="25.如何封装一个组件？"></a>25.如何封装一个组件？</h4><p>​    1.使用Vue.extend()创建一个组件<br>​    2.使用Vue.components()方法注册组件<br>​    3.如果子组件需要数据，可以在props中接收定义<br>​    4.子组件修改好数据，要把数据传递给父组件，可以用emit()方法<br>​    原则：<br>​        把功能拆开<br>​        尽量让组件原子化，一个组件做一件事情<br>​        容器组件管数据，展示组件管视图</p>
<h4 id="26-封装一个可复用的组件，需要满足什么条件？"><a href="#26-封装一个可复用的组件，需要满足什么条件？" class="headerlink" title="26.封装一个可复用的组件，需要满足什么条件？"></a>26.封装一个可复用的组件，需要满足什么条件？</h4><p>​    1.低耦合，组件之间的依赖越小越好<br>​    2.最好从父级传入信息，不要在公共组件中请求数据<br>​    3.传入的数据要进行校验<br>​    4.处理事件的方法写在父组件中</p>
<h4 id="27-vue的过滤器怎么使用？"><a href="#27-vue的过滤器怎么使用？" class="headerlink" title="27.vue的过滤器怎么使用？"></a>27.vue的过滤器怎么使用？</h4><p>​    vue的特性，用来对文本进行格式化处理<br>​    使用它的两个地方，一个是插值表达式，一个是v-bind<br>​    分类：<br>​        1.全局过滤器<br>​            Vue.filter(‘add’,function(v){<br>​                return v &lt; 10 ? ‘0’ + v : v<br>​            })</p>
<pre><code>        &lt;div&gt;&#123;&#123;33 | add&#125;&#125;&lt;/div&gt;
</code></pre>
<p>​        2.本地过滤器<br>​            和methods同级<br>​            filter:{<br>​                add:function(v){<br>​                    return v &lt; 10 ? ‘0’ + v : v<br>​                }<br>​            }</p>
<h4 id="28-vue中如何做强制刷新？"><a href="#28-vue中如何做强制刷新？" class="headerlink" title="28.vue中如何做强制刷新？"></a>28.vue中如何做强制刷新？</h4><p>​    1.localtion.reload()<br>​    2.this.$router.go(0)<br>​    3.provide和inject</p>
<h4 id="29-vue3和vue2有哪些区别？"><a href="#29-vue3和vue2有哪些区别？" class="headerlink" title="29.vue3和vue2有哪些区别？"></a>29.vue3和vue2有哪些区别？</h4><p>​    1.双向数据绑定的原理不同<br>​    2.是否支持碎片<br>​    3.API不同<br>​    4.定义数据变量方法不同<br>​    5.生命周期的不同<br>​    6.传值不同<br>​    7.指令和插槽不同<br>​    8.main.js不同</p>
<h4 id="30-vue的性能优化怎么做？"><a href="#30-vue的性能优化怎么做？" class="headerlink" title="30.vue的性能优化怎么做？"></a>30.vue的性能优化怎么做？</h4><p>​    1.编码优化<br>​        不要把所有数据都放在data中<br>​        v-for时给每个元素绑定事件用事件代理<br>​        keep-alive缓存组件<br>​        尽可能拆分组件，提高复用性、维护性<br>​        key值要保证唯一<br>​        合理使用路由懒加载，异步组件<br>​        数据持久化存储的使用尽量用防抖、节流优化<br>​    2.加载优化<br>​        按需加载<br>​        内容懒加载<br>​        图片懒加载<br>​    3.用户体验<br>​        骨架屏<br>​    4.SEO优化<br>​        预渲染<br>​        服务端渲染ssr<br>​    5.打包优化<br>​        CDN形式加载第三方模块<br>​        多线程打包<br>​        抽离公共文件<br>​    6.缓存和压缩<br>​        客户端缓存、服务端缓存<br>​        服务端Gzip压缩</p>
<h4 id="31-首屏优化该如何去做？"><a href="#31-首屏优化该如何去做？" class="headerlink" title="31.首屏优化该如何去做？"></a>31.首屏优化该如何去做？</h4><p>​    1.使用路由懒加载<br>​    2.非首屏组件使用异步组件<br>​    3.首屏不中要的组件延迟加载<br>​    4.静态资源放在CDN上<br>​    5.减少首屏上JS、CSS等资源文件的大小<br>​    6.使用服务端渲染<br>​    7.简历减少DOM的数量和层级<br>​    8.使用精灵图请求<br>​    9.做一些loading<br>​    10.开启Gzip压缩<br>​    11.图片懒加载</p>
<h4 id="32-vue3的性能为什么比vue2好？"><a href="#32-vue3的性能为什么比vue2好？" class="headerlink" title="32.vue3的性能为什么比vue2好？"></a>32.vue3的性能为什么比vue2好？</h4><p>​    1.diff算法的优化<br>​    2.静态提升<br>​    3.事件侦听缓存</p>
<h4 id="33-vue3为什么使用proxy？"><a href="#33-vue3为什么使用proxy？" class="headerlink" title="33.vue3为什么使用proxy？"></a>33.vue3为什么使用proxy？</h4><p>​    1.proxy可以代理整个对象，defineproperty只代理对象上的某个属性<br>​    2.proxy对代理对象的监听更加丰富<br>​    3.proxy代理对象会生成新的对象，不会修改被代理对象本身<br>​    4.proxy补兼容ie浏览器</p>
<h4 id="34-说一下你对组件的理解。"><a href="#34-说一下你对组件的理解。" class="headerlink" title="34.说一下你对组件的理解。"></a>34.说一下你对组件的理解。</h4><p>​    可以重复使用的vue实例，独一无二的组件名称<br>​    可以抽离单独的公共模块<br>​    提高代码的复用率</p>
<h4 id="35-你是如何规划项目文件的？"><a href="#35-你是如何规划项目文件的？" class="headerlink" title="35.你是如何规划项目文件的？"></a>35.你是如何规划项目文件的？</h4><p>​    public<br>​        图标、index.html、img<br>​    src<br>​        api<br>​        assets<br>​        components<br>​            按分类再次划分子目录<br>​        plugins<br>​        router<br>​        static<br>​        styles<br>​        utils<br>​        views<br>​    App.vue<br>​    main.js<br>​    package.json<br>​    vue.config.js</p>
<h4 id="36-是否使用过nuxt-js？"><a href="#36-是否使用过nuxt-js？" class="headerlink" title="36.是否使用过nuxt.js？"></a>36.是否使用过nuxt.js？</h4><p>​    是基于vue的应用框架，关注的是渲染，可以开发服务端渲染应用的配置<br>​    SSR：服务端渲染<br>​        好处：<br>​            SSR生成的是有内容的HTML页面，有利于搜索引擎的搜索<br>​            优化了首屏加载时间<br>​    SEO：优化搜索引擎<br>​    SPA的应用不利于搜索引擎SEO的操作</p>
<h4 id="37-SEO如何优化？"><a href="#37-SEO如何优化？" class="headerlink" title="37.SEO如何优化？"></a>37.SEO如何优化？</h4><p>​    1.SSR<br>​    2.预渲染 prerender-spa-plugin</p>
<h4 id="五、Echarts"><a href="#五、Echarts" class="headerlink" title="五、Echarts"></a>五、Echarts</h4><h4 id="1-echarts有用过吗？常用的组件有哪些？"><a href="#1-echarts有用过吗？常用的组件有哪些？" class="headerlink" title="1.echarts有用过吗？常用的组件有哪些？"></a>1.echarts有用过吗？常用的组件有哪些？</h4><p>​        title标题组件 show  text  link<br>​        toolbox工具栏 导出图片 数据视图 切换 缩放 show orient feature<br>​        tooltip tigger 触发类型<br>​        markPoint标注点<br>​        markLine图标的标线</p>
<h3 id="六、Uni-APP"><a href="#六、Uni-APP" class="headerlink" title="六、Uni-APP"></a>六、Uni-APP</h3><h4 id="1-uni-app有没有做过分包？"><a href="#1-uni-app有没有做过分包？" class="headerlink" title="1.uni-app有没有做过分包？"></a>1.uni-app有没有做过分包？</h4><p>​        优化小程序的下载和启动速度<br>​        小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示</p>
<h3 id="七、Weabpack"><a href="#七、Weabpack" class="headerlink" title="七、Weabpack"></a>七、Weabpack</h3><h4 id="1-webpack打包和不打包的区别？"><a href="#1-webpack打包和不打包的区别？" class="headerlink" title="1.webpack打包和不打包的区别？"></a>1.webpack打包和不打包的区别？</h4><p>​        1.运行效率<br>​        2.对基础的支持不够</p>
<h4 id="2-webpack是怎么打包的，babel是做什么的？"><a href="#2-webpack是怎么打包的，babel是做什么的？" class="headerlink" title="2.webpack是怎么打包的，babel是做什么的？"></a>2.webpack是怎么打包的，babel是做什么的？</h4><p>​        webpack会把js css image看作一个模块，用import&#x2F;require引入<br>​        找到入口文件，通过入口文件找到关联的依赖文件，把他们打包到一起<br>​        把bundle文件，拆分成多个小的文件，异步按需加载所需要的文件<br>​        如果一个被多个文件引用，打包时只会生成一个文件<br>​        如果引用的文件没有调用，不会打包，如果引入的变量和方法没有调用也不会打包<br>​        对于多个入口文件，加入引入了相同的代码，可以用插件把他抽离到公共文件中</p>
<h3 id="八、Git"><a href="#八、Git" class="headerlink" title="八、Git"></a>八、Git</h3><h4 id="1-git如何合并、拉取代码？"><a href="#1-git如何合并、拉取代码？" class="headerlink" title="1.git如何合并、拉取代码？"></a>1.git如何合并、拉取代码？</h4><p>​        拉取代码 git pull ‘仓库地址’<br>​        查看状态 git sattus<br>​        提交到本地缓存区  git add .<br>​        提交本地仓库 git commit -m ‘修改描述’<br>​        提交到远程仓库 git push ‘仓库地址’ master<br>​        创建分支 git branch -b xxx<br>​        合并分支 git merge ‘合并分支的名字’</p>
<h4 id="2-git如何解决冲突问题？"><a href="#2-git如何解决冲突问题？" class="headerlink" title="2.git如何解决冲突问题？"></a>2.git如何解决冲突问题？</h4><p>​        1.两个分支中修改了同一个文件<br>​        2.两个分支中修改了同一个文件的名字<br>​        1.解决：当前分支上，直接修改代码  add  commit<br>​        2.解决：在本地当前分支上，修改冲突代码 add commit push</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://coffeerin.github.io/2024/06/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95-%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">-面试 -八股文</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/06/27/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            防抖和节流
          
        </div>
      </a>
    
    
      <a href="/2024/05/30/MyBatis%E7%AC%94%E8%AE%B0/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">MyBatis笔记</div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> CoffeeLin
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/coffee.svg" alt="CoffeeLin"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/clock">时钟</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>